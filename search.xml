<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HTTP protocol</title>
    <url>/2016/10/25/HTTP/</url>
    <content><![CDATA[<h3 id="名词解析"><a href="#名词解析" class="headerlink" title="名词解析"></a>名词解析</h3><hr>
<ul>
<li><em><strong>URI</strong></em>  :(uniform resource identifier) 统一资源定位符；用来标识互联网上的唯一资源</li>
<li><em><strong>URL</strong></em>  :(uniform resource locator) 统一资源定位器；<br>e.g:<a href="http://user:pass@host.com/path?query=string#hash">http://user:pass@host.com:80/path?query=string#hash</a> 此类格式都叫URL，http，ftp协议等</li>
<li><em><strong>URN</strong></em>  :(Uniform Resource Name) 统一资源名称<br><img src="https://image.ibb.co/iu3WkV/URI-URL-URN.png" alt="img"></li>
</ul>
<span id="more"></span>

<h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><hr>
<h4 id="HTTP请求返回的完整过程："><a href="#HTTP请求返回的完整过程：" class="headerlink" title="HTTP请求返回的完整过程：####"></a>HTTP请求返回的完整过程：####</h4><p><img src="https://image.ibb.co/b01R2A/URL-HTTP.png" alt="img"></p>
<p>其中每个节点都代表HTTP为我们做的事情</p>
<h4 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h4><p>网络模型有七层标准模型和经典五层模型，这里展示五层模型<br><img src="https://image.ibb.co/fKJOhA/image.png" alt="img"></p>
<ul>
<li>物理层：定义物理设备如何传输数据</li>
<li>数据链路层：通信实体间建立数据链路连接</li>
<li>网络层：为数据在实体间传输创建逻辑链路</li>
<li>传输层：向用户提供可靠的端到端(end to end)的服务<br>传输层主要有两个协议TCP和UDP；<br>什么是端到端的服务呢？<br>比如我们建立了客户端到服务器的连接之后，他们两端如何去传输数据，传输的方式都是在这里定义的；<br>我们传输的数据有可能很小有可能很大，如果很大不能一次传输过去，那么就要分包分片；分后传输过去后又如何组装也是在这里定义的；</li>
<li>应用层：为软件提供服务<br>例如HTTP；构建于TCP协议之上的；屏蔽了网络传输相关细节</li>
</ul>
<h3 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h3><hr>
<p><img src="https://image.ibb.co/jKB4pq/HTTP.png" alt="img"></p>
<ol>
<li><strong><strong>http报文都有一个首行（不属于请求头）</strong></strong><ul>
<li>method：GET POST DELET PUT …</li>
<li>URL：</li>
<li>协议版本</li>
<li>返回码code: 不同code代表不同的意思 200,,301，302，404,500等</li>
</ul>
</li>
<li><strong><strong>header</strong></strong><br> 首行换行后就是header</li>
<li><strong><strong>body</strong></strong><br> header 换行后再空行 就是body</li>
</ol>
<h3 id="认识HTTP-Client"><a href="#认识HTTP-Client" class="headerlink" title="认识HTTP Client"></a>认识HTTP Client</h3><hr>
<p>什么是HTTP Client？<br>只要实现了一个发送标准HTTP请求的工具，那就是HTTP Client<br>ps: http只是负责返回数据，而真正展示页面的是浏览器，浏览器拿到数据后对数据进行渲染，得到结果展示给用户</p>
<p>使用 curl 工具，在命令行中 <strong><strong>curl baidu.com</strong></strong>会得到<br><img src="https://image.ibb.co/bWAj7A/curlbaiducom.png" alt="img"><br>为什么和在浏览器看到的不一样？<br>因为浏览器在得到数据解析识别 meta 后，根据 http-equiv 重定向到 <a href="http://www.baidu.com/">www.baidu.com</a></p>
<h3 id="浏览器同域限制"><a href="#浏览器同域限制" class="headerlink" title="浏览器同域限制"></a>浏览器同域限制</h3><hr>
<ul>
<li>跨域如何请求资源？<br>被请求资源的http头设置 ‘Access-Control-Allow-Origin’:’*’; 也可以设置具体的url地址，指定特定的服务能请求<br>e.g：’Access-Control-Allow-Origin’:’<a href="http://donscoco.github.io&/#39;---%E5%8F%AA%E6%9C%89http://donscoco.github.io%E5%8F%AF%E4%BB%A5%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E8%BF%99%E4%B8%AA%E8%B5%84%E6%BA%90">http://donscoco.github.io&#39;---只有http://donscoco.github.io可以跨域请求这个资源</a><br>ps:就算头没有设置，请求也是能请求到，只是浏览器识别不是同一域而且没有’Access-Control-Allow-Origin’所以会忽略</li>
<li>什么是跨域？<br>跨域，指的是浏览器不能执行其他网站的脚本。 它是由浏览器的同源策略造成的，是<strong><strong>浏览器施加的安全限制</strong></strong>。<br>浏览器运行标签上的路径加载内容，不会在乎是否加了’Access-Control-Allow-Origin’:’*’;</li>
<li>CORS预请求</li>
</ul>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><hr>
<p><img src="https://image.ibb.co/dFEACA/image.png" alt="img"></p>
<h4 id="可缓存性"><a href="#可缓存性" class="headerlink" title="可缓存性"></a>可缓存性</h4><p>Cache-Control:<br>http请求所经过的路径中，包括经过的一些http代理服务器都可以对http的内容进行缓存的操作<br>public 浏览器，代理服务器都进行缓存<br>private 只有浏览器缓存<br>no-cache 不缓存</p>
<h4 id="到期"><a href="#到期" class="headerlink" title="到期"></a>到期</h4><p>max-age&#x3D;<seconds><br>设置缓存时间；过期之后浏览器才会再次发送请求到服务端<br>s-maxage&#x3D;<seconds><br>代理服务器读取的缓存时间</p>
<h4 id="重新验证"><a href="#重新验证" class="headerlink" title="重新验证"></a>重新验证</h4><p>must-revalidate 在max-age 过期后用于验证<br>proxy-revalidate 用于缓存服务器的过期验证</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>no-store<br>no-transform </p>
<h4 id="验证头"><a href="#验证头" class="headerlink" title="验证头"></a>验证头</h4><p><code>Last-Modified</code>  上次修改时间<br><code>Etag</code>数据签名:常用的数据签名是对内容进行一个哈希计算；配合if-Match或者if-Non-Match使用对比资源签名判断是否使用缓存;</p>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><hr>
<h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><p>通过Set-Cookie设置      e.g: ‘Set-Cookie’:’id&#x3D;123’</p>
<ul>
<li>cookie结构：cookie是键值对的形式，可以设置多个</li>
<li>cookie流程：cookie是服务器返回的时候设置到浏览器的，保存在浏览器里面的数据，浏览器下一次同域的请求中会带上cookie</li>
<li>多个cookie：使用数组 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;id=123&#x27;</span>,<span class="string">&#x27;name=donscoco&#x27;</span>]</span><br></pre></td></tr></table></figure>
来表示</li>
<li>cookie属性：<br>  属性之间使用<code>;</code>分隔;<br>  <code>max-age</code>和<code>expires</code>设置过期时间；[‘id&#x3D;123’,’name&#x3D;donscoco;max-age&#x3D;10’] max-age是多久过期，expires是到什么时候过期;<br>  <code>Secure</code>只有在https的时候发送;<br>  HttpOnly无法通过document.cookie访问（为了安全考虑，如CSRF攻击）[‘id&#x3D;123’,’name&#x3D;donscoco;HttpOnly’];<br>  cookie共享：不同域名之间的cookie是不能共享的；如果想在一级域名下所有的二级域名都能读到cookie可以在访问一级域名test.com时设置[‘id&#x3D;123’,’name&#x3D;donscoco;domain&#x3D;test.com’]那么a.test.com和b.test.com都可以拿到同样的cookie；<br>  ps：不能跨域名设置cookie；e.g：a.test.com 不能给 test.com 设置cookie</li>
</ul>
<h4 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h4><p>Cookie不等于session；只是两者也是不同的概念，只是一般我们使用cookie来保存session，例如对于每个网站来说每个用户的session都是不一样的，这样客户端请求服务的时候会带上cookie，如果cookie中有之前存放的session，那么服务器就可以识别用户；这里session就是用于定位用户，只要能定位到用户，那就是一种session的实现方案，并不一定非要通过cookie来实现；</p>
<h3 id="HTTP连接"><a href="#HTTP连接" class="headerlink" title="HTTP连接"></a>HTTP连接</h3><hr>
<p>http的请求是建立在TCP的连接上的<br>http请求发送的时候要先去创建一个tcp连接，在tcp连接上面把请求发送并且接受返回；<br>在经过一次请求与返回之后，TCP和服务器的连接如果保持，那下次请求的时候可以直接使用这个TCP连接，但是在没有请求的时候是一种消耗，如果断开，下次请求的时候就要重新去进行三次握手建立连接；<br>tcp默认会同时创建6个连接；如果连接满了剩余的请求就会进入等待，这里是说同时存在6个连接，传输后不一定会继续使用原来的连接，看<code>connection</code>会不会复用，可能是其他连接，但是同时存在的连接不超过6个</p>
<h4 id="TCP长连接"><a href="#TCP长连接" class="headerlink" title="TCP长连接"></a>TCP长连接</h4><p>什么是长连接？客户端和服务端建立TCP连接后保持连接<br>长连接的设置：<code>&#39;connection&#39;:&#39;keep-alive&#39;</code><br>客户端和服务端都可以设置这个字段，这里如果服务端返回的如果是不想保持，浏览器也还是会关掉<br>浏览器请求会尽量地去复用已有的TCP连接，等有剩余的连接空出来;观察下图 ConnectionID和Waterfall字段；<br><img src="https://image.ibb.co/dSGtFV/6.png" alt="img"></p>
<h4 id="TCP短连接"><a href="#TCP短连接" class="headerlink" title="TCP短连接"></a>TCP短连接</h4><p>什么是短连接？客户端和服务端建立TCP连接经过一次请求返回后就关闭连接<br>短连接的设置：’connection’:’close’<br>浏览器不会去复用TCP连接，每个请求都建立一个新的TCP连接;观察下图 ConnectionID和Waterfall字段；<br><img src="https://image.ibb.co/fKW79q/TCP.png" alt="img"></p>
<h4 id="信道复用"><a href="#信道复用" class="headerlink" title="信道复用"></a>信道复用</h4><p>在http2里面；在TCP连接上面，我们可以并发地去放HTTP请求，也就是说，我们在连接一个网站(同域)的时候，只需要一个连接<br><img src="https://image.ibb.co/nPWh9q/image.png" alt="img"></p>
<h3 id="数据协商"><a href="#数据协商" class="headerlink" title="数据协商"></a>数据协商</h3><hr>
<p>概念：客户端向服务端发送请求时，向服务端表明，自己希望拿到的数据格式是怎么样的。</p>
<h4 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h4><ul>
<li><code>Accept</code> 告诉服务器我希望的数据类型，可以是多个，用<code>,</code>分隔</li>
<li><code>Accept-Encoding</code> 告诉服务器我的数据是怎样的编码方式进行传输,流行的有（gzip,deflate,br）</li>
<li><code>Accept-Language</code> 表示我希望要的语言类型,这个一般 是浏览器自动加的，浏览器会根据系统语言来填写这个</li>
<li><code>User-Agent</code> 客户端的类型，告诉服务器我是PC端还是移动端</li>
</ul>
<h4 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h4><ul>
<li><code>Content-Type</code> 表示我实际返回的是什么样的数据格式</li>
<li><code>Content-Encoding</code> 声明我服务端返回的数据是什么编码</li>
<li><code>Content-Language</code> 表示返回的语言类型</li>
</ul>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><h4 id="服务端示例"><a href="#服务端示例" class="headerlink" title="服务端示例"></a>服务端示例</h4><p><img src="https://image.ibb.co/dE7m2A/image.png" alt="img"></p>
<h4 id="客户端访问http-localhost-8080后跳转到http-localhost-8080-new展示"><a href="#客户端访问http-localhost-8080后跳转到http-localhost-8080-new展示" class="headerlink" title="客户端访问http://localhost:8080后跳转到http://localhost:8080/new展示"></a>客户端访问<a href="http://localhost:8080后跳转到http://localhost:8080/new展示">http://localhost:8080后跳转到http://localhost:8080/new展示</a></h4><p><img src="https://image.ibb.co/bOHB2A/image.png" alt="img"><br>这里要状态吗和Location一起使用，状态码设置200依然不会跳转</p>
<h4 id="301和302区别"><a href="#301和302区别" class="headerlink" title="301和302区别"></a>301和302区别</h4><p>301指永久跳转，302是临时跳转<br>浏览器下次再遇到请求那个会跳转301的路径时，会自动再加上跳转后的路径，不用再去经过服务器处理301重定向<br>告诉浏览器下一次再出现这个路径的访问的时候，直接在浏览器这边把他变成一个新的路径就可以了，不用经过服务器再去指定一个新的location而且还会默认在浏览器留下缓存</p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><hr>
<p><strong><strong>HTTP概念</strong></strong>：超文本传输协议（HTTP）是用于传输诸如HTML的超媒体文档的应用层协议。它被设计用于Web浏览器和Web服务器之间的通信，但它也可以用于其他目的。 HTTP遵循经典的客户端-服务端模型，客户端打开一个连接以发出请求，然后等待它收到服务器端响应。 HTTP是无状态协议，意味着服务器不会在两个请求之间保留任何数据（状态）。虽然通常基于TCP &#x2F; IP层，但可以在任何可靠的传输层上使用;也就是说，一个不会静默丢失消息的协议，如UDP。<br><strong><strong>HTTPS概念</strong></strong>：HTTP Strict Transport Security (通常简称为HSTS) 是一个安全功能，它告诉浏览器只能通过HTTPS访问当前资源, 禁止HTTP方式.<br>Strict Transport Security解决了这个问题；只要你通过HTTPS请求访问银行网站，并且银行网站配置好Strict Transport Security，你的浏览器知道自动使用HTTPS请求，这可以阻止黑客的中间人攻击的把戏。<br>HTTP的包是明文传输<br>HTTPS是在HTTP基础上进行加密</p>
<ul>
<li>TTPS协议需要到CA申请证书，一般免费证书很少，需要交费。</li>
<li>HTTPS运行在SSL&#x2F;TLS之上，SSL&#x2F;TLS运行在TCP之上，所有传输的内容都经过加密的。</li>
<li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>
</ul>
<h4 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h4><p>公钥私钥主要是在握手的时候进行传输<br><img src="https://image.ibb.co/fusHsA/image.png" alt="img"></p>
<ul>
<li>私钥</li>
<li>公钥<br>更多参考 <a href="http://www.wxtlife.com/2016/03/27/%E8%AF%A6%E8%A7%A3https%E6%98%AF%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F/">http://www.wxtlife.com/2016/03/27/%E8%AF%A6%E8%A7%A3https%E6%98%AF%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F/</a></li>
</ul>
<h4 id="IN-ACTION"><a href="#IN-ACTION" class="headerlink" title="IN ACTION"></a>IN ACTION</h4><p><strong><strong>证书生成</strong></strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl req -x509 -newkey rsa:2048 -nodes -sha256 -keyout localhost-privkey.pem -out localhost-cert.pem</span><br></pre></td></tr></table></figure>
<p>得到  <strong>localhost-privkey.pem</strong> 和 <strong>localhost-cert.pem</strong> 文件</p>
<p><strong><strong>Nginx 配置</strong></strong>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">proxy_cache_path cache levels=1:2 keys_zone=my_cache:10m;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen       80;</span><br><span class="line">  <span class="comment"># listen       [::]:80 default_server;</span></span><br><span class="line">  server_name  test.com;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># return 302 https://$server_name$request_uri;</span></span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_cache my_cache;</span><br><span class="line">    proxy_pass http://127.0.0.1:8888;</span><br><span class="line">    proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">  listen       443 http2;</span><br><span class="line">  server_name  test.com;</span><br><span class="line"></span><br><span class="line">  http2_push_preload  on;</span><br><span class="line"></span><br><span class="line">  ssl on;</span><br><span class="line">  ssl_certificate_key  ../certs/localhost-privkey.pem;</span><br><span class="line">  ssl_certificate      ../certs/localhost-cert.pem;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_cache my_cache;</span><br><span class="line">    proxy_pass http://127.0.0.1:8888;</span><br><span class="line">    proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h3><hr>
<ul>
<li><p><strong>数据的传输</strong>：<br>  http2 所有数据都是以<strong><strong>二进制</strong></strong>进行传输的，都是以帧进行传输<br>  http1 里面传输是通过<strong><strong>字符串</strong></strong>来传输的<br>  HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮</p>
</li>
<li><p><strong>多路复用</strong><br>  即连接共享，即每一个request都是是用作连接共享机制的。<br>  一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。<br>  多路复用原理图：</p>
</li>
<li><p><strong>请求返回无序</strong>：<br>  http2 同一个连接发送多个请求不需要按照顺序来返回<br>  这个也是数据用帧来传输带来的好处，也进一步带来了可以并发传输，大大增加了效率</p>
</li>
<li><p><strong>头信息压缩</strong><br>  头信息压缩提高效率的功能；<br>  在http1里面每次请求和返回的头都是要完整返回的，但是头里面很多字段都是字符串，会导致传输的额外开销</p>
</li>
<li><p><strong>推送</strong><br>  传统的http请求只能客户端发起请求，然后服务器响应请求；客户端是主动方，服务端是被动方；<br>  在HTTP2里面，服务端是可以主动发起数据传输的<br>  举个栗子：html中都有一些css，js之类的文件，在请求了html文本之后，再根据css，js的地址去请求；顺序是先得到文本在浏览器解析后再去请求css和js，这是一个串行的过程；有推送功能后，在返回html时一起推送css和js，大大提高了效率</p>
</li>
</ul>
<p>http2定义上没有和https相关，但是因为http2是google之前开发的一个叫spdy演化而来，所以，要使用http2要支持https</p>
<h3 id="HTTP和HTTPS区别"><a href="#HTTP和HTTPS区别" class="headerlink" title="HTTP和HTTPS区别"></a>HTTP和HTTPS区别</h3><ul>
<li>HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。</li>
<li>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL&#x2F;TLS之上，SSL&#x2F;TLS运行在TCP之上，所有传输的内容都经过加密的。</li>
<li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>
<li>HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。<br><img src="https://image.ibb.co/hbKu5V/HTTPS.png" alt="img"></li>
</ul>
]]></content>
      <categories>
        <category>Network</category>
        <category>Protocol</category>
        <category>http</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>Thread and Process</title>
    <url>/2018/01/30/Process&amp;&amp;Thread/</url>
    <content><![CDATA[<p>Key difference: Thread and Process are two closely related terms in multi-threading. The main difference between the two terms is that the threads are a part of a process.<br>i.e. a process may contain one or more threads, but a thread cannot contain a process.</p>
<p>In programming, there are two basic units of execution: processes and threads. They both execute a series of instructions. Both are initiated by a program or the operating system. This article helps to differentiate between the two units.</p>
<p>A process is an instance of a program that is being executed. It contains the program code and its current activity. Depending on the operating system, a process may be made up of multiple threads of execution that execute instructions concurrently. A program is a collection of instructions; a process is the actual execution of those instructions.</p>
<p>A process has a self-contained execution environment. It has a complete set of private basic run-time resources; in particular, each process has its own memory space. Processes are often considered similar to other programs or applications. However, the running of a single application may in fact be a set of cooperating processes. To facilitate communication between the processes, most operating systems use Inter Process Communication (IPC) resources, such as pipes and sockets. The IPC resources can also be used for communication between processes on different systems. Most applications in a virtual machine run as a single process. However, it can create additional processes using a process builder object.</p>
<p>In computers, a thread can execute even the smallest sequence of programmed instructions that can be managed independently by an operating system. The applications of threads and processes differ from one operating system to another. However, the threads are made of and exist within a process; every process has at least one. Multiple threads can also exist in a process and share resources, which helps in efficient communication between threads.</p>
<p>On a single processor, multitasking takes place as the processor switches between different threads; it is known as multithreading. The switching happens so frequently that the threads or tasks are perceived to be running at the same time. Threads can truly be concurrent on a multiprocessor or multi-core system, with every processor or core executing the separate threads simultaneously.</p>
<p>In summary, threads may be considered lightweight processes, as they contain simple sets of instructions and can run within a larger process. Computers can run multiple threads and processes at the same time.</p>
<p>Comparison between Process and Thread:</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>Process</strong></th>
<th><strong>Thread</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Definition</td>
<td>An executing instance of a program is called a process.</td>
<td>A thread is a subset of the process.</td>
</tr>
<tr>
<td>Process</td>
<td>It has its own copy of the data segment of the parent process.</td>
<td>It has direct access to the data segment of its process.</td>
</tr>
<tr>
<td>Communication</td>
<td>Processes must use inter-process communication to communicate with sibling processes.</td>
<td>Threads can directly communicate with other threads of its process.</td>
</tr>
<tr>
<td>Overheads</td>
<td>Processes have considerable overhead.</td>
<td>Threads have almost no overhead.</td>
</tr>
<tr>
<td>Creation</td>
<td>New processes require duplication of the parent process.</td>
<td>New threads are easily created.</td>
</tr>
<tr>
<td>Control</td>
<td>Processes can only exercise control over child processes.</td>
<td>Threads can exercise considerable control over threads of the same process.</td>
</tr>
<tr>
<td>Changes</td>
<td>Any change in the parent process does not affect child processes.</td>
<td>Any change in the main thread may affect the behavior of the other threads of the process.</td>
</tr>
<tr>
<td>Memory</td>
<td>Run in separate memory spaces.</td>
<td>Run in shared memory spaces.</td>
</tr>
<tr>
<td>File descriptors</td>
<td>Most file descriptors are not shared.</td>
<td>It shares file descriptors.</td>
</tr>
<tr>
<td>File system</td>
<td>There is no sharing of file system context.</td>
<td>It shares file system context.</td>
</tr>
<tr>
<td>Signal</td>
<td>It does not share signal handling.</td>
<td>It shares signal handling.</td>
</tr>
<tr>
<td>Controlled by</td>
<td>Process is controlled by the operating system.</td>
<td>Threads are controlled by programmer in a program.</td>
</tr>
<tr>
<td>Dependence</td>
<td>Processes are independent.</td>
<td>Threads are dependent.</td>
</tr>
</tbody></table>
<p><a href="http://www.differencebetween.info/difference-between-process-and-thread">http://www.differencebetween.info/difference-between-process-and-thread</a></p>
]]></content>
      <categories>
        <category>os</category>
      </categories>
      <tags>
        <tag>process</tag>
        <tag>thread</tag>
      </tags>
  </entry>
  <entry>
    <title>读写锁</title>
    <url>/2020/10/02/%E8%AF%BB%E5%86%99%E9%94%81%E2%80%94%E2%80%94golang%E4%BE%8B%E5%AD%90/</url>
    <content><![CDATA[<p>看完 golang的 读写锁后做下笔记。</p>
<h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><h4 id="读写锁设计关注的点："><a href="#读写锁设计关注的点：" class="headerlink" title="读写锁设计关注的点："></a>读写锁设计关注的点：</h4><ul>
<li>写锁与写锁的互斥</li>
<li>读锁释放和写锁获取的同步</li>
<li>写锁释放和读锁获取的同步</li>
<li>读饥饿和写饥饿问题</li>
</ul>
<h4 id="RWLock的本质"><a href="#RWLock的本质" class="headerlink" title="RWLock的本质:"></a>RWLock的本质:</h4><ul>
<li>写与写之间的同步 用mutexlock </li>
<li>写与读之间的同步 用readerCount中的：高位——写等待标志位，低位——读记数</li>
<li>为了防止写饥饿，用readerWait配合readerCount高位写等待标志位让读锁阻塞。</li>
<li>为了防止读饥饿，写锁释放前要先唤醒读锁的阻塞，让读锁协程比后来的写锁协程先进入临界区</li>
</ul>
<span id="more"></span>



<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>前置说明</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">runtime_SemacquireMutex</span><br><span class="line">runtime_Semrelease</span><br><span class="line">分别是阻塞和唤醒，里面实际会调用lock2进行自旋等优化，但是因为不是我们主要关注的点，这里我们简单的理解就是阻塞和唤醒了，把精力放在读写之间的同步设计上。</span><br><span class="line"></span><br><span class="line">中间一些竞态代码就用 ... 省略了。不是我们关注的重点</span><br><span class="line"></span><br><span class="line">其中读释放锁调用了 一个 rUnlockSlow 方法，这里我们为了方便整理讨论，直接把这个函数加到释放锁里面</span><br><span class="line"></span><br><span class="line">为了方便讨论说明，我在代码后面加了// 标志：xxx 的字样，然后到下面用 xxx 表示对应的那一行。这个// 标志xxx不是代码中的注释。是我们自己加的，方便指代我们在讨论哪一行。</span><br><span class="line"></span><br><span class="line">使用版本go1.15</span><br></pre></td></tr></table></figure>



<p>主要关注数据结构和4个方法，分别是 写锁获取，写锁释放，读锁获取，读锁释放。</p>
<p>数据结构</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	w           Mutex  <span class="comment">// held if there are pending writers</span></span><br><span class="line">	writerSem   <span class="type">uint32</span> <span class="comment">// semaphore for writers to wait for completing readers</span></span><br><span class="line">	readerSem   <span class="type">uint32</span> <span class="comment">// semaphore for readers to wait for completing writers</span></span><br><span class="line">	readerCount <span class="type">int32</span>  <span class="comment">// number of pending readers</span></span><br><span class="line">	readerWait  <span class="type">int32</span>  <span class="comment">// number of departing readers</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>写锁获取</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Lock() &#123;</span><br><span class="line">	...</span><br><span class="line">	rw.w.Lock() <span class="comment">// 用于阻塞其他写锁 // 标志：lwl</span></span><br><span class="line">	r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders</span><br><span class="line">	<span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class="number">0</span> &#123; <span class="comment">// 记录第几个读锁退出之后要唤醒自己 // 标志：wrw</span></span><br><span class="line">		runtime_SemacquireMutex(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">0</span>) <span class="comment">//阻塞自己，等待读锁唤醒自己 //标志：wbs</span></span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写锁释放</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Unlock() &#123;</span><br><span class="line">	r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(r); i++ &#123;</span><br><span class="line">		runtime_Semrelease(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)<span class="comment">//唤醒阻塞的读锁 //标志：rrs</span></span><br><span class="line">	&#125;</span><br><span class="line">	rw.w.Unlock() <span class="comment">// 标志：rwl</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面 rrs在 rwl 之前执行是为了 防止读锁饥饿；先唤醒 read锁，这样可以保证读锁比其他写锁有优先级，不至于出现读锁一直抢不到锁的情况。</span></span><br></pre></td></tr></table></figure>



<p>读锁获取</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RLock() &#123;</span><br><span class="line">	... </span><br><span class="line">	<span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="number">1</span>) &lt; <span class="number">0</span> &#123; <span class="comment">// 说明有写锁：因为写锁吧高位</span></span><br><span class="line">		runtime_SemacquireMutex(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>) <span class="comment">// 阻塞自己，等待写锁唤醒自己 // 标志：rbs</span></span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读锁释放</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RUnlock() &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> r := atomic.AddInt32(&amp;rw.readerCount, <span class="number">-1</span>); r &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerWait, <span class="number">-1</span>) == <span class="number">0</span> &#123;  <span class="comment">// 判断自己是否是最后一个退出的读锁//标志 rrw</span></span><br><span class="line">			runtime_Semrelease(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">1</span>) <span class="comment">// 唤醒阻塞的写锁 // 标志：wrs</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="个人想法"><a href="#个人想法" class="headerlink" title="个人想法"></a>个人想法</h3><p>声明：以下只是我个人观点，不代表官方设计者一定是这么思考的。个人观点不一定正确。写这个是为了便于以后自己遇到读写锁问题的处理和如何设计能有思路。</p>
<h4 id="读写锁设计关注的点：-1"><a href="#读写锁设计关注的点：-1" class="headerlink" title="读写锁设计关注的点："></a>读写锁设计关注的点：</h4><ul>
<li>写锁与写锁的互斥</li>
<li>读锁释放和写锁获取的同步</li>
<li>写锁释放和读锁获取的同步</li>
<li>读饥饿和写饥饿问题</li>
</ul>
<h4 id="RWLock的本质："><a href="#RWLock的本质：" class="headerlink" title="RWLock的本质："></a>RWLock的本质：</h4><ul>
<li>写与写之间的同步 用mutexlock </li>
<li>写与读之间的同步 用readerCount</li>
<li>为了防止写饥饿，用readerWait配合readerCount高位写等待标志位让读锁阻塞。</li>
<li>为了防止读饥饿，写锁释放前要先唤醒读锁的阻塞</li>
</ul>
<h3 id="设计思路："><a href="#设计思路：" class="headerlink" title="设计思路："></a>设计思路：</h3><hr>
<p>Q：写锁和写锁之间怎么设计同步？</p>
<p>A：直接使用 mutexlock 既可。</p>
<p>看代码中标志 lwl 和 标志  rwl 的行</p>
<hr>
<p>Q：读锁和写锁之间怎么设计同步？</p>
<p>A：需要关注两个点。</p>
<ol>
<li>读锁方需要知道写锁方是否已经到来。</li>
<li>读锁方的协程谁是最后离开的？</li>
</ol>
<p>所以我们需要设计</p>
<ol>
<li>一个标志来让读锁知道写锁已经到来。</li>
<li>记录读锁的数量。好让写锁到来时设置读锁数量（readerWait变量），读锁释放时根据这个数量判断自己是否最后一个</li>
</ol>
<p>同时我们需要把这两个变量具备原子性，万一两条变量中间被修改过就错误了。把这两个变量合为一个变量去处理——</p>
<p>写锁通过设置readerCount 的高位为1来把</p>
<p><code>0000 0000 0000 0000 0000 0000 0000 0000</code> 设置成了</p>
<p> <code>1100 0000 0000 0000 0000 0000 0000 0000</code> 相当于把最高位设置成了1，用高位来设置写锁到来标志。</p>
<p>后续读锁只要看最高位是否为1（也就是判断是否小于0）来知道写锁是否到来。</p>
<p>这就解释了为什么有 <code>readerCount</code>和 <code>readerWait</code>了。</p>
<hr>
<p>Q：读锁释放和写锁获取怎么设计同步？</p>
<p>A：读锁释放时候，最后一个离开的读锁需要唤醒写锁，所以写锁在为读锁阻塞的时候，需要知道在写锁之前的有多少个读锁，所以需要用一个变量来记录，也就是 readerWait。最后一个读锁释放的时候要唤醒阻塞的写锁。</p>
<p>看代码中 标志 wbs和wrs 的行。</p>
<hr>
<p>Q：写锁释放和读锁获取怎么设计同步？</p>
<p>A：读锁在获取锁的时候看到readerCount最高位为1(readerCount&lt;0)。把自己阻塞，等待写锁释放。而写锁在释放的时候需要恢复读写标志，readerCount复原，也就是加上<code>const rwmutexMaxReaders = 1 &lt;&lt; 30</code>，之后检查readerCount是否&gt;0（代表此时有调用读锁的协程在阻塞）。负责唤醒。</p>
<p>看代码中 标志 rbs 和 rrs 的行。</p>
<hr>
<p>Q：读写锁怎么处理写饥饿问题？</p>
<p>A：</p>
<p>解决写饥饿问题：写锁用readerWait来记录自己到来时还有多少读，这些读在最后一个离开的时候负责先唤醒写锁的协程。也就是解决了写饥饿</p>
<p>看代码标志  wrw 和 rrw的行。ps：其实前提条件是还需要读锁判断readerCount 自己阻塞来配合</p>
<hr>
<p>Q：读写锁怎么处理读饥饿问题？</p>
<p>A：</p>
<p>解决读饥饿问题：读锁在看到readerCount中有标志位负数，说明有写锁在阻塞，便把自己阻塞等待这个写锁执行完后唤醒自己。写锁在释放的时候，为了防止其他写锁继续进来抢锁导致读锁饥饿，在释放锁前，先唤醒读锁，再释放锁，这样，读锁就比写锁有更先进入临界区。也就解决了读饥饿问题。</p>
<p>看代码中标志  rrs 和 rwl 的行。</p>
<hr>
<p>Q：这里为什么不只设置最高位？</p>
<p>A：是因为需要预留空间给退出的读锁，也就是预留空间给-1。举个反例，如果设置只有最高位是1（也就是最小的补码），那么-1的时候就溢出变了</p>
<p><code>0111 1111 1111 1111 1111 1111 1111 1111</code> 这样最高位就变成了0，破坏了我们用最高位来设置写锁的标志</p>
<hr>
<p>todo。。。</p>
<h3 id="使用代码"><a href="#使用代码" class="headerlink" title="使用代码"></a>使用代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;os/signal&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;syscall&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mu sync.RWMutex</span><br><span class="line"><span class="keyword">var</span> count <span class="type">int</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1。一开始启动的10个go read，立马就打印出来。说明读他们之间没有相互阻塞</span></span><br><span class="line"><span class="comment">2。第3秒的时候，写锁是一个一个打印出来的，说明读锁之间相互阻塞</span></span><br><span class="line"><span class="comment">3。第7秒的时候（上面写锁的10个因为阻塞还没打印完），又瞬间打印出10个读锁。</span></span><br><span class="line"><span class="comment">	说明第7秒的读锁抢到了读锁，第3秒开始的一批写锁只打印了4个就和第7秒的读锁发生抢占抢占。</span></span><br><span class="line"><span class="comment">	读锁抢占后，后面的其他读锁也一起打印出来（没有被阻塞），10个读锁过后，打印剩下的写锁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">			<span class="keyword">go</span> read(i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">			<span class="keyword">go</span> write(i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(<span class="number">7</span> * time.Second)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">			<span class="keyword">go</span> read(i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	sig := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">	signal.Notify(sig, syscall.SIGTERM, syscall.SIGINT)</span><br><span class="line">	&lt;-sig</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	mu.RLock()</span><br><span class="line">	<span class="keyword">defer</span> mu.RUnlock()</span><br><span class="line">	fmt.Println(<span class="string">&quot;process reading....&quot;</span>, i)</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">	fmt.Println(<span class="string">&quot;process writing....&quot;</span>, i)</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
        <category>锁</category>
        <category>读写锁</category>
        <category>golang</category>
      </categories>
      <tags>
        <tag>锁</tag>
        <tag>个人想法</tag>
        <tag>学习笔记</tag>
        <tag>设计思路</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql</title>
    <url>/2022/10/21/mysql/</url>
    <content><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="mysql-架构"><a href="#mysql-架构" class="headerlink" title="mysql 架构"></a>mysql 架构</h2><img src="/2022/10/21/mysql/mysql-%E7%BB%93%E6%9E%84%E5%9B%BE.png" class="" title="mysql-结构图">

<span id="more"></span>



<p>连接器：</p>
<ul>
<li>tcp连接：连接的过程需要先经过 TCP 三次握手。如果mysql没有启动tcp服务就连接会有   ；</li>
<li>用户名和密码校验：建立TCP连接后，连接器负责用户名和密码的验证。</li>
<li>保存这次会话的用户执行权限：接着连接器会保存这次连接的用户权限，之后的操作都会根据这个权限判断是否能执行。（已经建立的连接，不会被超级管理员修改后的新权限影响）</li>
</ul>
<p>缓存：</p>
<p>mysql 8.0 前的版本，对于SELECT 语句 ，mysql 会先查询缓存Query Cache，缓存是以 key-value 形式保存在内存中的，key 为 SQL 查询语句，value 为 SQL 语句查询的结果。</p>
<p>解析器：</p>
<p>解析器负载对sql语句进行词法解析和语法解析生成语法树</p>
<p>预处理器：</p>
<ul>
<li>检查语法树中的表和字段是否存在。</li>
<li>对  <code>*</code>  等字符进行预处理，做相关替换。例如这里<code>*</code>替换为对应表的所有字段</li>
</ul>
<p>优化器：</p>
<p>优化器负责决定sql如何执行，也就是生成执行计划；例如sql查询语句要使用哪个索引等。主要在 <code>explain</code> 语句中可以看到优化器在执行sql时的决策。</p>
<p>执行器：</p>
<p>执行器负责根据执行计划和存储引擎交互，执行计划主要有三种</p>
<ul>
<li>主键索引搜索</li>
<li>全表搜索</li>
<li>索引下推</li>
</ul>
<h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p>主键索引:</p>
<p>例如执行以下sql</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from students where id = 1 AND name = &#x27;donscoco&#x27;;</span><br></pre></td></tr></table></figure>

<p>执行器 将id &#x3D; 1 传给存储引擎，存储引擎通过主键索引的 B+ 树结构定位到 id &#x3D; 1的记录。执行器从存储引擎读到记录后，接着判断记录是否符合查询条件，如果符合则发送给客户端，如果不符合则跳过该记录。</p>
<p>全表扫描:</p>
<p>例如执行以下sql</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from students where name = &#x27;donscoco&#x27;;</span><br></pre></td></tr></table></figure>

<p>存储引擎每读到一条记录就返回给执行器；执行器检查判断是否 name 和查询字段相等，相等则返回给客户端 （Server 层每从存储引擎读到一条记录就会发送给客户端）。执行器继续让存储引擎扫描，直到扫描完，每扫描一条记录就返回给客户端。（最后客户端会一起展示）</p>
<p>索引下推:</p>
<p>例如执行以下sql</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from students where age &gt; 22 AND name = &#x27;donscoco&#x27;;</span><br></pre></td></tr></table></figure>

<p>一般查询索引后，会进行一个回表操作，执行器根据二级索引拿到主键，再查询到主键索引中的完整record，然后根据这个record中的字段去判断是非符合sql的where，不符合就过滤，继续让存储引擎查找下一条；索引下推其实就是将原本需要执行器去判断的这个操作交给 存储引擎。存储引擎在查询的二级索引中根据字段判断，符合才返回给执行器。</p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>索引的数据结构：B+树</p>
<p>自增主键的插入数据模式，正符合了递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。</p>
<p>（ps，以下不都是名词，例如重建索引，不是一类索引，而是指一个行为）</p>
<p>聚簇索引——主键索引，节点下挂着的是完整的数据。</p>
<p>二级索引——根据定义字段创建的索引，节点下挂着的是主键。</p>
<p>回表——先查询二级索引得到主键，再查询聚簇索引的行为。</p>
<p>覆盖索引——普通索引的节点上的数据就已经满足查询需要，不需要回表的情况下就叫覆盖索引</p>
<p>联合索引——多个字段组成的索引，例如有（id,name,key）表，建立（name,age）的联合索引</p>
<p>最左前缀原则——我们知道索引是一个排序树；单独用name或者用name的like ‘张%’ 可用使用上联合索引（name,age）。因为排序树对比的时候是先对比左边的。</p>
<p>前缀索引——指通过左前缀原则，使用联合索引。例如（name,age）的联合索引，在通过 name查找的时候就能使用上</p>
<p>索引下推——可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p>
<p>唯一索引——保证索引用的key是唯一的</p>
<p>索引区分度——区分度就是某个字段 column 不同值的个数「除以」表的总行数</p>
<p>普通索引——和唯一索引相对立，可能有重复的key。例如 按名字建立二级索引，但是可能有人是重名的。</p>
<p>重建索引——为什么要重建索引？索引可能因为删除，或者页分裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据按顺序插入，这样页面的利用率最高，也就是索引更紧凑、更省空间。（注意，重建主键索引会导致普通的二级索引和联合索引都进行重做，因为主键改变，二级索引的节点用的是主键，自然要重做。所以，如果有重建主键索引的需求要先执行重做主键索引）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 重建主键索引</span></span><br><span class="line">alter table T drop primary key;</span><br><span class="line">alter table T add primary key(<span class="built_in">id</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">## 重建二级索引</span></span><br><span class="line">alter table T drop index k;</span><br><span class="line">alter table T add index(k);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<p>什么时候适用索引？</p>
<ul>
<li>字段有唯一性限制的，比如商品编码；</li>
<li>经常用于 <code>WHERE</code> 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。</li>
<li>经常用于 <code>GROUP BY</code> 和 <code>ORDER BY</code> 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。（联合索引可以用于排序sql优化）</li>
</ul>
<p>什么时候不需要创建索引？</p>
<ul>
<li><code>WHERE</code> 条件，<code>GROUP BY</code>，<code>ORDER BY</code> 里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。</li>
<li>字段中存在大量重复数据，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。</li>
<li>表数据太少的时候，不需要创建索引；</li>
<li>经常更新的字段不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。</li>
</ul>
<p>有什么优化索引的方法？</p>
<ul>
<li>前缀索引优化；——使用前缀索引是为了减小索引字段大小（节省空间）</li>
<li>覆盖索引优化；——不用回表（提升性能）</li>
<li>主键索引最好是自增的；——有效预防页分裂导致的空间浪费</li>
<li>防止索引失效；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##### 主键索引最好是自增的:</span></span><br><span class="line">如果我们使用自增主键，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次插入一条新记录，都是追加操作，不需要重新移动数据，因此这种插入数据的方法效率非常高。</span><br><span class="line">如果我们使用非自增主键，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为页分裂。页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##### 常见索引失效场景</span></span><br><span class="line">联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</span><br><span class="line">左模糊匹配——当我们使用左或者左右模糊匹配的时候，也就是 like %xx 或者 like %xx%这两种方式都会造成索引失效；</span><br><span class="line">函数计算——当我们在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效；</span><br><span class="line">OR 条件 ——在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</span><br><span class="line">索引列隐式数据类型转化——</span><br><span class="line">对索引列进行表达式计算——</span><br></pre></td></tr></table></figure>



<h2 id="数据页（Innodb引擎的）"><a href="#数据页（Innodb引擎的）" class="headerlink" title="数据页（Innodb引擎的）"></a>数据页（Innodb引擎的）</h2><p><strong>InnoDB 的数据是按「数据页」为单位来读写的</strong>，也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。</p>
<p><strong>数据库的 I&#x2F;O 操作的最小单位是页</strong>，<strong>InnoDB 数据页的默认大小是 16KB</strong>，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。</p>
<img src="/2022/10/21/mysql/mysql-%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84.drawio.png" class="" title="数据页结构">

<p>在 File Header 中有两个指针，分别指向上一个数据页和下一个数据页，连接起来的页相当于一个双向的链表，如下图所示：</p>
<img src="/2022/10/21/mysql/mysql-%E6%95%B0%E6%8D%AE%E9%A1%B5%E5%85%B3%E7%B3%BB%E5%9B%BE.drawio.png" class="">

<p>数据页的主要作用是存储记录，也就是数据库的数据，所以重点说一下数据页中的 User Records 是怎么组织数据的。</p>
<p><strong>数据页中的记录按照「主键」顺序组成单向链表</strong>，单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。</p>
<p>因此，数据页中有一个<strong>页目录</strong>，起到记录的索引作用，就像书籍那样，针对书中内容的每个章节设立了一个目录，想看某个章节的时候，可以查看目录，快速找到对应的章节的页数，而数据页中的页目录就是为了能快速找到记录。</p>


<p>页目录创建的过程如下：</p>
<ol>
<li>将所有的记录划分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录；</li>
<li>每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段（上图中粉红色字段）</li>
<li>页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），<strong>每个槽相当于指针指向了不同组的最后一个记录</strong>。</li>
</ol>
<p>从图可以看到，<strong>页目录就是由多个槽组成的，槽相当于分组记录的索引</strong>。然后，因为记录是按照「主键值」从小到大排序的，所以<strong>我们通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到对应的记录</strong>，无需从最小记录开始遍历整个页中的记录链表。</p>
<p>以上面那张图举个例子，5 个槽的编号分别为 0，1，2，3，4，我想查找主键为 11 的用户记录：</p>
<ul>
<li>先二分得出槽中间位是 (0+4)&#x2F;2&#x3D;2 ，2号槽里最大的记录为 8。因为 11 &gt; 8，所以需要从 2 号槽后继续搜索记录；</li>
<li>再使用二分搜索出 2 号和 4 槽的中间位是 (2+4)&#x2F;2&#x3D; 3，3 号槽里最大的记录为 12。因为 11 &lt; 12，所以主键为 11 的记录在 3 号槽里；</li>
<li>这里有个问题，<strong>「槽对应的值都是这个组的主键最大的记录，如何找到组里最小的记录」</strong>？比如槽 3 对应最大主键是 12 的记录，那如何找到最小记录 9。解决办法是：通过槽 3 找到 槽 2 对应的记录，也就是主键为 8 的记录。主键为 8 的记录的下一条记录就是槽 3 当中主键最小的 9 记录，然后开始向下搜索 2 次，定位到主键为 11 的记录，取出该条记录的信息即为我们想要查找的内容。</li>
</ul>
<p>InnoDB 对每个分组中的记录条数都是有规定的，槽内的记录就只有几条：</p>
<ul>
<li>第一个分组中的记录只能有 1 条记录；</li>
<li>最后一个分组中的记录条数范围只能在 1-8 条之间；</li>
<li>剩下的分组中记录条数范围只能在 4-8 条之间。</li>
</ul>
<p>InnoDB 里的 B+ 树中的<strong>每个节点都是一个数据页</strong></p>
<img src="/2022/10/21/mysql/mysql-B+%E6%A0%91%E6%95%B0%E6%8D%AE%E9%A1%B5.png" class="">

<p>通过上图，我们看出 B+ 树的特点：</p>
<ul>
<li>只有叶子节点（最底层的节点）才存放了数据，非叶子节点（其他上层节）仅用来存放目录项作为索引。</li>
<li>非叶子节点分为不同层次，通过分层来降低每一层的搜索量；</li>
<li>所有节点按照索引键大小排序，构成一个双向链表，便于范围查询；</li>
</ul>
<h2 id="为什么-MySQL-采用-B-树作为索引"><a href="#为什么-MySQL-采用-B-树作为索引" class="headerlink" title="为什么 MySQL 采用 B+ 树作为索引?"></a>为什么 MySQL 采用 B+ 树作为索引?</h2><p>要设计一个 MySQL 的索引数据结构，不仅仅考虑数据结构增删改的时间复杂度，更重要的是要考虑磁盘 I&#x2F;0 的操作次数。因为索引和记录都是存放在硬盘，硬盘是一个非常慢的存储设备，我们在查询数据的时候，最好能在尽可能少的磁盘 I&#x2F;0 的操作次数内完成。</p>
<p>二分查找树虽然是一个天然的二分结构，能很好的利用二分查找快速定位数据，但是它存在一种极端的情况，每当插入的元素都是树内最大的元素，就会导致二分查找树退化成一个链表，此时查询复杂度就会从 O(logn)降低为 O(n)。</p>
<p>为了解决二分查找树退化成链表的问题，就出现了自平衡二叉树，保证了查询操作的时间复杂度就会一直维持在 O(logn) 。但是它本质上还是一个二叉树，每个节点只能有 2 个子节点，随着元素的增多，树的高度会越来越高。</p>
<p>而树的高度决定于磁盘 I&#x2F;O 操作的次数，因为树是存储在磁盘中的，访问每个节点，都对应一次磁盘 I&#x2F;O 操作，也就是说树的高度就等于每次查询数据时磁盘 IO 操作的次数，所以树的高度越高，就会影响查询性能。</p>
<p>B 树和 B+ 都是通过多叉树的方式，会将树的高度变矮，所以这两个数据结构非常适合检索存于磁盘中的数据。</p>
<p>但是 MySQL 默认的存储引擎 InnoDB 采用的是 B+ 作为索引的数据结构，原因有：</p>
<ul>
<li>B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I&#x2F;O次数会更少。</li>
<li>B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；</li>
<li>B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I&#x2F;O 操作，范围查询效率不如 B+ 树。</li>
</ul>
<h2 id="MySQL-单表不要超过-2000W-行"><a href="#MySQL-单表不要超过-2000W-行" class="headerlink" title="MySQL 单表不要超过 2000W 行"></a>MySQL 单表不要超过 2000W 行</h2><p>看下 这个实验 ： 原文链接：<a href="https://my.oschina.net/u/4090830/blog/5559454">https://my.oschina.net/u/4090830/blog/5559454</a></p>
<p>MySQL 为了提高性能，会将表的索引装载到内存中，在 InnoDB buffer size 足够的情况下，其能完成全加载进内存，查询不会有问题。</p>
<p>但是，当单表数据库到达某个量级的上限时，导致内存无法存储其索引，使得之后的 SQL 查询会产生磁盘 IO，从而导致性能下降，所以增加硬件配置（比如把内存当磁盘使），可能会带来立竿见影的性能提升哈。</p>
<p>在保持相同的层级（相似查询性能）的情况下，在行数据大小不同的情况下，其实这个最大建议值也是不同的，而且影响查询性能的还有很多其他因素，比如，数据库版本，服务器配置，sql 的编写等等。（例如2000W是默认 每行数据 1KB左右的，每页大概放15条。当每行放的不只1KB，那每页放的就更少条。对应的，为了使得B+树高度不超过3，对应总行数也要减少）</p>
<p>索引结构不会影响单表最大行数，2000W 也只是推荐值，超过了这个值可能会导致 B + 树层级更高，影响查询性能。（层级变高代表磁盘IO次数变多）</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="事务有哪些特性？ACID"><a href="#事务有哪些特性？ACID" class="headerlink" title="事务有哪些特性？ACID"></a>事务有哪些特性？ACID</h2><p>要实现事务必须要遵守 4 个特性，分别如下：</p>
<ul>
<li><strong>原子性（Atomicity）</strong>：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样，就好比买一件商品，购买成功时，则给商家付了钱，商品到手；购买失败时，则商品在商家手中，消费者的钱也没花出去。</li>
<li><strong>一致性（Consistency）</strong>：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。比如，用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加 200 元。一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况（该情况，用户 A 和 B 均为 600 元，总共 1200 元）。</li>
<li><strong>隔离性（Isolation）</strong>：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。也就是说，消费者购买商品这个事务，是不影响其他消费者购买的。</li>
<li><strong>持久性（Durability）</strong>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ul>
<p>InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？</p>
<ul>
<li>持久性是通过 redo log （重做日志）来保证的；</li>
<li>原子性是通过 undo log（回滚日志） 来保证的；</li>
<li>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；</li>
<li>一致性则是通过持久性+原子性+隔离性来保证；</li>
</ul>
<h2 id="并行事务会引发什么问题？"><a href="#并行事务会引发什么问题？" class="headerlink" title="并行事务会引发什么问题？"></a>并行事务会引发什么问题？</h2><p>MySQL 服务端是允许多个客户端连接的，这意味着 MySQL 会出现同时处理多个事务的情况。</p>
<p>那么<strong>在同时处理多个事务的时候，就可能出现</strong></p>
<ul>
<li><strong>脏读（dirty read）</strong>——如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。</li>
<li><strong>不可重复读（non-repeatable read）</strong>——在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象</li>
<li><strong>幻读（phantom read）</strong>——在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。</li>
</ul>
<h2 id="事务的隔离级别有哪些？"><a href="#事务的隔离级别有哪些？" class="headerlink" title="事务的隔离级别有哪些？"></a>事务的隔离级别有哪些？</h2><p>SQL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低，这四个隔离级别如下：</p>
<ul>
<li><strong>读未提交（*read uncommitted*）</strong>，指一个事务还没提交时，它做的变更就能被其他事务看到；</li>
<li><strong>读提交（*read committed*）</strong>，指一个事务提交之后，它做的变更才能被其他事务看到；</li>
<li><strong>可重复读（*repeatable read*）</strong>，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<strong>MySQL InnoDB 引擎的默认隔离级别</strong>；</li>
<li><strong>串行化（*serializable* ）</strong>；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</li>
</ul>
<h2 id="可重复读是如何工作的？-MVCC工作原理）"><a href="#可重复读是如何工作的？-MVCC工作原理）" class="headerlink" title="可重复读是如何工作的？(MVCC工作原理）"></a>可重复读是如何工作的？(MVCC工作原理）</h2><p><strong>可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View</strong>。</p>
<ul>
<li>read-view</li>
<li>聚簇索引记录中的两个隐藏列。</li>
</ul>
<h3 id="read-view"><a href="#read-view" class="headerlink" title="read-view"></a>read-view</h3><p>Read View 有四个重要的字段：</p>
<ul>
<li>m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的<strong>事务 id 列表</strong>，注意是一个列表，<strong>“活跃事务”指的就是，启动了但还没提交的事务</strong>。</li>
<li>min_trx_id ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 <strong>id 最小的事务</strong>，也就是 m_ids 的最小值。</li>
<li>max_trx_id ：这个并不是 m_ids 的最大值，而是<strong>创建 Read View 时当前数据库中应该给下一个事务的 id 值</strong>，也就是全局事务中最大的事务 id 值 + 1；</li>
<li>creator_trx_id ：指的是<strong>创建该 Read View 的事务的事务 id</strong>。</li>
</ul>
<h3 id="隐藏列"><a href="#隐藏列" class="headerlink" title="隐藏列"></a>隐藏列</h3><p>对于使用 InnoDB 存储引擎的数据库表，它的聚簇索引记录中都包含下面两个隐藏列：</p>
<ul>
<li>trx_id，当一个事务对某条聚簇索引记录进行改动时，就会<strong>把该事务的事务 id 记录在 trx_id 隐藏列里</strong>；</li>
<li>roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后<strong>这个隐藏列是个指针，指向每一个旧版本记录</strong>，于是就可以通过它找到修改前的记录。</li>
</ul>
<img src="/2022/10/21/mysql/mysql-%E9%9A%90%E8%97%8F%E5%88%97.drawio.png" class="">



<p>一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：</p>
<ul>
<li><p>如果记录的 trx_id 值小于 Read View 中的 <code>min_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>前</strong>已经提交的事务生成的，所以该版本的记录对当前事务<strong>可见</strong>。</p>
</li>
<li><p>如果记录的 trx_id 值大于等于 Read View 中的 <code>max_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>后</strong>才启动的事务生成的，所以该版本的记录对当前事务<strong>不可见</strong>。</p>
</li>
<li><p>如果记录的 trx_id 值在 Read View 的min_trx_id和max_trx_id之间，需要判断 trx_id 是否在 m_ids 列表中：</p>
<ul>
<li>如果记录的 trx_id <strong>在</strong> <code>m_ids</code> 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务<strong>不可见</strong>。（哪怕这些活跃事务后面提交了。在本事务创建的那一时刻是还没提交的。就当做看不见。）</li>
<li>如果记录的 trx_id <strong>不在</strong> <code>m_ids</code>列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务<strong>可见</strong>。</li>
</ul>
</li>
</ul>
<p>本质就是记录在创建事务那一时刻的<strong>已提交</strong>和<strong>未提交（包括为开始）</strong>，自己的事务只关注创建事务那一个时间点的已提交和自己的事务。后续每次查询，拿这个行的<strong>trx_id</strong>检查，只要不是自己的或者不是”创建事务那个时刻的已提交”都进行回滚。而怎么判断是不是自己的？对比row trx_id 和自己的 transaction_id 就行，那怎么判断 是否是当时的已提交呢？已提交有很多。不可能一个个去看。所以每个可重复读事务才会维护一个数组保存未提交事务id。</p>
<h3 id="MVCC工作流程"><a href="#MVCC工作流程" class="headerlink" title="MVCC工作流程"></a>MVCC工作流程</h3><p>事务 B 第一次读小林的账户余额记录，在找到记录后，它会先看这条记录的 trx_id，此时<strong>发现 trx_id 为 50，比事务 B 的 Read View 中的 min_trx_id 值（51）还小，这意味着修改这条记录的事务早就在事务 B 启动前提交过了，所以该版本的记录对事务 B 可见的</strong>，也就是事务 B 可以获取到这条记录。</p>
<p>接着，事务 A 通过 update 语句将这条记录修改了（还未提交事务），将小林的余额改成 200 万，这时 MySQL 会记录相应的 undo log，并以链表的方式串联起来，形成<strong>版本链</strong>，如下图：</p>
<img src="/2022/10/21/mysql/mysql-%E4%BA%8B%E5%8A%A1ab%E7%9A%84%E8%A7%86%E5%9B%BE.png" class="">

<p>你可以在上图的「记录的字段」看到，由于事务 A 修改了该记录，以前的记录就变成旧版本记录了，于是最新记录和旧版本记录通过链表的方式串起来，而且最新记录的 trx_id 是事务 A 的事务 id（trx_id &#x3D; 51）。</p>
<p>然后事务 B 第二次去读取该记录，<strong>发现这条记录的 trx_id 值为 51，在事务 B 的 Read View 的 min_trx_id 和 max_trx_id 之间，则需要判断 trx_id 值是否在 m_ids 范围内，判断的结果是在的，那么说明这条记录是被还未提交的事务修改的，这时事务 B 并不会读取这个版本的记录。而是沿着 undo log 链条往下找旧版本的记录，直到找到 trx_id 「小于」事务 B 的 Read View 中的 min_trx_id 值的第一条记录</strong>，所以事务 B 能读取到的是 trx_id 为 50 的记录，也就是小林余额是 100 万的这条记录。</p>
<p>最后，当事物 A 提交事务后，<strong>由于隔离级别时「可重复读」，所以事务 B 再次读取记录时，还是基于启动事务时创建的 Read View 来判断当前版本的记录是否可见。所以，即使事物 A 将小林余额修改为 200 万并提交了事务， 事务 B 第三次读取记录时，读到的记录都是小林余额是 100 万的这条记录</strong>。</p>
<p>就是通过这样的方式实现了，「可重复读」隔离级别下在事务期间读到的记录都是事务启动前的记录。</p>
<h3 id="读提交是如何工作的？"><a href="#读提交是如何工作的？" class="headerlink" title="读提交是如何工作的？"></a>读提交是如何工作的？</h3><p><strong>读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View</strong>。</p>
<p>也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。</p>
<p>和 可重复读类似，只不过这个视图 不是事务创建时的。视图维护的数组每次都在变。每次修改都要去看当前活跃的事务id</p>
<p>读的概念</p>
<ul>
<li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li>
<li>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li>
</ul>
<h4 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h4><p>执行「开始事务」命令，并不意味着启动了事务。在 MySQL 有两种开启事务的命令，分别是：</p>
<ul>
<li>第一种：begin&#x2F;start transaction 命令；</li>
<li>第二种：start transaction with consistent snapshot 命令；</li>
</ul>
<p>这两种开启事务的命令，事务的启动时机是不同的：</p>
<ul>
<li>执行了 begin&#x2F;start transaction 命令后，并不代表事务启动了。只有在执行这个命令后，执行了增删查改操作的 SQL 语句，才是事务真正启动的时机；</li>
<li>执行了 start transaction with consistent snapshot 命令，就会马上启动事务。</li>
</ul>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>全局锁</p>
<p>表级锁</p>
<p>行级锁</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">flush tables with <span class="built_in">read</span> lock <span class="comment">### 锁住</span></span><br><span class="line"></span><br><span class="line">unlock tables <span class="comment">### 释放</span></span><br></pre></td></tr></table></figure>

<p>全局锁主要应用于做<strong>全库逻辑备份</strong>，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</p>
<hr>
<h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>获取表锁</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//表级别的共享锁，也就是读锁；</span><br><span class="line">lock tables t_student <span class="built_in">read</span>;</span><br><span class="line"></span><br><span class="line">//表级别的独占锁，也就是写锁；</span><br><span class="line">lock tables t_stuent write;</span><br></pre></td></tr></table></figure>

<p>释放表锁</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unlock tables</span><br></pre></td></tr></table></figure>

<p>当会话退出后，也会释放所有表锁。</p>
<hr>
<h3 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h3><p>再来说说<strong>元数据锁</strong>（MDL）。</p>
<p>我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：</p>
<ul>
<li>对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；</li>
<li>对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；</li>
</ul>
<p>MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。</p>
<p>当有线程在执行 select 语句（ 加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL 写锁），那么将会被阻塞，直到执行完 select 语句（ 释放 MDL 读锁）。</p>
<p>反之，当有线程对表结构进行变更（ 加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（ 申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（ 释放 MDL 写锁）。</p>
<hr>
<p>MDL 不需要显示调用，那它是在什么时候释放的?</p>
<p>MDL 是在事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong>。</p>
<p>那如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），那在对表结构做变更操作的时候，可能会发生意想不到的事情，比如下面这个顺序的场景：</p>
<ol>
<li>首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 select 语句，此时就先对该表加上 MDL 读锁；</li>
<li>然后，线程 B 也执行了同样的 select 语句，此时并不会阻塞，因为「读读」并不冲突；</li>
<li>接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞，</li>
</ol>
<p>那么在线程 C 阻塞后，后续有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。</p>
<hr>
<p>为什么线程 C 因为申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞？</p>
<p>这是因为申请 MDL 锁的操作会形成一个队列，队列中<strong>写锁获取优先级高于读锁</strong>，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。</p>
<p>所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 kill 掉这个长事务，然后再做表结构的变更。</p>
<hr>
<h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁 *"></a>意向锁 *</h3><ul>
<li>在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；</li>
<li>在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；</li>
</ul>
<p>也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。</p>
<p>而普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。</p>
<p>不过，select 也是可以对记录加共享锁和独占锁的，具体方式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//先在表上加上意向共享锁，然后对读取的记录加共享锁</span><br><span class="line">select ... lock <span class="keyword">in</span> share mode;</span><br><span class="line"></span><br><span class="line">//先在表上加上意向独占锁，然后对读取的记录加独占锁</span><br><span class="line">select ... <span class="keyword">for</span> update;</span><br></pre></td></tr></table></figure>

<p><strong>意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（*lock tables … read*）和独占表锁（*lock tables … write*）发生冲突。</strong></p>
<p>表锁和行锁是满足读读共享、读写互斥、写写互斥的。</p>
<p>如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。</p>
<p>那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。</p>
<p>所以，<strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong>。</p>
<hr>
<h3 id="AUTO-INC-锁"><a href="#AUTO-INC-锁" class="headerlink" title="AUTO-INC 锁"></a>AUTO-INC 锁</h3><p>最后，说说 <strong>AUTO-INC 锁</strong>。</p>
<p>在为某个字段声明 <code>AUTO_INCREMENT</code> 属性时，之后可以在插入数据时，可以不指定该字段的值，数据库会自动给该字段赋值递增的值，这主要是通过 AUTO-INC 锁实现的。</p>
<p>AUTO-INC 锁是特殊的表锁机制，锁<strong>不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放</strong>。</p>
<p><strong>在插入数据时，会加一个表级别的 AUTO-INC 锁</strong>，然后为被 <code>AUTO_INCREMENT</code> 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。</p>
<p>那么，一个事务在持有 AUTO-INC 锁的过程中，其他事务的如果要向该表插入语句都会被阻塞，从而保证插入数据时，被 <code>AUTO_INCREMENT</code> 修饰的字段的值是<strong>连续递增</strong>的。</p>
<p>但是， AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。</p>
<p>因此， 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种<strong>轻量级的锁</strong>来实现自增。</p>
<p>一样也是在插入数据的时候，会为被 <code>AUTO_INCREMENT</code> 修饰的字段加上轻量级锁，<strong>然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁</strong>。</p>
<p>InnoDB 存储引擎提供了个 innodb_autoinc_lock_mode 的系统变量，是用来控制选择用 AUTO-INC 锁，还是轻量级的锁。</p>
<ul>
<li>当 innodb_autoinc_lock_mode &#x3D; 0，就采用 AUTO-INC 锁；</li>
<li>当 innodb_autoinc_lock_mode &#x3D; 2，就采用轻量级锁；</li>
<li>当 innodb_autoinc_lock_mode &#x3D; 1，这个是默认值，两种锁混着用，如果能够确定插入记录的数量就采用轻量级锁，不确定时就采用 AUTO-INC 锁。</li>
</ul>
<p>不过，当 innodb_autoinc_lock_mode &#x3D; 2 是性能最高的方式，但是会带来一定的问题。因为并发插入的存在，在每次插入时，自增长的值可能不是连续的，<strong>这在有主从复制的场景中是不安全的</strong>。</p>
<p>例如事务会滚会导致主键增长不是连续的。（但是还是可以确保递增的）（例如事务A insert，虽然另一个事务B要insert的时候被间隙锁阻塞，但是id已经分配，等事务A回滚，B的insert写入，中间事务A原本的那个id位置就是空的）</p>
<hr>
<h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><p>在mysql innodb中 共享锁的符号是S ，独占锁的符号是X， 所以有时候用S锁和X锁来指代。</p>
<p>前面也提到，普通的 select 语句是不会对记录加锁的，因为它属于快照读。如果要在查询时对记录加行锁，可以使用下面这两个方式，这种查询会加锁的语句称为<strong>锁定读</strong>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//对读取的记录加共享锁</span><br><span class="line">select ... lock <span class="keyword">in</span> share mode;</span><br><span class="line"></span><br><span class="line">//对读取的记录加独占锁</span><br><span class="line">select ... <span class="keyword">for</span> update;</span><br></pre></td></tr></table></figure>

<p>上面的语句使用必须在事务中，<strong>因为当事务提交了，锁就会被释放</strong>，所以在使用这两条语句的时候，要加上 begin、start transaction 或者 set autocommit &#x3D; 0。</p>
<p>共享锁（S锁）满足读读共享，读写互斥。独占锁（X锁）满足写写互斥、读写互斥。</p>
<table>
<thead>
<tr>
<th></th>
<th>X</th>
<th>S</th>
</tr>
</thead>
<tbody><tr>
<td>X</td>
<td>冲突</td>
<td>冲突</td>
</tr>
<tr>
<td>S</td>
<td>冲突</td>
<td>不冲突</td>
</tr>
</tbody></table>
<p>行级锁的类型主要有三类：</p>
<ul>
<li>Record Lock，记录锁，也就是仅仅把一条记录锁上；</li>
<li>Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；</li>
<li>Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</li>
</ul>
<h3 id="Record-Lock"><a href="#Record-Lock" class="headerlink" title="Record Lock"></a>Record Lock</h3><p>Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：</p>
<ul>
<li>当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;</li>
<li>当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。</li>
</ul>
<p>举个例子，当一个事务执行了下面这条语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql &gt; begin;</span><br><span class="line">mysql &gt; select * from t_test where id = 1 for update;</span><br></pre></td></tr></table></figure>

<p>就是对 t_test 表中主键 id 为 1 的这条记录加上 X 型的记录锁，这样其他事务就无法对这条记录进行修改了。</p>
<p>当事务执行 commit 后，事务过程中生成的锁都会被释放。</p>
<h3 id="Gap-Lock"><a href="#Gap-Lock" class="headerlink" title="Gap Lock"></a>Gap Lock</h3><p>Gap Lock 称为间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。</p>
<p>假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id &#x3D; 4 这条记录了，这样就有效的防止幻读现象的发生。</p>
<p>间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，<strong>间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的</strong>。（但是有一点要注意，<strong>next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的</strong>。也就是只有间隙锁才不会互斥，例如 （a,b）兼容，（a,b] 不兼容）</p>
<h3 id="Next-Key-Lock"><a href="#Next-Key-Lock" class="headerlink" title="Next-Key Lock"></a>Next-Key Lock</h3><p>Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</p>
<p>假设，表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id &#x3D; 4 记录，也不能修改 id &#x3D; 5 这条记录。</p>
<p>所以，next-key lock 即能保护该记录，又能阻止其他事务将新纪录插入到被保护记录前面的间隙中。</p>
<p><strong>next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的</strong>。</p>
<p>比如，一个事务持有了范围为 (1, 10] 的 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，就会被阻塞。</p>
<p>虽然相同范围的间隙锁是多个事务相互兼容的，但对于记录锁，我们是要考虑 X 型与 S 型关系，X 型的记录锁与 X 型的记录锁是冲突的。</p>
<h3 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁 *"></a>插入意向锁 *</h3><p>一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。</p>
<p>如果有的话，插入操作就会发生<strong>阻塞</strong>，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个<strong>插入意向锁</strong>，表明有事务想在某个区间插入新记录，但是现在处于等待状态。</p>
<p>当事务 A 还没提交的时候，事务 B 向该表插入一条 id &#x3D; 4 的新记录，这时会判断到插入的位置已经被事务 A 加了间隙锁，于是事物 B 会生成一个插入意向锁，然后将锁的状态设置为等待状态（<em>PS：MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁</em>），此时事务 B 就会发生阻塞，直到事务 A 提交了事务。</p>
<p>插入意向锁名字虽然有意向锁，但是它并<strong>不是意向锁，它是一种特殊的间隙锁，属于行级别锁</strong>。<strong>该锁只用于并发插入操作</strong>。</p>
<p>如果说间隙锁锁住的是一个区间，那么「插入意向锁」锁住的就是一个点。因而从这个角度来说，插入意向锁确实是一种特殊的间隙锁。</p>
<p>插入意向锁与间隙锁的另一个非常重要的差别是：尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不在间隙锁区间内则是可以的）。</p>
<p>插入意向锁的生成时机：</p>
<ul>
<li>每插入一条新记录，都需要看一下待插入记录的下一条记录上是否已经被加了间隙锁，如果已加间隙锁，此时会生成一个插入意向锁，然后锁的状态设置为等待状态（<em>PS：MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁</em>），现象就是 Insert 语句会被阻塞。</li>
</ul>
<hr>
<h2 id="MySQL-是怎么加锁的？"><a href="#MySQL-是怎么加锁的？" class="headerlink" title="MySQL 是怎么加锁的？"></a>MySQL 是怎么加锁的？</h2><p>主要关注三个点：是否唯一索引列；是等值查找还是范围查找；是否存在对应节点记录</p>
<p>对记录加锁时，<strong>加锁的基本单位是 next-key lock</strong>，它是由记录锁和间隙锁组合而成的，<strong>next-key lock 是前开后闭区间，而间隙锁是前开后开区间</strong>。</p>
<p>next-key lock 在一些场景下会退化成记录锁或间隙锁。</p>
<p>唯一索引等值查询：</p>
<ul>
<li>当查询的记录是存在的，next-key lock 会退化成「记录锁」。</li>
<li>当查询的记录是不存在的，next-key lock 会退化成「间隙锁」。</li>
</ul>
<p>非唯一索引等值查询：</p>
<ul>
<li>当查询的记录存在时，除了会加 next-key lock 外，还额外加间隙锁，也就是会加两把锁。</li>
<li>当查询的记录不存在时，只会加 next-key lock，然后会退化为间隙锁，也就是只会加一把锁。</li>
</ul>
<p>非唯一索引和主键索引的范围查询的加锁规则不同之处在于：</p>
<ul>
<li>唯一索引在满足一些条件的时候，next-key lock 退化为间隙锁和记录锁。</li>
<li>非唯一索引范围查询，next-key lock 不会退化为间隙锁和记录锁。</li>
</ul>
<p>小技巧：看情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">直接先按照next-key方式吧所有能覆盖查找范围的节点找到(如果最右边刚好是64的话还要继续往右找一个节点)，例如：</span><br><span class="line">(8,16],(16,32],(32,64] <span class="comment">## 如果是 where x&gt;9 and x&lt;=64 则多找一个 (64,128]</span></span><br><span class="line">然后</span><br><span class="line">等值唯一存在：左边间隙拿掉</span><br><span class="line">等值唯一不存在：右边记录锁拿掉</span><br><span class="line">等值非唯一存在：右边加上间隙</span><br><span class="line">等值非唯一不存在：右边记录锁拿掉</span><br><span class="line"></span><br><span class="line">范围唯一存在：左边间隙拿掉</span><br><span class="line">范围唯一不存在：右边记录锁拿掉</span><br><span class="line">范围非唯一存在：不变</span><br><span class="line">范围非唯一不存在：不变</span><br><span class="line">还有就是如果右边是 supernum 是不会退化的 ，例如：(1024,supernum] 在 非唯一中 还是 (1024,supernum] 不会 (1024,supernum) </span><br></pre></td></tr></table></figure>





<hr>
<h2 id="update-没加索引会怎样？"><a href="#update-没加索引会怎样？" class="headerlink" title="update 没加索引会怎样？"></a>update 没加索引会怎样？</h2><p> InnoDB 存储引擎自己实现了行锁，通过 next-key 锁（记录锁和间隙锁的组合）来锁住记录本身和记录之间的“间隙”，防止其他事务在这个记录之间插入新的记录，从而避免了幻读现象。</p>
<p>当我们执行 update 语句时，实际上是会对记录加独占锁（X 锁）的，如果其他事务对持有独占锁的记录进行修改时是会被阻塞的。另外，这个锁并不是执行完 update 语句就会释放的，而是会等事务结束时才会释放。</p>
<p>在 InnoDB 事务中，对记录加锁带基本单位是 next-key 锁，但是会因为一些条件会退化成间隙锁，或者记录锁。加锁的位置准确的说，<strong>锁是加在索引上的而非行上</strong>。</p>
<p>比如，在 update 语句的 where 条件使用了唯一索引，那么 next-key 锁会退化成记录锁，也就是只会给一行记录加锁。</p>
<p><strong>在 update 语句的 where 条件没有使用索引，就会全表扫描，于是就会对所有记录加上 next-key 锁（记录锁 + 间隙锁），相当于把整个表锁住了</strong>。（全表扫描并加上next-key锁，并非加上表锁）</p>
<p>当在数据量非常大的数据库表执行 update 语句时，如果没有使用索引，就会给全表的加上 next-key 锁， 那么锁就会持续很长一段时间，直到事务结束，而这期间除了 <code>select ... from</code>语句，其他语句都会被锁住不能执行，业务会因此停滞</p>
<p>那 update 语句的 where 带上索引就能避免全表记录加锁了吗？</p>
<p>并不是。</p>
<p><strong>关键还得看这条语句在执行过程种，优化器最终选择的是索引扫描，还是全表扫描，如果走了全表扫描，就会对全表的记录加锁了</strong>。</p>
<hr>
<p>如何避免这种事故的发生？</p>
<p>可以将 MySQL 里的 <code>sql_safe_updates</code> 参数设置为 1，开启安全更新模式。</p>
<p>当 sql_safe_updates 设置为 1 时。</p>
<p>update 语句必须满足如下条件之一才能执行成功：</p>
<ul>
<li>使用 where，并且 where 条件中必须有索引列；</li>
<li>使用 limit；</li>
<li>同时使用 where 和 limit，此时 where 条件中可以没有索引列；</li>
</ul>
<p>delete 语句必须满足以下条件能执行成功：</p>
<ul>
<li>同时使用 where 和 limit，此时 where 条件中可以没有索引列；</li>
</ul>
<p>如果 where 条件带上了索引列，但是优化器最终扫描选择的是全表，而不是索引的话，我们可以使用 <code>force index([index_name])</code> 可以告诉优化器使用哪个索引，以此避免有几率锁全表带来的隐患。</p>
<hr>
<h2 id="MySQL-记录锁-间隙锁可以防止删除操作而导致的幻读吗？"><a href="#MySQL-记录锁-间隙锁可以防止删除操作而导致的幻读吗？" class="headerlink" title="MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读吗？"></a>MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读吗？</h2><p>接下来，来验证「 MySQL 记录锁+间隙锁<strong>可以防止</strong>删除操作而导致的幻读问题」的结论。</p>
<p>实验环境：MySQL 8.0 版本，可重复读隔离级。</p>
<p>现在有一张用户表（iron_student），表里<strong>只有一个主键索引</strong>，表里有以下行数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from iron_student;</span><br><span class="line">+----+--------+------+-------+</span><br><span class="line">| id | name   | age  | score |</span><br><span class="line">+----+--------+------+-------+</span><br><span class="line">|  1 | name_1 |   18 |    10 |</span><br><span class="line">|  2 | name_2 |   19 |    20 |</span><br><span class="line">|  3 | name_3 |   20 |    30 |</span><br><span class="line">|  4 | name_4 |   22 |    40 |</span><br><span class="line">|  5 | name_5 |   16 |    50 |</span><br><span class="line">|  6 | name_6 |   16 |    60 |</span><br><span class="line">|  7 | name_7 |   23 |    60 |</span><br><span class="line">|  8 | name_8 |   31 |    80 |</span><br><span class="line">|  9 | name_9 |   12 |    90 |</span><br><span class="line">+----+--------+------+-------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>



<p>现在有一个 A 事务执行了一条查询语句，查询到年龄大于 20 岁的用户共有 6 条行记录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from iron_student where age &gt; 20 for update;</span><br><span class="line">+----+--------+------+-------+</span><br><span class="line">| id | name   | age  | score |</span><br><span class="line">+----+--------+------+-------+</span><br><span class="line">|  4 | name_4 |   22 |    40 |</span><br><span class="line">|  7 | name_7 |   23 |    60 |</span><br><span class="line">|  8 | name_8 |   31 |    80 |</span><br><span class="line">+----+--------+------+-------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>



<p>然后， B 事务执行了一条删除 id &#x3D; 4 的语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; delete from iron_student where id = 4 limit 1;</span><br><span class="line">## 阻塞</span><br></pre></td></tr></table></figure>



<p>此时，B 事务的删除语句就陷入了<strong>等待状态</strong>，说明是无法进行删除的。</p>
<p>因此，MySQL 记录锁+间隙锁<strong>可以防止</strong>删除操作而导致的幻读问题。</p>
<p>问题来了，A 事务在执行 select … for update 语句时，具体加了什么锁呢？</p>
<p>我们可以通过 <code>select * from performance_schema.data_locks\G;</code> 这条语句，查看事务执行 SQL 过程中加了什么锁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from performance_schema.data_locks\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               ENGINE: INNODB</span><br><span class="line">       ENGINE_LOCK_ID: 140036574412800:1063:140036469222048</span><br><span class="line">ENGINE_TRANSACTION_ID: 2869</span><br><span class="line">            THREAD_ID: 52</span><br><span class="line">             EVENT_ID: 37</span><br><span class="line">        OBJECT_SCHEMA: test</span><br><span class="line">          OBJECT_NAME: iron_student</span><br><span class="line">       PARTITION_NAME: NULL</span><br><span class="line">    SUBPARTITION_NAME: NULL</span><br><span class="line">           INDEX_NAME: NULL</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 140036469222048</span><br><span class="line">            LOCK_TYPE: TABLE   ### 表级锁</span><br><span class="line">            LOCK_MODE: IX      ### 这个是插入独占锁，因为 for update 语句加上的。如果是 lock in share mode 则是 IS</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">            LOCK_DATA: NULL</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">               ENGINE: INNODB</span><br><span class="line">       ENGINE_LOCK_ID: 140036574412800:2:4:1:140036469219136</span><br><span class="line">ENGINE_TRANSACTION_ID: 2869</span><br><span class="line">            THREAD_ID: 52</span><br><span class="line">             EVENT_ID: 37</span><br><span class="line">        OBJECT_SCHEMA: test</span><br><span class="line">          OBJECT_NAME: iron_student</span><br><span class="line">       PARTITION_NAME: NULL</span><br><span class="line">    SUBPARTITION_NAME: NULL</span><br><span class="line">           INDEX_NAME: PRIMARY</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 140036469219136</span><br><span class="line">            LOCK_TYPE: RECORD</span><br><span class="line">            LOCK_MODE: X</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">            LOCK_DATA: supremum pseudo-record</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">               ENGINE: INNODB</span><br><span class="line">       ENGINE_LOCK_ID: 140036574412800:2:4:2:140036469219136</span><br><span class="line">ENGINE_TRANSACTION_ID: 2869</span><br><span class="line">            THREAD_ID: 52</span><br><span class="line">             EVENT_ID: 37</span><br><span class="line">        OBJECT_SCHEMA: test</span><br><span class="line">          OBJECT_NAME: iron_student</span><br><span class="line">       PARTITION_NAME: NULL</span><br><span class="line">    SUBPARTITION_NAME: NULL</span><br><span class="line">           INDEX_NAME: PRIMARY</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 140036469219136</span><br><span class="line">            LOCK_TYPE: RECORD</span><br><span class="line">            LOCK_MODE: X</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">            LOCK_DATA: 1</span><br><span class="line">*************************** 4. row ***************************</span><br><span class="line">               ENGINE: INNODB</span><br><span class="line">       ENGINE_LOCK_ID: 140036574412800:2:4:3:140036469219136</span><br><span class="line">ENGINE_TRANSACTION_ID: 2869</span><br><span class="line">            THREAD_ID: 52</span><br><span class="line">             EVENT_ID: 37</span><br><span class="line">        OBJECT_SCHEMA: test</span><br><span class="line">          OBJECT_NAME: iron_student</span><br><span class="line">       PARTITION_NAME: NULL</span><br><span class="line">    SUBPARTITION_NAME: NULL</span><br><span class="line">           INDEX_NAME: PRIMARY</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 140036469219136</span><br><span class="line">            LOCK_TYPE: RECORD</span><br><span class="line">            LOCK_MODE: X</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">            LOCK_DATA: 2</span><br><span class="line">*************************** 5. row ***************************</span><br><span class="line">               ENGINE: INNODB</span><br><span class="line">       ENGINE_LOCK_ID: 140036574412800:2:4:4:140036469219136</span><br><span class="line">ENGINE_TRANSACTION_ID: 2869</span><br><span class="line">            THREAD_ID: 52</span><br><span class="line">             EVENT_ID: 37</span><br><span class="line">        OBJECT_SCHEMA: test</span><br><span class="line">          OBJECT_NAME: iron_student</span><br><span class="line">       PARTITION_NAME: NULL</span><br><span class="line">    SUBPARTITION_NAME: NULL</span><br><span class="line">           INDEX_NAME: PRIMARY</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 140036469219136</span><br><span class="line">            LOCK_TYPE: RECORD</span><br><span class="line">            LOCK_MODE: X</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">            LOCK_DATA: 3</span><br><span class="line">*************************** 6. row ***************************</span><br><span class="line">               ENGINE: INNODB</span><br><span class="line">       ENGINE_LOCK_ID: 140036574412800:2:4:5:140036469219136</span><br><span class="line">ENGINE_TRANSACTION_ID: 2869</span><br><span class="line">            THREAD_ID: 52</span><br><span class="line">             EVENT_ID: 37</span><br><span class="line">        OBJECT_SCHEMA: test</span><br><span class="line">          OBJECT_NAME: iron_student</span><br><span class="line">       PARTITION_NAME: NULL</span><br><span class="line">    SUBPARTITION_NAME: NULL</span><br><span class="line">           INDEX_NAME: PRIMARY</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 140036469219136</span><br><span class="line">            LOCK_TYPE: RECORD</span><br><span class="line">            LOCK_MODE: X</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">            LOCK_DATA: 4</span><br><span class="line">*************************** 7. row ***************************</span><br><span class="line">               ENGINE: INNODB</span><br><span class="line">       ENGINE_LOCK_ID: 140036574412800:2:4:6:140036469219136</span><br><span class="line">ENGINE_TRANSACTION_ID: 2869</span><br><span class="line">            THREAD_ID: 52</span><br><span class="line">             EVENT_ID: 37</span><br><span class="line">        OBJECT_SCHEMA: test</span><br><span class="line">          OBJECT_NAME: iron_student</span><br><span class="line">       PARTITION_NAME: NULL</span><br><span class="line">    SUBPARTITION_NAME: NULL</span><br><span class="line">           INDEX_NAME: PRIMARY</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 140036469219136</span><br><span class="line">            LOCK_TYPE: RECORD</span><br><span class="line">            LOCK_MODE: X</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">            LOCK_DATA: 5</span><br><span class="line">*************************** 8. row ***************************</span><br><span class="line">               ENGINE: INNODB</span><br><span class="line">       ENGINE_LOCK_ID: 140036574412800:2:4:7:140036469219136</span><br><span class="line">ENGINE_TRANSACTION_ID: 2869</span><br><span class="line">            THREAD_ID: 52</span><br><span class="line">             EVENT_ID: 37</span><br><span class="line">        OBJECT_SCHEMA: test</span><br><span class="line">          OBJECT_NAME: iron_student</span><br><span class="line">       PARTITION_NAME: NULL</span><br><span class="line">    SUBPARTITION_NAME: NULL</span><br><span class="line">           INDEX_NAME: PRIMARY</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 140036469219136</span><br><span class="line">            LOCK_TYPE: RECORD</span><br><span class="line">            LOCK_MODE: X</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">            LOCK_DATA: 6</span><br><span class="line">*************************** 9. row ***************************</span><br><span class="line">               ENGINE: INNODB</span><br><span class="line">       ENGINE_LOCK_ID: 140036574412800:2:4:8:140036469219136</span><br><span class="line">ENGINE_TRANSACTION_ID: 2869</span><br><span class="line">            THREAD_ID: 52</span><br><span class="line">             EVENT_ID: 37</span><br><span class="line">        OBJECT_SCHEMA: test</span><br><span class="line">          OBJECT_NAME: iron_student</span><br><span class="line">       PARTITION_NAME: NULL</span><br><span class="line">    SUBPARTITION_NAME: NULL</span><br><span class="line">           INDEX_NAME: PRIMARY</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 140036469219136</span><br><span class="line">            LOCK_TYPE: RECORD</span><br><span class="line">            LOCK_MODE: X</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">            LOCK_DATA: 7</span><br><span class="line">*************************** 10. row ***************************</span><br><span class="line">               ENGINE: INNODB</span><br><span class="line">       ENGINE_LOCK_ID: 140036574412800:2:4:9:140036469219136</span><br><span class="line">ENGINE_TRANSACTION_ID: 2869</span><br><span class="line">            THREAD_ID: 52</span><br><span class="line">             EVENT_ID: 37</span><br><span class="line">        OBJECT_SCHEMA: test</span><br><span class="line">          OBJECT_NAME: iron_student</span><br><span class="line">       PARTITION_NAME: NULL</span><br><span class="line">    SUBPARTITION_NAME: NULL</span><br><span class="line">           INDEX_NAME: PRIMARY</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 140036469219136</span><br><span class="line">            LOCK_TYPE: RECORD</span><br><span class="line">            LOCK_MODE: X</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">            LOCK_DATA: 8</span><br><span class="line">*************************** 11. row ***************************</span><br><span class="line">               ENGINE: INNODB</span><br><span class="line">       ENGINE_LOCK_ID: 140036574412800:2:4:10:140036469219136</span><br><span class="line">ENGINE_TRANSACTION_ID: 2869</span><br><span class="line">            THREAD_ID: 52</span><br><span class="line">             EVENT_ID: 37</span><br><span class="line">        OBJECT_SCHEMA: test</span><br><span class="line">          OBJECT_NAME: iron_student</span><br><span class="line">       PARTITION_NAME: NULL</span><br><span class="line">    SUBPARTITION_NAME: NULL</span><br><span class="line">           INDEX_NAME: PRIMARY</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 140036469219136</span><br><span class="line">            LOCK_TYPE: RECORD ### 行级锁</span><br><span class="line">            LOCK_MODE: X    ## 结合上面 LOCK_TYPE,这里是 next-key-lock</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">            LOCK_DATA: 9    ## （9的上一个,9] ,结合LOCK_MODE为x，说明没有退化为间隙锁或者行锁。</span><br><span class="line">11 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>



<p>从上面输出的信息可以看到，共加了两种不同粒度的锁，分别是：</p>
<ul>
<li>表锁（<code>LOCK_TYPE: TABLE</code>）：X 类型的意向锁；</li>
<li>行锁（<code>LOCK_TYPE: RECORD</code>）：X 类型的 next-key 锁；</li>
</ul>
<p>这里我们重点关注「行锁」，图中 <code>LOCK_TYPE</code> 中的 <code>RECORD</code> 表示行级锁，而不是记录锁的意思：</p>
<ul>
<li>如果 LOCK_MODE 为 <code>X</code>，说明是 next-key 锁；</li>
<li>如果 LOCK_MODE 为 <code>X, REC_NOT_GAP</code>，说明是记录锁；</li>
<li>如果 LOCK_MODE 为 <code>X, GAP</code>，说明是间隙锁；</li>
</ul>
<p>然后通过 <code>LOCK_DATA</code> 信息，可以确认 next-key 锁的范围，具体怎么确定呢？</p>
<ul>
<li>根据我的经验，如果 LOCK_MODE 是 next-key 锁或者间隙锁，那么 <strong>LOCK_DATA 就表示锁的范围最右值</strong>，而锁范围的最左值为 LOCK_DATA 的上一条记录的值。</li>
</ul>
<p>因此，此时事务 A 在主键索引（<code>INDEX_NAME : PRIMARY</code>）上加了 10 个 next-key 锁，如下：</p>
<ul>
<li>X 型的 next-key 锁，范围：(-∞, 1]</li>
<li>X 型的 next-key 锁，范围：(1, 2]</li>
<li>X 型的 next-key 锁，范围：(2, 3]</li>
<li>X 型的 next-key 锁，范围：(3, 4]</li>
<li>X 型的 next-key 锁，范围：(4, 5]</li>
<li>X 型的 next-key 锁，范围：(5, 6]</li>
<li>X 型的 next-key 锁，范围：(6, 7]</li>
<li>X 型的 next-key 锁，范围：(7, 8]</li>
<li>X 型的 next-key 锁，范围：(8, 9]</li>
<li>X 型的 next-key 锁，范围：(9, +∞]</li>
</ul>
<p><strong>这相当于把整个表给锁住了，其他事务在对该表进行增、删、改操作的时候都会被阻塞</strong>。</p>
<p>只有在事务 A 提交了事务，事务 A 执行过程中产生的锁才会被释放。</p>
<p>为什么只是查询年龄 20 岁以上行记录，而把整个表给锁住了呢？</p>
<p>这是因为事务 A 的这条查询语句是<strong>全表扫描，锁是在遍历索引的时候加上的，并不是针对输出的结果加锁</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from iron_student where age &gt; 20 for update\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: iron_student</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ALL   ####### 这里表示全表扫描（因为age没有索引）</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 9</span><br><span class="line">     filtered: 33.33</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>





<p>因此，<strong>在线上在执行 update、delete、select … for update 等具有加锁性质的语句，一定要检查语句是否走了索引，如果是全表扫描的话，会对每一个索引加 next-key 锁，相当于把整个表锁住了</strong>，这是挺严重的问题。</p>
<p>如果对 age 建立索引，事务 A 这条查询会加什么锁呢？</p>
<p><strong>对 age 字段建立索引</strong>，然后再执行这条查询语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE INDEX stu_age ON iron_student (age);</span><br><span class="line">Query OK, 0 rows affected (0.04 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from iron_student where age &gt; 20 for update;</span><br><span class="line">+----+--------+------+-------+</span><br><span class="line">| id | name   | age  | score |</span><br><span class="line">+----+--------+------+-------+</span><br><span class="line">|  4 | name_4 |   22 |    40 |</span><br><span class="line">|  7 | name_7 |   23 |    60 |</span><br><span class="line">|  8 | name_8 |   31 |    80 |</span><br><span class="line">+----+--------+------+-------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>



<p>接下来，继续通过 <code>select * from performance_schema.data_locks\G;</code> 这条语句，查看事务执行 SQL 过程中加了什么锁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from performance_schema.data_locks\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               ENGINE: INNODB</span><br><span class="line">       ENGINE_LOCK_ID: 140036574412800:1063:140036469222048</span><br><span class="line">ENGINE_TRANSACTION_ID: 2881</span><br><span class="line">            THREAD_ID: 52</span><br><span class="line">             EVENT_ID: 58</span><br><span class="line">        OBJECT_SCHEMA: test</span><br><span class="line">          OBJECT_NAME: iron_student</span><br><span class="line">       PARTITION_NAME: NULL</span><br><span class="line">    SUBPARTITION_NAME: NULL</span><br><span class="line">           INDEX_NAME: NULL</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 140036469222048</span><br><span class="line">            LOCK_TYPE: TABLE  ### 同理，肯定会加上表级锁</span><br><span class="line">            LOCK_MODE: IX     ### 意向独占锁</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">            LOCK_DATA: NULL</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">               ENGINE: INNODB</span><br><span class="line">       ENGINE_LOCK_ID: 140036574412800:2:5:1:140036469219136</span><br><span class="line">ENGINE_TRANSACTION_ID: 2881</span><br><span class="line">            THREAD_ID: 52</span><br><span class="line">             EVENT_ID: 58</span><br><span class="line">        OBJECT_SCHEMA: test</span><br><span class="line">          OBJECT_NAME: iron_student</span><br><span class="line">       PARTITION_NAME: NULL</span><br><span class="line">    SUBPARTITION_NAME: NULL</span><br><span class="line">           INDEX_NAME: stu_age</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 140036469219136</span><br><span class="line">            LOCK_TYPE: RECORD</span><br><span class="line">            LOCK_MODE: X</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">            LOCK_DATA: supremum pseudo-record</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">               ENGINE: INNODB</span><br><span class="line">       ENGINE_LOCK_ID: 140036574412800:2:5:8:140036469219136</span><br><span class="line">ENGINE_TRANSACTION_ID: 2881</span><br><span class="line">            THREAD_ID: 52</span><br><span class="line">             EVENT_ID: 58</span><br><span class="line">        OBJECT_SCHEMA: test</span><br><span class="line">          OBJECT_NAME: iron_student</span><br><span class="line">       PARTITION_NAME: NULL</span><br><span class="line">    SUBPARTITION_NAME: NULL</span><br><span class="line">           INDEX_NAME: stu_age</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 140036469219136</span><br><span class="line">            LOCK_TYPE: RECORD</span><br><span class="line">            LOCK_MODE: X</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">            LOCK_DATA: 22, 4  ### 这里并非22开始 而是 (20,22]</span><br><span class="line">*************************** 4. row ***************************</span><br><span class="line">               ENGINE: INNODB</span><br><span class="line">       ENGINE_LOCK_ID: 140036574412800:2:5:9:140036469219136</span><br><span class="line">ENGINE_TRANSACTION_ID: 2881</span><br><span class="line">            THREAD_ID: 52</span><br><span class="line">             EVENT_ID: 58</span><br><span class="line">        OBJECT_SCHEMA: test</span><br><span class="line">          OBJECT_NAME: iron_student</span><br><span class="line">       PARTITION_NAME: NULL</span><br><span class="line">    SUBPARTITION_NAME: NULL</span><br><span class="line">           INDEX_NAME: stu_age</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 140036469219136</span><br><span class="line">            LOCK_TYPE: RECORD</span><br><span class="line">            LOCK_MODE: X</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">            LOCK_DATA: 23, 7</span><br><span class="line">*************************** 5. row ***************************</span><br><span class="line">               ENGINE: INNODB</span><br><span class="line">       ENGINE_LOCK_ID: 140036574412800:2:5:10:140036469219136</span><br><span class="line">ENGINE_TRANSACTION_ID: 2881</span><br><span class="line">            THREAD_ID: 52</span><br><span class="line">             EVENT_ID: 58</span><br><span class="line">        OBJECT_SCHEMA: test</span><br><span class="line">          OBJECT_NAME: iron_student</span><br><span class="line">       PARTITION_NAME: NULL</span><br><span class="line">    SUBPARTITION_NAME: NULL</span><br><span class="line">           INDEX_NAME: stu_age</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 140036469219136</span><br><span class="line">            LOCK_TYPE: RECORD   ## next-key lock</span><br><span class="line">            LOCK_MODE: X</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">            LOCK_DATA: 31, 8</span><br><span class="line">*************************** 6. row ***************************</span><br><span class="line">               ENGINE: INNODB</span><br><span class="line">       ENGINE_LOCK_ID: 140036574412800:2:4:5:140036469219480</span><br><span class="line">ENGINE_TRANSACTION_ID: 2881</span><br><span class="line">            THREAD_ID: 52</span><br><span class="line">             EVENT_ID: 58</span><br><span class="line">        OBJECT_SCHEMA: test</span><br><span class="line">          OBJECT_NAME: iron_student</span><br><span class="line">       PARTITION_NAME: NULL</span><br><span class="line">    SUBPARTITION_NAME: NULL</span><br><span class="line">           INDEX_NAME: PRIMARY</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 140036469219480</span><br><span class="line">            LOCK_TYPE: RECORD</span><br><span class="line">            LOCK_MODE: X,REC_NOT_GAP</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">            LOCK_DATA: 4</span><br><span class="line">*************************** 7. row ***************************</span><br><span class="line">               ENGINE: INNODB</span><br><span class="line">       ENGINE_LOCK_ID: 140036574412800:2:4:8:140036469219480</span><br><span class="line">ENGINE_TRANSACTION_ID: 2881</span><br><span class="line">            THREAD_ID: 52</span><br><span class="line">             EVENT_ID: 58</span><br><span class="line">        OBJECT_SCHEMA: test</span><br><span class="line">          OBJECT_NAME: iron_student</span><br><span class="line">       PARTITION_NAME: NULL</span><br><span class="line">    SUBPARTITION_NAME: NULL</span><br><span class="line">           INDEX_NAME: PRIMARY</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 140036469219480</span><br><span class="line">            LOCK_TYPE: RECORD</span><br><span class="line">            LOCK_MODE: X,REC_NOT_GAP  ## 行锁（记录锁）</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">            LOCK_DATA: 7</span><br><span class="line">*************************** 8. row ***************************</span><br><span class="line">               ENGINE: INNODB</span><br><span class="line">       ENGINE_LOCK_ID: 140036574412800:2:4:9:140036469219480</span><br><span class="line">ENGINE_TRANSACTION_ID: 2881</span><br><span class="line">            THREAD_ID: 52</span><br><span class="line">             EVENT_ID: 58</span><br><span class="line">        OBJECT_SCHEMA: test</span><br><span class="line">          OBJECT_NAME: iron_student</span><br><span class="line">       PARTITION_NAME: NULL</span><br><span class="line">    SUBPARTITION_NAME: NULL</span><br><span class="line">           INDEX_NAME: PRIMARY</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 140036469219480</span><br><span class="line">            LOCK_TYPE: RECORD</span><br><span class="line">            LOCK_MODE: X,REC_NOT_GAP  ### 行锁</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">            LOCK_DATA: 8</span><br><span class="line">8 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>



<p><strong>因为表中有两个索引，分别是主键索引和 age 索引，所以会分别对这两个索引加锁。</strong></p>
<p>主键索引会加如下的锁：</p>
<ul>
<li>X 型的记录锁，锁住 id &#x3D; 4 的记录；</li>
<li>X 型的记录锁，锁住 id &#x3D; 7 的记录；</li>
<li>X 型的记录锁，锁住 id &#x3D; 8 的记录；</li>
</ul>
<p>分析 age 索引加锁的范围时，要先对 age 字段进行排序。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from iron_student order by age;</span><br><span class="line">+----+--------+------+-------+</span><br><span class="line">| id | name   | age  | score |</span><br><span class="line">+----+--------+------+-------+</span><br><span class="line">|  9 | name_9 |   12 |    90 |</span><br><span class="line">|  5 | name_5 |   16 |    50 |</span><br><span class="line">|  6 | name_6 |   16 |    60 |</span><br><span class="line">|  1 | name_1 |   18 |    10 |</span><br><span class="line">|  2 | name_2 |   19 |    20 |</span><br><span class="line">|  3 | name_3 |   20 |    30 | ### 这里刚好是开区间，没有被锁主 (20,22]</span><br><span class="line">|  4 | name_4 |   22 |    40 | ### 大于age 20 的被锁住, 然后对应的 id =4 也会被锁住</span><br><span class="line">|  7 | name_7 |   23 |    60 | ### 大于age 20 的被锁住, 然后对应的 id =7 也会被锁住</span><br><span class="line">|  8 | name_8 |   31 |    80 | ### 大于age 20 的被锁住, 然后对应的 id =8 也会被锁住，最后一个还有一个supernum的+无穷</span><br><span class="line">+----+--------+------+-------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>



<p>age 索引加的锁：</p>
<ul>
<li>X 型的 next-key lock，锁住 age 范围 (20, 22] 的记录；</li>
<li>X 型的 next-key lock，锁住 age 范围 (22, 23] 的记录；</li>
<li>X 型的 next-key lock，锁住 age 范围 (23, 31] 的记录；</li>
<li>X 型的 next-key lock，锁住 age 范围 (31, +∞] 的记录；</li>
</ul>
<p>化简一下，<strong>age 索引 next-key 锁的范围是 (20, +∞]。</strong></p>
<p>可以看到，对 age 字段建立了索引后，查询语句是索引查询，并不会全表扫描，因此<strong>不会把整张表给锁住</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from iron_student where age &gt; 20 for update\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: iron_student</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: range</span><br><span class="line">possible_keys: stu_age   </span><br><span class="line">          key: stu_age   ### 使用了 stu_age 索引</span><br><span class="line">      key_len: 5</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 3</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using index condition</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; delete from iron_student where id = 4 limit 1; ## 因为id=4 主键已经加上了行锁——阻塞</span><br><span class="line">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction </span><br><span class="line">mysql&gt; update  iron_student set age = 1000 where id = 8 limit 1; ## </span><br><span class="line">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</span><br><span class="line">mysql&gt; insert into iron_student (name,age,score) values (&#x27;donscoco&#x27;,2,2); ## 不阻塞。</span><br><span class="line">mysql&gt; insert into iron_student (name,age,score) values (&#x27;donscoco&#x27;,24,90); ## age 24 在(20,supernum]之间，阻塞</span><br><span class="line">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</span><br><span class="line">mysql&gt; delete from iron_student where score=80; ## score 的那条记录的age在锁范围内，阻塞</span><br><span class="line">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</span><br></pre></td></tr></table></figure>





<p>总结一下，在对 age 字段建立索引后，事务 A 在执行下面这条查询语句后，主键索引和 age 索引会加如下的锁。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">age索引中 加上 (20,supernum]</span><br><span class="line">聚簇索引中 加上 4,7,8</span><br></pre></td></tr></table></figure>





<h2 id="MySQL-死锁了，怎么办？"><a href="#MySQL-死锁了，怎么办？" class="headerlink" title="MySQL 死锁了，怎么办？"></a>MySQL 死锁了，怎么办？</h2><hr>
<h3 id="死锁例子"><a href="#死锁例子" class="headerlink" title="死锁例子"></a>死锁例子</h3><p>现在有这样一个表，order_no是唯一索引。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from t_order;</span><br><span class="line">+----+----------+-------------+</span><br><span class="line">| id | order_no | create_date |</span><br><span class="line">+----+----------+-------------+</span><br><span class="line">|  1 |     1001 | NULL        |</span><br><span class="line">|  2 |     1002 | NULL        |</span><br><span class="line">|  3 |     1003 | NULL        |</span><br><span class="line">|  4 |     1004 | NULL        |</span><br><span class="line">|  5 |     1005 | NULL        |</span><br><span class="line">+----+----------+-------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>



<p>事务A和事务B先后启动事务后，在各自的事务里面检查是否有 order_no&#x3D;1007 ，发现没有都准备插入。</p>
<img src="/2022/10/21/mysql/%E6%AD%BB%E9%94%81%E5%AE%9E%E9%AA%8C0-1.png" class="">

<p>之后事务A开始插入，发现被事务B的间隙锁阻塞</p>
<img src="/2022/10/21/mysql/%E6%AD%BB%E9%94%81%E5%AE%9E%E9%AA%8C0-2.png" class="">

<p>之后事务B开始插入，发现被事务A的间隙锁阻塞。（因为这里开启的死锁检测，所以事务B被强制退出了）</p>
<img src="/2022/10/21/mysql/%E6%AD%BB%E9%94%81%E5%AE%9E%E9%AA%8C0-3.png" class="">

<p>事务A和事务B之间死锁。（因为间隙锁不冲突，相互持有间隙锁，相互等待对方的间隙锁释放）</p>
<h3 id="Insert-语句是怎么加行级锁的？"><a href="#Insert-语句是怎么加行级锁的？" class="headerlink" title="Insert 语句是怎么加行级锁的？"></a>Insert 语句是怎么加行级锁的？</h3><ul>
<li>隐式锁</li>
</ul>
<p>Insert 语句在正常执行时是不会生成锁结构的，它是靠聚簇索引记录自带的 trx_id 隐藏列来作为<strong>隐式锁</strong>来保护记录的。</p>
<p>什么是隐式锁？</p>
<p>当事务需要加锁的时，如果这个锁不可能发生冲突，InnoDB会跳过加锁环节，这种机制称为隐式锁。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">说白了就是不加锁。但是后续的处理根据是否冲突可能会升级为一个锁</span><br><span class="line">1.间隙锁冲突——隐式锁升级为一个独占、插入意向锁（X,INSERT_INTENTION）<span class="comment">## 目的是为了阻塞其他事务的独占锁并让自己有优先权，</span></span><br><span class="line">2.唯一二级索引列冲突——<span class="string">&#x27;隐式锁升级为共享锁（S）&#x27;</span>。<span class="comment">## 目的是为了阻塞其他事务之后的申请独占锁</span></span><br><span class="line">3.相同sql语句冲突——隐式锁升级为 独占锁（X,REC_NOT_GAP）, 后面的insert的<span class="string">&#x27;隐式锁升级为 共享锁（S）&#x27;</span>。 <span class="comment">## 目的是为了阻塞其他事务之后的申请独占锁</span></span><br></pre></td></tr></table></figure>

<p>为什么说 隐式锁是 用 trx_id 隐藏列 来实现的？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">因为trx_id 是一定递增的。不会出现相同的trx_id。隐式锁不是一个实体，而是一个处理逻辑，根据后续不同的情况进行判断去进行一个加锁或者不加锁的操作。</span><br></pre></td></tr></table></figure>



<p>间隙锁与间隙锁之间是兼容的:</p>
<p><strong>间隙锁的意义只在于阻止区间被插入</strong>，因此是可以共存的。<strong>一个事务获取的间隙锁不会阻止另一个事务获取同一个间隙范围的间隙锁</strong>，共享和排他的间隙锁是没有区别的，他们相互不冲突，且功能相同，即两个事务可以同时持有包含共同间隙的间隙锁。这里的共同间隙包括两种场景：</p>
<ul>
<li>其一是两个间隙锁的间隙区间完全一样；</li>
<li>其二是一个间隙锁包含的间隙区间是另一个间隙锁包含间隙区间的子集。</li>
</ul>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from t_order;</span><br><span class="line">+----+----------+-------------+</span><br><span class="line">| id | order_no | create_date |</span><br><span class="line">+----+----------+-------------+</span><br><span class="line">|  1 |     1001 | NULL        |</span><br><span class="line">|  2 |     1002 | NULL        |</span><br><span class="line">|  3 |     1003 | NULL        |</span><br><span class="line">|  4 |     1004 | NULL        |</span><br><span class="line">|  5 |     1005 | NULL        |</span><br><span class="line">+----+----------+-------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>



<p>现在，事务 A 执行了下面这条语句。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 事务 A</span></span><br><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t_order <span class="built_in">where</span> order_no = 1006 <span class="keyword">for</span> update;</span><br><span class="line">Empty <span class="built_in">set</span> (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>接着，我们执行 <code>select * from performance_schema.data_locks\G;</code> 语句 ，确定事务 A 加了什么类型的锁，这里只关注在记录上加锁的类型。</p>
<img src="/2022/10/21/mysql/%E6%AD%BB%E9%94%81%E5%AE%9E%E9%AA%8C1.png" class="">

<p>本次的例子加的是 next-key 锁（记录锁+间隙锁），锁范围是<code>（1005, +∞]</code>。</p>
<p>然后，有个事务 B 在这个间隙锁中，插入了一个记录，那么此时该事务 B 就会被阻塞：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 事务 B 插入一条记录</span></span><br><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t_order(order_no, create_date) values(1010,now());</span><br><span class="line"><span class="comment">### 阻塞状态。。。。</span></span><br></pre></td></tr></table></figure>

<p>接着，我们执行 <code>select * from performance_schema.data_locks\G;</code> 语句 ，确定事务 B 加了什么类型的锁，这里只关注在记录上加锁的类型。</p>
<img src="/2022/10/21/mysql/%E6%AD%BB%E9%94%81%E5%AE%9E%E9%AA%8C2.png" class="">

<p>可以看到，事务 B 的状态为等待状态（LOCK_STATUS: WAITING），因为向事务 A 生成的 next-key 锁（记录锁+间隙锁）范围<code>（1005, +∞]</code> 中插入了一条记录，所以事务 B 的插入操作生成了一个插入意向锁（<code>LOCK_MODE: X,INSERT_INTENTION</code>），锁的状态是等待状态，意味着事务 B 并没有成功获取到插入意向锁，因此事务 B 发生阻塞。</p>
<hr>
<h4 id="记录之间加有间隙锁"><a href="#记录之间加有间隙锁" class="headerlink" title="记录之间加有间隙锁"></a>记录之间加有间隙锁</h4><p>每插入一条新记录，都需要看一下待插入记录的下一条记录上是否已经被加了间隙锁，如果已加间隙锁，此时会生成一个插入意向锁，然后锁的状态设置为等待状态（<em>PS：MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁</em>），现象就是 Insert 语句会被阻塞。</p>
<p>举个例子，现在 t_order 表中，只有这些数据，<strong>order_no 是二级索引</strong>。</p>
<h4 id="遇到唯一键冲突"><a href="#遇到唯一键冲突" class="headerlink" title="遇到唯一键冲突"></a>遇到唯一键冲突</h4><p>如果在插入新记录时，插入了一个与「已有的记录的主键或者唯一二级索引列值相同」的记录」（不过可以有多条记录的唯一二级索引列的值同时为NULL，这里不考虑这种情况），此时插入就会失败，然后对于这条记录加上了 <strong>S 型的锁</strong>。</p>
<p><strong>唯一二级索引冲突</strong></p>
<p>下面举个「唯一二级索引冲突」的例子，MySQL 8.0 版本，事务隔离级别为可重复读（默认隔离级别）。</p>
<p>t_order 表中的 order_no 字段为唯一二级索引，并且已经存在 order_no 值为 1001 的记录，此时事务 A，插入了 order_no 为 1001 的记录，就出现了报错。</p>
<p>但是除了报错之外，还做一个很重要的事情，就是对 order_no 值为 1001 这条记录加上了 <strong>S 型的 next-key 锁</strong>。</p>
<p>我们可以执行 <code>select * from performance_schema.data_locks\G;</code> 语句 ，确定事务加了什么类型的锁，这里只关注在记录上加锁的类型。</p>
<img src="/2022/10/21/mysql/%E6%AD%BB%E9%94%81%E5%AE%9E%E9%AA%8C3.png" class="">

<p>可以看到，index_order 二级索引中的 1001（LOCK_DATA） 记录的锁类型为 S 型的 next-key 锁。注意，这里 LOCK_TYPE 中的 RECORD 表示行级锁，而不是记录锁的意思。如果是记录锁的话，LOCK_MODE 会显示 <code>S, REC_NOT_GAP</code>。</p>
<p>此时，事务 B 执行了 select * from t_order where order_no &#x3D; 1001 for update; 就会阻塞，因为这条语句想加 X 型的锁，是与 S 型的锁是冲突的，所以就会被阻塞。</p>
<p>我们也可以从 performance_schema.data_locks 这个表中看到，事务 B 的状态（LOCK_STATUS）是等待状态，加锁的类型 X 型的记录锁（LOCK_MODE: X,REC_NOT_GAP ）。</p>
<img src="/2022/10/21/mysql/%E6%AD%BB%E9%94%81%E5%AE%9E%E9%AA%8C4.png" class="">

<p>上面的案例是针对唯一二级索引重复而插入失败的场景。</p>
<p><strong>相同的 insert 语句的场景</strong></p>
<p>接下来，分析两个事务执行过程中，执行了相同的 insert 语句的场景。</p>
<p>现在 t_order 表中，只有这些数据，<strong>order_no 为唯一二级索引</strong>。</p>
<p>在隔离级别可重复读的情况下，开启两个事务，前后执行相同的 Insert 语句，此时<strong>事务 B 的 Insert 语句会发生阻塞</strong>。</p>
<p>两个事务的加锁过程：</p>
<ul>
<li>事务 A 先插入 order_no 为 1007 的记录，可以插入成功，此时对应的唯一二级索引记录被「隐式锁」保护，此时还没有实际的锁结构（执行完这里的时候，你可以看查 performance_schema.data_locks 信息，可以看到这条记录是没有加任何锁的）；</li>
<li>接着，事务 B 也插入 order_no 为 1007 的记录，由于事务 A 已经插入 order_no 值为 1007 的记录，所以事务 B 在插入二级索引记录时会遇到重复的唯一二级索引列值，此时事务 B 想获取一个 S 型 next-key 锁，但是事务 A 并未提交，<strong>事务 A 插入的 order_no 值为 1007 的记录上的「隐式锁」会变「显示锁」且锁类型为 X 型的记录锁，所以事务 B 向获取 S 型 next-key 锁时会遇到锁冲突，事务 B 进入阻塞状态</strong>。</li>
</ul>
<p>我们可以执行 <code>select * from performance_schema.data_locks\G;</code> 语句 ，确定事务加了什么类型的锁，这里只关注在记录上加锁的类型。</p>
<p>先看事务 A 对 order_no 为 1007 的记录加了什么锁？</p>
<p>从下图可以看到，<strong>事务 A 对 order_no 为 1007 记录加上了类型为 X 型的记录锁</strong>（<em>注意，这个是在执行事务 B 之后才产生的锁，没执行事务 B 之前，该记录还是隐式锁</em>）。</p>
<p>然后看事务 B 想对 order_no 为 1007 的记录加什么锁？</p>
<p>从下图可以看到，<strong>事务 B 想对 order_no 为 1007 的记录加 S 型的 next-key 锁，但是由于事务 A 在该记录上持有了 X 型的记录锁，这两个锁是冲突的，所以导致事务 B 处于等待状态</strong>。</p>
<img src="/2022/10/21/mysql/%E6%AD%BB%E9%94%81%E5%AE%9E%E9%AA%8C5.png" class="">

<p>从这个实验可以得知，并发多个事务的时候，第一个事务插入的记录，并不会加锁，而是会用隐式锁保护唯一二级索引的记录。</p>
<p>但是当第一个事务还未提交的时候，有其他事务插入了与第一个事务相同的记录，第二个事务就会<strong>被阻塞</strong>，<strong>因为此时第一事务插入的记录中的隐式锁会变为显示锁且类型是 X 型的记录锁，而第二个事务是想对该记录加上 S 型的 next-key 锁，X 型与 S 型的锁是冲突的</strong>，所以导致第二个事务会等待，直到第一个事务提交后，释放了锁。</p>
<p>如果 order_no 不是唯一二级索引，那么两个事务，前后执行相同的 Insert 语句，是不会发生阻塞的，就如前面的这个例子。</p>
<hr>
<h3 id="加锁分析"><a href="#加锁分析" class="headerlink" title="加锁分析 *"></a>加锁分析 *</h3><p><a href="https://xiaolincoding.com/mysql/lock/show_lock.html#time-2-%E9%98%B6%E6%AE%B5%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90">https://xiaolincoding.com/mysql/lock/show_lock.html#time-2-%E9%98%B6%E6%AE%B5%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90</a></p>
<h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h2><p>MySQL 的数据都是存在磁盘中的，那么我们要更新一条记录的时候，得先要从磁盘读取该记录，然后在内存中修改这条记录。那修改完这条记录是选择直接写回到磁盘，还是选择缓存起来呢？</p>
<p>当然是缓存起来好，这样下次有查询语句命中了这条记录，直接读取缓存中的记录，就不需要从磁盘获取数据了。</p>
<p>为此，Innodb 存储引擎设计了一个<strong>缓冲池（Buffer Pool）</strong>，来提高数据库的读写性能。</p>
<img src="/2022/10/21/mysql/mysql-buffer-pool.drawio.png" class="">

<p>有了 Buffer Poo 后：</p>
<ul>
<li>当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。</li>
<li>当修改数据时，如果数据存在于 Buffer Pool 中，那直接修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页（该页的内存数据和磁盘上的数据已经不一致），为了减少磁盘I&#x2F;O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。(看情况，如果设置参数时”双一”，那每次提交事务都会fsync到磁盘)</li>
</ul>
<p>Buffer Pool缓存了什么？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">InnoDB 会把存储的数据划分为若干个「页」，以页作为磁盘和内存交互的基本单位，一个页的默认大小为 16KB。因此，Buffer Pool 同样需要按「页」来划分。</span><br><span class="line">在 MySQL 启动的时候，InnoDB 会为 Buffer Pool 申请一片连续的内存空间，然后按照默认的16KB的大小划分出一个个的页， Buffer Pool 中的页就叫做缓存页。此时这些缓存页都是空闲的，之后随着程序的运行，才会有磁盘上的页被缓存到 Buffer Pool 中。</span><br><span class="line">所以，MySQL 刚启动的时候，你会观察到使用的虚拟内存空间很大，而使用到的物理内存空间却很小，这是因为只有这些虚拟内存被访问后，操作系统才会触发缺页中断，申请物理内存，接着将虚拟地址和物理地址建立映射关系。</span><br></pre></td></tr></table></figure>

<p>Buffer Pool 除了缓存「索引页」和「数据页」，还包括了 Undo 页，插入缓存、自适应哈希索引、锁信息等等。</p>
<h2 id="Buffer-Pool-管理"><a href="#Buffer-Pool-管理" class="headerlink" title="Buffer Pool 管理"></a>Buffer Pool 管理</h2><h3 id="管理空闲页"><a href="#管理空闲页" class="headerlink" title="管理空闲页"></a>管理空闲页</h3><p>Buffer Pool 是一片连续的内存空间，当 MySQL 运行一段时间后，这片连续的内存空间中的缓存页既有空闲的，也有被使用的。</p>
<p>为了能够快速找到空闲的缓存页，可以使用链表结构，将空闲缓存页的「控制块」作为链表的节点，这个链表称为 <strong>Free 链表</strong>（空闲链表）。</p>
<img src="/2022/10/21/mysql/mysql-%E7%BC%93%E5%AD%98%E9%A1%B5%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8.drawio.png" class="">

<p>Free 链表上除了有控制块，还有一个头节点，该头节点包含链表的头节点地址，尾节点地址，以及当前链表中节点的数量等信息。</p>
<p>Free 链表节点是一个一个的控制块，而每个控制块包含着对应缓存页的地址，所以相当于 Free 链表节点都对应一个空闲的缓存页。</p>
<p>有了 Free 链表后，每当需要从磁盘中加载一个页到 Buffer Pool 中时，就从 Free链表中取一个空闲的缓存页，并且把该缓存页对应的控制块的信息填上，然后把该缓存页对应的控制块从 Free 链表中移除。</p>
<h3 id="管理脏页"><a href="#管理脏页" class="headerlink" title="管理脏页"></a>管理脏页</h3><p>设计 Buffer Pool 除了能提高读性能，还能提高写性能，也就是更新数据的时候，不需要每次都要写入磁盘，而是将 Buffer Pool 对应的缓存页标记为<strong>脏页</strong>，然后再由后台线程将脏页写入到磁盘。</p>
<p>那为了能快速知道哪些缓存页是脏的，于是就设计出 <strong>Flush 链表</strong>，它跟 Free 链表类似的，链表的节点也是控制块，区别在于 Flush 链表的元素都是脏页。</p>
<img src="/2022/10/21/mysql/mysql-%E7%BC%93%E5%AD%98%E9%A1%B5%E8%84%8F%E9%A1%B5%E9%93%BE%E8%A1%A8.drawio.png" class="">

<p>有了 Flush 链表后，后台线程就可以遍历 Flush 链表，将脏页写入到磁盘。</p>
<h3 id="提高缓存命中率"><a href="#提高缓存命中率" class="headerlink" title="提高缓存命中率"></a>提高缓存命中率</h3><p>LRU 策略</p>
<p>Buffer Pool 的三个链表</p>
<ul>
<li>Free Page（空闲页），表示此页未被使用，位于 Free 链表；</li>
<li>Clean Page（干净页），表示此页已被使用，但是页面未发生修改，位于LRU 链表。</li>
<li>Dirty Page（脏页），表示此页「已被使用」且「已经被修改」，其数据和磁盘上的数据已经不一致。当脏页上的数据写入磁盘后，内存数据和磁盘数据一致，那么该页就变成了干净页。脏页同时存在于 LRU 链表和 Flush 链表。</li>
</ul>
<hr>
<p>什么是预读失效？</p>
<p>先来说说 MySQL 的预读机制。程序是有空间局部性的，靠近当前被访问数据的数据，在未来很大概率会被访问到。</p>
<p>所以，MySQL 在加载数据页时，会提前把它相邻的数据页一并加载进来，目的是为了减少磁盘 IO。</p>
<p>但是可能这些<strong>被提前加载进来的数据页，并没有被访问</strong>，相当于这个预读是白做了，这个就是<strong>预读失效</strong>。</p>
<p>如果使用简单的 LRU 算法，就会把预读页放到 LRU 链表头部，而当 Buffer Pool空间不够的时候，还需要把末尾的页淘汰掉。</p>
<p>如果这些预读页如果一直不会被访问到，就会出现一个很奇怪的问题，不会被访问的预读页却占用了 LRU 链表前排的位置，而末尾淘汰的页，可能是频繁访问的页，这样就大大降低了缓存命中率。</p>
<hr>
<p>怎么解决预读失效而导致缓存命中率降低的问题？</p>
<p>我们不能因为害怕预读失效，而将预读机制去掉，大部分情况下，局部性原理还是成立的。</p>
<p>要避免预读失效带来影响，最好就是<strong>让预读的页停留在 Buffer Pool 里的时间要尽可能的短，让真正被访问的页才移动到 LRU 链表的头部，从而保证真正被读取的热数据留在 Buffer Pool 里的时间尽可能长</strong>。</p>
<p>那到底怎么才能避免呢？</p>
<p>MySQL 是这样做的，它改进了 LRU 算法，将 LRU 划分了 2 个区域：<strong>old 区域 和 young 区域</strong>。</p>
<p>young 区域在 LRU 链表的前半部分，old 区域则是在后半部分，如下图：</p>
<img src="/2022/10/21/mysql/mysql-%E7%BC%93%E5%86%B2%E9%A1%B5LRU%E9%93%BE%E8%A1%A8.drawio.png" class="">

<p><strong>划分这两个区域后，预读的页就只需要加入到 old 区域的头部，当页被真正访问的时候，才将页插入 young 区域的头部</strong>。如果预读的页一直没有被访问，就会从 old 区域移除，这样就不会影响 young 区域中的热点数据。</p>
<p>old区域没有占用到 young 区域的位置，而且还会比 young 区域的数据更早被淘汰出去。</p>
<p>例如，预读20，然后访问20.预读20进来，同时挤出去（淘汰）10.局部性原理，不久后访问20了。把20放前面。</p>
<img src="/2022/10/21/mysql/mysql-%E7%BC%93%E5%86%B2%E9%A1%B5LRU%E9%93%BE%E8%A1%A8a.drawio.png" class="">



<hr>
<p>什么是 Buffer Pool 污染？</p>
<p>当某一个 SQL 语句<strong>扫描了大量的数据</strong>时，在 Buffer Pool 空间比较有限的情况下，可能会将 <strong>Buffer Pool 里的所有页都替换出去，导致大量热数据被淘汰了</strong>，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 IO，MySQL 性能就会急剧下降，这个过程被称为 <strong>Buffer Pool 污染</strong>。</p>
<p>注意， Buffer Pool 污染并不只是查询语句查询出了大量的数据才出现的问题，即使查询出来的结果集很小，也会造成 Buffer Pool 污染。</p>
<p>比如，在一个数据量非常大的表，执行了这条语句：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">select * from test_user <span class="built_in">where</span> name like <span class="string">&quot;%zhangsan%&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>可能这个查询出来的结果就几条记录，但是由于这条语句会发生索引失效，所以这个查询过程是全表扫描的，接着会发生如下的过程：</p>
<ul>
<li>从磁盘读到的页加入到 LRU 链表的 old 区域头部；</li>
<li>当从页里读取行记录时，也就是页被访问的时候，就要将该页放到 young 区域头部；</li>
<li>接下来拿行记录的 name 字段和字符串 xiaolin 进行模糊匹配，如果符合条件，就加入到结果集里；</li>
<li>如此往复，直到扫描完表中的所有记录。</li>
</ul>
<p>经过这一番折腾，原本 young 区域的热点数据都会被替换掉。</p>
<hr>
<p>怎么解决出现 Buffer Pool 污染而导致缓存命中率下降的问题？</p>
<p>像前面这种全表扫描的查询，很多缓冲页其实只会被访问一次，但是它却只因为被访问了一次而进入到 young 区域，从而导致热点数据被替换了。</p>
<p>LRU 链表中 young 区域就是热点数据，只要我们提高进入到 young 区域的门槛，就能有效地保证 young 区域里的热点数据不会被替换掉。</p>
<p>MySQL 是这样做的，进入到 young 区域条件增加了一个<strong>停留在 old 区域的时间判断</strong>。</p>
<p>具体是这样做的，在对某个处在 old 区域的缓存页进行第一次访问时，就在它对应的控制块中记录下来这个访问时间：</p>
<ul>
<li>如果后续的访问时间与第一次访问的时间<strong>在某个时间间隔内</strong>，那么<strong>该缓存页就不会被从 old 区域移动到 young 区域的头部</strong>；</li>
<li>如果后续的访问时间与第一次访问的时间<strong>不在某个时间间隔内</strong>，那么<strong>该缓存页移动到 young 区域的头部</strong>；</li>
</ul>
<p>这个间隔时间是由 <code>innodb_old_blocks_time</code> 控制的，默认是 1000 ms。</p>
<p>也就说，<strong>只有同时满足「被访问」与「在 old 区域停留时间超过 1 秒」两个条件，才会被插入到 young 区域头部</strong>，这样就解决了 Buffer Pool 污染的问题 。</p>
<p>另外，MySQL 针对 young 区域其实做了一个优化，为了防止 young 区域节点频繁移动到头部。young 区域前面 1&#x2F;4 被访问不会移动到链表头部，只有后面的 3&#x2F;4被访问了才会。</p>
<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p>基础概念</p>
<ul>
<li><strong>undo log（回滚日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>原子性</strong>，主要<strong>用于事务回滚和 MVCC</strong>。</li>
<li><strong>redo log（重做日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>持久性</strong>，主要<strong>用于掉电等故障恢复</strong>；</li>
<li><strong>binlog （归档日志）</strong>：是 Server 层生成的日志，主要<strong>用于数据备份和主从复制</strong>；</li>
</ul>
<p>我们在执行执行一条“增删改”语句的时候，虽然没有输入 begin 开启事务和 commit 提交事务，但是 MySQL 会<strong>隐式开启事务</strong>来执行“增删改”语句的，执行完就自动提交事务的，这样就保证了执行完“增删改”语句后，我们可以及时在数据库表看到“增删改”的结果了。</p>
<p>执行一条语句是否自动提交事务，是由 <code>autocommit</code> 参数决定的，默认是开启。所以，执行一条 update 语句也是会使用事务的。</p>
<p>一个事务在执行过程中，在还没有提交事务之前，如果MySQL 发生了崩溃，要怎么回滚到事务之前的数据呢？</p>
<h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><p>undo log 是一种用于撤销回退的日志。在事务没提交之前，MySQL 会先记录更新前的数据到 undo log 日志文件里面，当事务回滚时，可以利用 undo log 来进行回滚。</p>
<p>每当 InnoDB 引擎对一条记录进行操作（修改、删除、新增）时，要把回滚时需要的信息都记录到 undo log 里，比如：</p>
<ul>
<li>在<strong>插入</strong>一条记录时，要把这条记录的主键值记下来，这样之后回滚时只需要把这个主键值对应的记录<strong>删掉</strong>就好了；</li>
<li>在<strong>删除</strong>一条记录时，要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录<strong>插入</strong>到表中就好了；</li>
<li>在<strong>更新</strong>一条记录时，要把被更新的列的旧值记下来，这样之后回滚时再把这些列<strong>更新为旧值</strong>就好了。</li>
</ul>
<p>在发生回滚时，就读取 undo log 里的数据，然后做原先相反操作。比如当 delete 一条记录时，undo log 中会把记录中的内容都记下来，然后执行回滚操作的时候，就读取 undo log 里的数据，然后进行 insert 操作。</p>
<p>不同的操作，需要记录的内容也是不同的，所以不同类型的操作（修改、删除、新增）产生的 undo log 的格式也是不同的。</p>
<p>一条记录的每一次更新操作产生的 undo log 格式都有一个 roll_pointer 指针和一个 trx_id 事务id：</p>
<ul>
<li>通过 trx_id 可以知道该记录是被哪个事务修改的；</li>
<li>通过 roll_pointer 指针可以将这些 undo log 串成一个链表，这个链表就被称为版本链；</li>
</ul>
<p>undo log 是如何刷盘（持久化到磁盘）的？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">undo <span class="built_in">log</span> 和数据页的刷盘策略是一样的，都需要通过 redo <span class="built_in">log</span> 保证持久化。</span><br><span class="line">buffer pool 中有 undo 页，对 undo 页的修改也都会记录到 redo <span class="built_in">log</span>。redo <span class="built_in">log</span> 会每秒刷盘，提交事务时也会刷盘，数据页和 undo 页都是靠这个机制保证持久化的。</span><br></pre></td></tr></table></figure>





<h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p>Buffer Pool 是提高了读写效率没错，但是问题来了，Buffer Pool 是基于内存的，而内存总是不可靠，万一断电重启，还没来得及落盘的脏页数据就会丢失。</p>
<p>为了防止断电导致数据丢失的问题，当有一条记录需要更新的时候，InnoDB 引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录下来，<strong>这个时候更新就算完成了</strong>。</p>
<p>后续，InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是 <strong>WAL （Write-Ahead Logging）技术</strong>。</p>
<p><strong>WAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上</strong>。</p>
<img src="/2022/10/21/mysql/mysql-wal.drawio.png" class="">

<p>什么是redo log </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redo <span class="built_in">log</span> 是物理日志，</span><br><span class="line">记录了某个数据页做了什么修改，比如**对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新**，每当执行一个事务就会产生这样的一条或者多条物理日志。</span><br><span class="line">在事务提交时，只要先将 redo <span class="built_in">log</span> 持久化到磁盘即可，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。</span><br><span class="line">当系统崩溃时，虽然脏页数据没有持久化，但是 redo <span class="built_in">log</span> 已经持久化，接着 MySQL 重启后，可以根据 redo <span class="built_in">log</span> 的内容，将所有数据恢复到最新的状态。</span><br></pre></td></tr></table></figure>

<hr>
<p>redo log的作用</p>
<ul>
<li><strong>实现事务的持久性，让 MySQL 有 crash-safe 的能力</strong>，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失；</li>
<li><strong>将写操作从「随机写」变成了「顺序写」</strong>，提升 MySQL 写入磁盘的性能。</li>
</ul>
<hr>
<p>被修改 Undo 页面，需要记录对应 redo log 吗？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">需要的。</span><br><span class="line"></span><br><span class="line">开启事务后，InnoDB 层更新记录前，首先要记录相应的 undo <span class="built_in">log</span>，如果是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo <span class="built_in">log</span>，undo <span class="built_in">log</span> 会写入 Buffer Pool 中的 Undo 页面。</span><br><span class="line"></span><br><span class="line">不过，在内存修改该 Undo 页面后，需要记录对应的 redo <span class="built_in">log</span>。</span><br></pre></td></tr></table></figure>

<hr>
<p>redo log 和 undo log 区别在哪？这两种日志是属于 InnoDB 存储引擎的日志，它们的区别在于：</p>
<ul>
<li>redo log 记录了此次事务「<strong>完成后</strong>」的数据状态，记录的是更新<strong>之后</strong>的值；</li>
<li>undo log 记录了此次事务「<strong>开始前</strong>」的数据状态，记录的是更新<strong>之前</strong>的值；</li>
</ul>
<p>事务提交之前发生了崩溃，重启后会通过 undo log 回滚事务，事务提交之后发生了崩溃，重启后会通过 redo log 恢复事务。</p>
<p>所以有了 redo log，再通过 WAL 技术，InnoDB 就可以保证即使数据库发生异常重启，之前已提交的记录都不会丢失，这个能力称为 <strong>crash-safe</strong>（崩溃恢复）。可以看出来， <strong>redo log 保证了事务四大特性中的持久性</strong>。</p>
<hr>
<p>redo log 要写到磁盘，数据也要写磁盘，为什么要多此一举？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">写入 redo <span class="built_in">log</span> 的方式使用了追加操作， 所以磁盘操作是顺序写，而写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是随机写。</span><br></pre></td></tr></table></figure>

<hr>
<p>产生的 redo log 是直接写入磁盘的吗？</p>
<p>不是的。</p>
<p>实际上， 执行一个事务的过程中，产生的 redo log 也不是直接写入磁盘的，因为这样会产生大量的 I&#x2F;O 操作，而且磁盘的运行速度远慢于内存。</p>
<p>所以，redo log 也有自己的缓存—— <strong>redo log buffer</strong>，每当产生一条 redo log 时，会先写入到 redo log buffer，后续在持久化到磁盘如下图：</p>
<img src="/2022/10/21/mysql/mysql-redolog-buf.png" class="">

<p>redo log buffer 默认大小 16 MB，可以通过 <code>innodb_log_Buffer_size</code> 参数动态的调整大小，增大它的大小可以让 MySQL 处理「大事务」是不必写入磁盘，进而提升写 IO 性能。</p>
<hr>
<p>redolog 什么时候刷盘？</p>
<p>缓存在 redo log buffer 里的 redo log 还是在内存中，它什么时候刷新到磁盘？</p>
<p>主要有下面几个时机：</p>
<ul>
<li>MySQL 正常关闭时；</li>
<li>当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘；</li>
<li>InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。</li>
<li>每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘（这个策略可由 innodb_flush_log_at_trx_commit 参数控制，“双一”中的一个一）。</li>
</ul>
<hr>
<p><code>innodb_flush_log_at_trx_commit</code> 参数控制，可取的值有：0、1、2，默认值为 1，这三个值分别代表的策略如下：</p>
<ul>
<li>当设置该<strong>参数为 0 时</strong>，表示每次事务提交时 ，还是<strong>将 redo log 留在 redo log buffer 中</strong> ，该模式下在事务提交时不会主动触发写入磁盘的操作。</li>
<li>当设置该<strong>参数为 1 时</strong>，表示每次事务提交时，都<strong>将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘</strong>，这样可以保证 MySQL 异常重启之后数据不会丢失。</li>
<li>当设置该<strong>参数为 2 时</strong>，表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log <strong>写到 redo log 文件，注意写入到「 redo log 文件」并不意味着写入到了磁盘</strong>，因为操作系统的文件系统中有个 Page Cache（如果你想了解 Page Cache，可以看<a href="https://xiaolincoding.com/os/6_file_system/pagecache.html">这篇 (opens new window)</a>），Page Cache 是专门用来缓存文件数据的，所以写入「 redo log文件」意味着写入到了操作系统的文件缓存。</li>
</ul>
<p>如图：</p>
<img src="/2022/10/21/mysql/mysql-flush-log.drawio.png" class="">

<p>InnoDB 的后台线程每隔 1 秒：</p>
<ul>
<li>针对参数 0 ：会把缓存在 redo log buffer 中的 redo log ，通过调用 <code>write()</code> 写到操作系统的 Page Cache，然后调用 <code>fsync()</code> 持久化到磁盘。<strong>所以参数为 0 的策略，MySQL 进程的崩溃会导致上一秒钟所有事务数据的丢失</strong>;</li>
<li>针对参数 2 ：调用 fsync，将缓存在操作系统中 Page Cache 里的 redo log 持久化到磁盘。<strong>所以参数为 2 的策略，较取值为 0 情况下更安全，因为 MySQL 进程的崩溃并不会丢失数据，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数据才可能丢失</strong>。</li>
</ul>
<hr>
<p>这三个参数的应用场景是什么？</p>
<hr>
<p>redo log 文件写满了怎么办？</p>
<p>默认情况下， InnoDB 存储引擎有 1 个重做日志文件组( redo log Group），「重做日志文件组」由有 2 个 redo log 文件组成，这两个 redo 日志的文件名叫 ：<code>ib_logfile0</code> 和 <code>ib_logfile1</code> 。</p>
<p>在重做日志组中，每个 redo log File 的大小是固定且一致的，假设每个 redo log File 设置的上限是 1 GB，那么总共就可以记录 2GB 的操作。</p>
<p>重做日志文件组是以<strong>循环写</strong>的方式工作的，从头开始写，写到末尾就又回到开头，相当于一个环形。</p>
<img src="/2022/10/21/mysql/%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%BB%84%E5%86%99%E5%85%A5%E8%BF%87%E7%A8%8B.drawio_1.png" class="">

<p>所以 InnoDB 存储引擎会先写 ib_logfile0 文件，当 ib_logfile0 文件被写满的时候，会切换至 ib_logfile1 文件，当 ib_logfile1 文件也被写满时，会切换回 ib_logfile0 文件。</p>
<p>我们知道 redo log 是为了防止 Buffer Pool 中的脏页丢失而设计的，那么如果随着系统运行，Buffer Pool 的脏页刷新到了磁盘中，那么 redo log 对应的记录也就没用了，这时候我们擦除这些旧记录，以腾出空间记录新的更新操作。</p>
<img src="/2022/10/21/mysql/mysql-checkpoint.png" class="">

<p>图中的：</p>
<ul>
<li>write pos 和 checkpoint 的移动都是顺时针方向；</li>
<li>write pos ～ checkpoint 之间的部分（图中的红色部分），用来记录新的更新操作；</li>
<li>check point ～ write pos 之间的部分（图中蓝色部分）：待落盘的脏数据页记录；</li>
</ul>
<p>如果 write pos 追上了 checkpoint，就意味着 <strong>redo log 文件满了，这时 MySQL 不能再执行新的更新操作，也就是说 MySQL 会被阻塞</strong>（<em>因此所以针对并发量大的系统，适当设置 redo log 的文件大小非常重要</em>），此时<strong>会停下来将 Buffer Pool 中的脏页刷新到磁盘中，然后标记 redo log 哪些记录可以被擦除，接着对旧的 redo log 记录进行擦除，等擦除完旧记录腾出了空间，checkpoint 就会往后移动（图中顺时针）</strong>，然后 MySQL 恢复正常运行，继续执行新的更新操作。</p>
<p>所以，一次 checkpoint 的过程就是脏页刷新到磁盘中变成干净页，然后标记 redo log 哪些记录可以被覆盖的过程。</p>
<hr>
<h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p>前面介绍的 undo log 和 redo log 这两个日志都是 Innodb 存储引擎生成的。</p>
<p>MySQL 在完成一条更新操作后，Server 层还会生成一条 binlog，等之后事务提交的时候，会将该事物执行过程中产生的所有 binlog 统一写 入 binlog 文件。</p>
<p>binlog 文件是记录了所有数据库表结构变更和表数据修改的日志，不会记录查询类的操作，比如 SELECT 和 SHOW 操作。</p>
<hr>
<p>为什么有了 binlog， 还要有 redo log？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">binlog 是 mysql server 层的日志，只记录sql执行。</span><br><span class="line">redolog 是 innodb 引擎实现，主要用于实现crash-safe，在崩溃后重启时对数据进行恢复。</span><br></pre></td></tr></table></figure>

<hr>
<p>主从复制是怎么实现？</p>
<p>MySQL 的主从复制依赖于 binlog ，也就是记录 MySQL 上的所有变化并以二进制形式保存在磁盘上。复制的过程就是将 binlog 中的数据从主库传输到从库上。</p>
<p>这个过程一般是<strong>异步</strong>的，也就是主库上执行事务操作的线程不会等待复制 binlog 的线程同步完成。</p>
<img src="/2022/10/21/mysql/mysql-binlog%E4%B8%BB%E4%BB%8E.drawio.png" class="">

<p>具体详细过程如下：</p>
<ul>
<li>MySQL 主库在收到客户端<strong>提交事务的请求之后，会先写入 binlog，再提交事务</strong>，更新存储引擎中的数据，事务提交完成后，返回给客户端“操作成功”的响应。</li>
<li>从库会创建一个专门的 I&#x2F;O 线程，连接主库的 log dump 线程，来接收主库的 binlog 日志，再把 binlog 信息写入 relay log 的中继日志里，再返回给主库“复制成功”的响应。</li>
<li>从库会创建一个用于回放 binlog 的线程，去读 relay log 中继日志，然后回放 binlog 更新存储引擎中的数据，最终实现主从的数据一致性。</li>
</ul>
<hr>
<p>从库是不是越多越好？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">不是的。</span><br><span class="line"></span><br><span class="line">因为从库数量增加，从库连接上来的 I/O 线程也比较多，主库也要创建同样多的 <span class="built_in">log</span> dump 线程来处理复制的请求，对主库资源消耗比较高，同时还受限于主库的网络带宽。</span><br><span class="line"></span><br><span class="line">所以在实际使用中，一个主库一般跟 2～3 个从库（1 套数据库，1 主 2 从 1 备主），这就是一主多从的 MySQL 集群结构。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p>MySQL 主从复制还有哪些模型？</p>
<ul>
<li><strong>同步复制</strong>：MySQL 主库提交事务的线程要等待所有从库的复制成功响应，才返回客户端结果。这种方式在实际项目中，基本上没法用，原因有两个：一是性能很差，因为要复制到所有节点才返回响应；二是可用性也很差，主库和所有从库任何一个数据库出问题，都会影响业务。</li>
<li><strong>异步复制</strong>（默认模型）：MySQL 主库提交事务的线程并不会等待 binlog 同步到各从库，就返回客户端结果。这种模式一旦主库宕机，数据就会发生丢失。</li>
<li><strong>半同步复制</strong>：MySQL 5.7 版本之后增加的一种复制方式，介于两者之间，事务线程不用等待所有的从库复制成功响应，只要一部分复制成功响应回来就行，比如一主二从的集群，只要数据成功复制到任意一个从库上，主库的事务线程就可以返回给客户端。这种<strong>半同步复制的方式，兼顾了异步复制和同步复制的优点，即使出现主库宕机，至少还有一个从库有最新的数据，不存在数据丢失的风险</strong>。</li>
</ul>
<hr>
<p>binlog 什么时候刷盘？</p>
<p>事务执行过程中，先把日志写到 binlog cache（Server 层的 cache），事务提交的时候，再把 binlog cache 写到 binlog 文件中。</p>
<p>MySQL 给 binlog cache 分配了一片内存，每个线程一个，参数 binlog_cache_size 用于控制单个线程内 binlog cache 所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。</p>
<p>在事务提交的时候，执行器把 binlog cache 里的完整事务写入到 binlog 文件中，并清空 binlog cache。如下图：</p>
<img src="/2022/10/21/mysql/binlogcache.drawio.png" class="">

<p>虽然每个线程有自己 binlog cache，但是最终都写到同一个 binlog 文件：</p>
<ul>
<li>图中的 write，指的就是指把日志写入到 binlog 文件，但是并没有把数据持久化到磁盘，因为数据还缓存在文件系统的 page cache 里，write 的写入速度还是比较快的，因为不涉及磁盘 I&#x2F;O。</li>
<li>图中的 fsync，才是将数据持久化到磁盘的操作，这里就会涉及磁盘 I&#x2F;O，所以频繁的 fsync 会导致磁盘的 I&#x2F;O 升高。</li>
</ul>
<p>MySQL提供一个 sync_binlog 参数来控制数据库的 binlog 刷到磁盘上的频率：</p>
<ul>
<li>sync_binlog &#x3D; 0 的时候，表示每次提交事务都只 write，不 fsync，后续交由操作系统决定何时将数据持久化到磁盘；</li>
<li>sync_binlog &#x3D; 1 的时候，表示每次提交事务都会 write，然后马上执行 fsync；</li>
<li>sync_binlog &#x3D;N(N&gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。</li>
</ul>
<p>在MySQL中系统默认的设置是 sync_binlog &#x3D; 0，也就是不做任何强制性的磁盘刷新指令，这时候的性能是最好的，但是风险也是最大的。因为一旦主机发生异常重启，还没持久化到磁盘的数据就会丢失。</p>
<p>如果能容少量事务的 binlog 日志丢失的风险，为了提高写入的性能，一般会 sync_binlog 设置为 100~1000 中的某个数值。</p>
<hr>
<h2 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h2><p>事务提交后，redo log 和 binlog 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态，这样就造成两份日志之间的逻辑不一致。</p>
<p>举个例子，假设 id &#x3D; 1 这行数据的字段 name 的值原本是 ‘jay’，然后执行 <code>UPDATE t_user SET name = &#39;xiaolin&#39; WHERE id = 1;</code> 如果在持久化 redo log 和 binlog 两个日志的过程中，出现了半成功状态，那么就有两种情况：</p>
<ul>
<li><strong>如果在将 redo log 刷入到磁盘之后， MySQL 突然宕机了，而 binlog 还没有来得及写入</strong>。MySQL 重启后，通过 redo log 能将 Buffer Pool 中 id &#x3D; 1 这行数据的 name 字段恢复到新值 xiaolin，但是 binlog 里面没有记录这条更新语句，在主从架构中，binlog 会被复制到从库，由于 binlog 丢失了这条更新语句，从库的这一行 name 字段是旧值 jay，与主库的值不一致性；</li>
<li><strong>如果在将 binlog 刷入到磁盘之后， MySQL 突然宕机了，而 redo log 还没有来得及写入</strong>。由于 redo log 还没写，崩溃恢复以后这个事务无效，所以 id &#x3D; 1 这行数据的 name 字段还是旧值 jay，而 binlog 里面记录了这条更新语句，在主从架构中，binlog 会被复制到从库，从库执行了这条更新语句，那么这一行 name 字段是新值 xiaolin，与主库的值不一致性；</li>
</ul>
<p>可以看到，在持久化 redo log 和 binlog 这两份日志的时候，如果出现半成功的状态，就会造成主从环境的数据不一致性。这是因为 redo log 影响主库的数据，binlog 影响从库的数据，所以 redo log 和 binlog 必须保持一致才能保证主从数据一致。</p>
<p><strong>MySQL 为了避免出现两份日志之间的逻辑不一致的问题，使用了「两阶段提交」来解决</strong>，两阶段提交其实是分布式事务一致性协议，它可以保证多个逻辑操作要不全部成功，要不全部失败，不会出现半成功的状态。</p>
<p><strong>两阶段提交把单个事务的提交拆分成了 2 个阶段，分别是「准备（Prepare）阶段」和「提交（Commit）阶段」</strong>，每个阶段都由协调者（Coordinator）和参与者（Participant）共同完成。注意，不要把提交（Commit）阶段和 commit 语句混淆了，commit 语句执行的时候，会包含提交（Commit）阶段。</p>
<h3 id="两阶段提交的过程"><a href="#两阶段提交的过程" class="headerlink" title="两阶段提交的过程 *"></a>两阶段提交的过程 *</h3><p>在 MySQL 的 InnoDB 存储引擎中，开启 binlog 的情况下，MySQL 会同时维护 binlog 日志与 InnoDB 的 redo log，为了保证这两个日志的一致性，MySQL 使用了<strong>内部 XA 事务</strong>（是的，也有外部 XA 事务，跟本文不太相关，我就不介绍了），内部 XA 事务由 binlog 作为协调者，存储引擎是参与者。</p>
<p>当客户端执行 commit 语句或者在自动提交的情况下，MySQL 内部开启一个 XA 事务，<strong>分两阶段来完成 XA 事务的提交</strong>，如下图：</p>
<img src="/2022/10/21/mysql/mysql-%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4b.drawio.png" class="">

<p>从图中可看出，事务的提交过程有两个阶段，就是<strong>将 redo log 的写入拆成了两个步骤：prepare 和 commit，中间再穿插写入binlog</strong>，具体如下：</p>
<ul>
<li><strong>prepare 阶段</strong>：将 XID（内部 XA 事务的 ID） 写入到 redo log，同时将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘；</li>
<li><strong>commit 阶段</strong>：把 XID 写入到 binlog，然后将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit（将事务设置为 commit 状态后，刷入到磁盘 redo log 文件，所以 commit 状态也是会刷盘的）；</li>
</ul>
<p>我们来看看在两阶段提交的不同时刻，MySQL 异常重启会出现什么现象？下图中有时刻 A 和时刻 B 都有可能发生崩溃：</p>
<img src="/2022/10/21/mysql/mysql-%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.drawio.png" class="">

<p>不管是时刻 A（已经 redo log，还没写入 binlog），还是时刻 B （已经写入 redo log 和 binlog，还没写入 commit 标识）崩溃，<strong>此时的 redo log 都处于 prepare 状态</strong>。</p>
<p>在 MySQL 重启后会按顺序扫描 redo log 文件，碰到处于 prepare 状态的 redo log，就拿着 redo log 中的 XID 去 binlog 查看是否存在此 XID：</p>
<ul>
<li><strong>如果 binlog 中没有当前内部 XA 事务的 XID，说明 redolog 完成刷盘，但是 binlog 还没有刷盘，则回滚事务</strong>。对应时刻 A 崩溃恢复的情况。</li>
<li><strong>如果 binlog 中有当前内部 XA 事务的 XID，说明 redolog 和 binlog 都已经完成了刷盘，则提交事务</strong>。对应时刻 B 崩溃恢复的情况。</li>
</ul>
<p>可以看到，<strong>对于处于 prepare 阶段的 redo log，即可以提交事务，也可以回滚事务，这取决于是否能在 binlog 中查找到与 redo log 相同的 XID</strong>，如果有就提交事务，如果没有就回滚事务。这样就可以保证 redo log 和 binlog 这两份日志的一致性了。</p>
<p>所以说，<strong>两阶段提交是以 binlog 写成功为事务提交成功的标识</strong>，因为 binlog 写成功了，就意味着能在 binlog 中查找到与 redo log 相同的 XID。</p>
<p>处于 prepare 阶段的 redo log 加上完整 binlog，重启就提交事务，MySQL 为什么要这么设计?</p>
<p>binlog 已经写入了，之后就会被从库（或者用这个 binlog 恢复出来的库）使用。</p>
<p>所以，在主库上也要提交这个事务。采用这个策略，主库和备库的数据就保证了一致性。</p>
<hr>
<p>事务没提交的时候，redo log 会被持久化到磁盘吗？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">会的。</span><br><span class="line"></span><br><span class="line">事务执行中间过程的 redo <span class="built_in">log</span> 也是直接写在 redo <span class="built_in">log</span> buffer 中的，这些缓存在 redo <span class="built_in">log</span> buffer 里的 redo <span class="built_in">log</span> 也会被「后台线程」每隔一秒一起持久化到磁盘。</span><br><span class="line"></span><br><span class="line">也就是说，事务没提交的时候，redo <span class="built_in">log</span> 也是可能被持久化到磁盘的。</span><br><span class="line"></span><br><span class="line">有的同学可能会问，如果 mysql 崩溃了，还没提交事务的 redo <span class="built_in">log</span> 已经被持久化磁盘了，mysql 重启后，数据不就不一致了？</span><br><span class="line"></span><br><span class="line">放心，这种情况 mysql 重启会进行回滚操作，因为事务没提交的时候，binlog 是还没持久化到磁盘的。</span><br><span class="line"></span><br><span class="line">所以， redo <span class="built_in">log</span> 可以在事务没提交之前持久化到磁盘，但是 binlog 必须在事务提交之后，才可以持久化到磁盘。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p>两阶段提交虽然保证了两个日志文件的数据一致性，但是性能很差，主要有两个方面的影响：</p>
<ul>
<li><strong>磁盘 I&#x2F;O 次数高</strong>：对于“双1”配置，每个事务提交都会进行两次 fsync（刷盘），一次是 redo log 刷盘，另一次是 binlog 刷盘。</li>
<li><strong>锁竞争激烈</strong>：两阶段提交虽然能够保证「单事务」两个日志的内容一致，但在「多事务」的情况下，却不能保证两者的提交顺序一致，因此，在两阶段提交的流程基础上，还需要加一个锁来保证提交的原子性，从而保证多事务的情况下，两个日志的提交顺序一致。</li>
</ul>
<hr>
<h3 id="一个update-的执行过程"><a href="#一个update-的执行过程" class="headerlink" title="一个update 的执行过程"></a>一个update 的执行过程</h3><p>当优化器分析出成本最小的执行计划后，执行器就按照执行计划开始进行更新操作。</p>
<p>具体更新一条记录 <code>UPDATE t_user SET name = &#39;xiaolin&#39; WHERE id = 1;</code> 的流程如下:</p>
<ol>
<li>执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id &#x3D; 1 这一行记录：<ul>
<li>如果 id&#x3D;1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；</li>
<li>如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。</li>
</ul>
</li>
<li>执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：<ul>
<li>如果一样的话就不进行后续更新流程；</li>
<li>如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；</li>
</ul>
</li>
<li>开启事务， InnoDB 层更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。</li>
<li>InnoDB 层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面，这个时候更新就算完成了。为了减少磁盘I&#x2F;O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。这就是 <strong>WAL 技术</strong>，MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。</li>
<li>至此，一条记录更新完了。</li>
<li>在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。</li>
<li>事务提交。</li>
</ol>
<h3 id="组提交"><a href="#组提交" class="headerlink" title="组提交"></a>组提交</h3><p><strong>MySQL 引入了 binlog 组提交（group commit）机制，当有多个事务提交的时候，会将多个 binlog 刷盘操作合并成一个，从而减少磁盘 I&#x2F;O 的次数</strong>，如果说 10 个事务依次排队刷盘的时间成本是 10，那么将这 10 个事务一次性一起刷盘的时间成本则近似于 1。</p>
<p>引入了组提交机制后，prepare 阶段不变，只针对 commit 阶段，将 commit 阶段拆分为三个过程：</p>
<ul>
<li><strong>flush 阶段</strong>：多个事务按进入的顺序将 binlog 从 cache 写入文件（不刷盘）；</li>
<li><strong>sync 阶段</strong>：对 binlog 文件做 fsync 操作（多个事务的 binlog 合并一次刷盘）；</li>
<li><strong>commit 阶段</strong>：各个事务按顺序做 InnoDB commit 操作；</li>
</ul>
<h1 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h1><h2 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h2><p>查看连接mysql的客户端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show processlist;</span><br></pre></td></tr></table></figure>

<p>查看空闲链接的最大时长</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;wait_timeout&#x27;;</span><br></pre></td></tr></table></figure>

<p>断开链接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kill connection +6;</span><br></pre></td></tr></table></figure>

<p>查看MySQL 的连接数限制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;max_connections&#x27;;</span><br></pre></td></tr></table></figure>

<p>查看当前事务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM information_schema.INNODB_TRX\G;</span><br></pre></td></tr></table></figure>

<p>查看锁</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mysql 8.0.* 之前的版本使用该方式查询</span></span><br><span class="line">SELECT * FROM information_schema.INNODB_LOCKS\G</span><br><span class="line"></span><br><span class="line"><span class="comment"># mysql 8.0.1 之后的版本使用</span></span><br><span class="line">SELECT * FROM performance_schema.data_locks\G</span><br></pre></td></tr></table></figure>

<p>查看因为锁而等待的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mysql 8.0.1 之前的版本使用该方式查询</span></span><br><span class="line">SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS\G</span><br><span class="line"></span><br><span class="line"><span class="comment"># mysql 8.0.1 之后的版本使用</span></span><br><span class="line">SELECT * FROM performance_schema.data_lock_waits\G</span><br></pre></td></tr></table></figure>






<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h3><p> explain 命令看到的这条语句的执行情况。 explain [要查看的sql]，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">explain select * from t <span class="built_in">where</span> a between 10000 and 20000;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 对于执行计划，参数有：</span></span><br><span class="line">possible_keys 字段表示可能用到的索引；表示mysql可以选择的索引，多个的时候以 <span class="string">&quot;,&quot;</span>  分隔</span><br><span class="line">key 字段表示实际用的索引，如果这一项为 NULL，说明没有使用索引；</span><br><span class="line">key_len 表示索引的长度；</span><br><span class="line">rows 表示扫描的数据行数。</span><br><span class="line"><span class="built_in">type</span> 表示数据扫描类型，我们需要重点看这个。</span><br><span class="line">extra </span><br><span class="line"></span><br><span class="line"><span class="comment">## type 字段就是描述了找到所需数据时使用的扫描方式是什么，常见扫描类型的执行效率从低到高的顺序为：</span></span><br><span class="line">All（全表扫描）；</span><br><span class="line">index（全索引扫描）；</span><br><span class="line">range（索引范围扫描）；<span class="comment">## 一般在 where 子句中使用 &lt; 、&gt;、in、between 等关键词，只检索给定范围的行，属于范围查找</span></span><br><span class="line">ref（非唯一索引扫描）；</span><br><span class="line">eq_ref（唯一索引扫描）；</span><br><span class="line">const（结果只有一条的主键或唯一索引扫描）。</span><br><span class="line"></span><br><span class="line"><span class="comment">## extra 字段</span></span><br><span class="line">Using filesort ：当查询语句中包含 group by 操作，而且无法利用索引完成排序操作的时候， 这时不得不选择相应的排序算法进行，甚至可能会通过文件排序，效率是很低的，所以要避免这种问题的出现。</span><br><span class="line">Using temporary：使了用临时表保存中间结果，MySQL 在对查询结果排序时使用临时表，常见于排序 order by 和分组查询 group by。效率低，要避免这种问题的出现。</span><br><span class="line">Using index：所需数据只需在索引即可全部获得，不须要再到表中取数据，也就是使用了覆盖索引，避免了回表操作，效率不错。</span><br><span class="line">Using Index condition，表示使用到了索引下推（有回表），例如查询 age&gt;10 and name=zhang </span><br></pre></td></tr></table></figure>



<h3 id="select-from-performance-schema-data-locks-G"><a href="#select-from-performance-schema-data-locks-G" class="headerlink" title="select * from performance_schema.data_locks\G;"></a>select * from performance_schema.data_locks\G;</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">主要看</span><br><span class="line">INDEX_NAME——使用的索引</span><br><span class="line">LOCK_TYPE: RECORD <span class="comment">### RECORD 表示行级锁</span></span><br><span class="line">LOCK_MODE: X,GAP,INSERT_INTENTION <span class="comment">##</span></span><br><span class="line"><span class="comment"># X 代表独占锁；</span></span><br><span class="line"><span class="comment"># X,GAP代表间隙锁；</span></span><br><span class="line"><span class="comment"># X,REC_NOT_GAP代表行锁；</span></span><br><span class="line"><span class="comment"># S 代表共享锁；</span></span><br><span class="line"><span class="comment"># INSERT_INTENTION代表插入意向锁；</span></span><br><span class="line">LOCK_STATUS: WAITING <span class="comment">## GRENTED表示已经获得锁，WAITING表示在等待锁</span></span><br><span class="line">LOCK_DATA: <span class="comment">### 一般是一个节点的值。我们默认这个节点往左的间隙锁加到一起算一个next-key锁，然后根据前面LOCK_MODE来判断是行锁还是间隙锁还是next-key锁。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>database</category>
        <category>mysql</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title>读书计划</title>
    <url>/2022/01/02/%E8%AF%BB%E4%B9%A6%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<p>关注书单 —— oreilly ；broadview ；华章教育；异步图书；图灵教育</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ul>
<li><input checked="" disabled="" type="checkbox"> 《操作系统导论》——Remzi H. Arpaci-Dussea</li>
<li><input checked="" disabled="" type="checkbox"> 《网络是怎样连接的》</li>
<li><input checked="" disabled="" type="checkbox"> 《图解网络》</li>
<li><input checked="" disabled="" type="checkbox"> 《Computer Networking A Top-Down Approach》—— KUROSE Ross</li>
<li><input checked="" disabled="" type="checkbox"> 《程序员的自我修养 – 链接、装载与库》</li>
<li><input checked="" disabled="" type="checkbox"> 《深入理解计算机系统》</li>
<li><input checked="" disabled="" type="checkbox"> 《现代操作系统：原理与实现》—— anderew S</li>
<li><input checked="" disabled="" type="checkbox"> 《HTTP.The.Definitive.Guide》</li>
<li><input checked="" disabled="" type="checkbox"> 《Wireshark网络分析就这么简单》</li>
<li><input disabled="" type="checkbox"> 《wireshark网络分析的艺术》</li>
<li><input disabled="" type="checkbox"> 《TCP&#x2F;IP 详解》 卷一卷二</li>
<li><input disabled="" type="checkbox"> <a href="https://book.douban.com/subject/34467459/">BPF Performance Tools : Linux System and Application Observability</a>——Brendan Gregg</li>
<li><input disabled="" type="checkbox"> <a href="https://book.douban.com/subject/24840375/">Systems Performance : Enterprise and the Cloud</a>《[性能之巅 : 洞悉系统、企业与云计算]》——Brendan Gregg</li>
</ul>
<h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><ul>
<li><input checked="" disabled="" type="checkbox"> 《go web 编程》</li>
<li><input checked="" disabled="" type="checkbox"> 《go in action》</li>
<li><input checked="" disabled="" type="checkbox"> 《GO语言圣经》</li>
<li><input disabled="" type="checkbox"> 《go 学习笔记》 下卷</li>
<li><input checked="" disabled="" type="checkbox"> 《Go语言底层原理剖析》—— 郑建勋</li>
<li><input checked="" disabled="" type="checkbox"> 《Go语言设计与实现》—— draveness</li>
<li><input checked="" disabled="" type="checkbox"> 《GO语言高级编程》——曹春晖</li>
<li><input checked="" disabled="" type="checkbox"> 《Go专家编程》—— <a href="https://books.studygolang.com/GoExpertProgramming/FOREWORD.html">https://books.studygolang.com/GoExpertProgramming/FOREWORD.html</a></li>
<li><input checked="" disabled="" type="checkbox"> 《Go语言轻松进阶》——<a href="http://tigerb.cn/go/#/kernal/">http://tigerb.cn/go/#/kernal/</a></li>
<li><input disabled="" type="checkbox"> 《Go设计模式实战》——<a href="http://tigerb.cn/go/#/">http://tigerb.cn/go/#/</a></li>
</ul>
<span id="more"></span>



<h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><ul>
<li><input checked="" disabled="" type="checkbox"> 《鸟哥私房菜》</li>
<li><input checked="" disabled="" type="checkbox"> 《Linux命令行与shell脚本编程大全》——[<a href="https://book.douban.com/search/%E5%B8%83%E9%B2%81%E5%A7%86%EF%BC%8C%E5%B8%83%E9%9B%B7%E6%96%AF%E7%BA%B3%E6%B1%89">美]布鲁姆，布雷斯纳汉</a></li>
<li><input checked="" disabled="" type="checkbox"> 《Linux Shell脚本攻略》——[[美] Clif Flynt](<a href="https://book.douban.com/search/Clif">https://book.douban.com/search/Clif</a> Flynt) &#x2F; [[印] Shantanu Tushar](<a href="https://book.douban.com/search/Shantanu">https://book.douban.com/search/Shantanu</a> Tushar) &#x2F; [[印] Sarath Lakshman](<a href="https://book.douban.com/search/Sarath">https://book.douban.com/search/Sarath</a> Lakshman)</li>
<li><input disabled="" type="checkbox"> 《Linux Bible》—— Christopher Negus</li>
<li><input disabled="" type="checkbox"> 《The Linux Programming Interface》</li>
<li><input disabled="" type="checkbox"> 《Unix&#x2F;Linux编程实践教程》——<a href="https://book.douban.com/subject/1219329/">https://book.douban.com/subject/1219329/</a></li>
<li><input disabled="" type="checkbox"> 《深入理解LINUX内核》！——<a href="https://book.douban.com/subject/2287506/">https://book.douban.com/subject/2287506/</a></li>
<li><input disabled="" type="checkbox"> 《深入Linux内核架构》——<a href="https://book.douban.com/subject/4843567/">https://book.douban.com/subject/4843567/</a></li>
<li><input disabled="" type="checkbox"> 《Linux内核设计的艺术》</li>
<li><input disabled="" type="checkbox"> 《Linux内核设计与实现》！——<a href="https://book.douban.com/subject/6097773/">https://book.douban.com/subject/6097773/</a></li>
<li><input disabled="" type="checkbox"> 《Linux二进制分析》</li>
<li><input disabled="" type="checkbox"> 《深入理解LINUX网络内幕》！——<a href="https://book.douban.com/subject/1834459/">https://book.douban.com/subject/1834459/</a></li>
<li><input disabled="" type="checkbox"> 《Linux设备驱动程序》！</li>
<li><input disabled="" type="checkbox"> 《深入理解Linux虚拟内存管理》——<a href="https://book.douban.com/subject/1865724/">https://book.douban.com/subject/1865724/</a> ！！！！！找英文版本，翻译得不好</li>
<li><input disabled="" type="checkbox"> 《Linux内核技术手册》</li>
</ul>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><ul>
<li><p><input checked="" disabled="" type="checkbox"> 
《The C Programming Language》</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
《C Primer Plus》</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
《UNIX环境高级编程》</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《UNIX网络编程》</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《C专家编程》</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《C陷阱与缺陷》</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《C和指针》</p>
</li>
</ul>
<h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><ul>
<li><input checked="" disabled="" type="checkbox"> 《汇编语言》——王爽</li>
<li><input disabled="" type="checkbox"> 《现代编译原理：Ｃ语言描述 》</li>
<li><input disabled="" type="checkbox"> 《编译原理》</li>
<li><input disabled="" type="checkbox"> 《汇编语言程序设计》——[Richard Blum](<a href="https://book.douban.com/search/Richard">https://book.douban.com/search/Richard</a> Blum)</li>
<li><input disabled="" type="checkbox"> 《Algorithms to live by the computer science of human decisions》</li>
</ul>
<h2 id="数据库和消息队列"><a href="#数据库和消息队列" class="headerlink" title="数据库和消息队列"></a>数据库和消息队列</h2><ul>
<li><input checked="" disabled="" type="checkbox"> 《mysql技术内幕》</li>
<li><input checked="" disabled="" type="checkbox"> 《高性能mysql》</li>
<li><input checked="" disabled="" type="checkbox"> 《redis设计与实现》</li>
<li><input checked="" disabled="" type="checkbox"> 《redis开发与运维》</li>
<li><input checked="" disabled="" type="checkbox"> 《Redis 深度历险：核心原理与应用实践》</li>
<li><input checked="" disabled="" type="checkbox"> 《Kafka: The Definitive Guide》——Neha Narkhede, Gwen Shapira &amp; Todd Palino</li>
<li><input checked="" disabled="" type="checkbox"> 《Aerospike: Architecture of a Real-Time Operational DBMS》—— p1389-srinivasan ；vldb论文</li>
<li><input checked="" disabled="" type="checkbox"> 《mongo in action》</li>
<li><input disabled="" type="checkbox"> 《深入学习mongodb》</li>
<li><input disabled="" type="checkbox"> 《mongodb 权威指南》</li>
<li><input disabled="" type="checkbox"> 《Redis核心原理与实践》</li>
<li><input disabled="" type="checkbox"> todo etcd 类的书籍</li>
<li><input disabled="" type="checkbox"> todo clickhouse 类的书籍</li>
</ul>
<h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><ul>
<li><input checked="" disabled="" type="checkbox"> 《第一本docker书》</li>
<li><input disabled="" type="checkbox"> 《docker 入门到实践》</li>
<li><input disabled="" type="checkbox"> 《Programming Kubernetes》 —— [Michael Hausenblas](<a href="https://book.douban.com/search/Michael">https://book.douban.com/search/Michael</a> Hausenblas) &#x2F; Stefan Schimanski</li>
<li><input checked="" disabled="" type="checkbox"> 《深入剖析Kubernetes》—— 张磊</li>
<li><input checked="" disabled="" type="checkbox"> 《大型网站技术架构：核心原理与案例分析》——李智慧</li>
<li><input checked="" disabled="" type="checkbox"> 《大型分布式网站设计与实践》 ——陈康贤</li>
<li><input checked="" disabled="" type="checkbox"> 《Designing Data-Intensive Applications》《数据密集型应用系统设计》</li>
<li><input disabled="" type="checkbox"> 《Bigtable_A Distributed Storage System for Structured Data》</li>
<li><input disabled="" type="checkbox"> 《MapReduce_Simplified Data Processing on Large Clusters》</li>
<li><input disabled="" type="checkbox"> 《The Google File System》</li>
</ul>
<h2 id="工程数学"><a href="#工程数学" class="headerlink" title="工程数学"></a>工程数学</h2><ul>
<li><input disabled="" type="checkbox"> 《离散数学》——<a href="https://book.douban.com/search/%E5%A4%9A%E8%A5%BF">多西</a></li>
<li><input disabled="" type="checkbox"> 《离散数学》——<a href="https://book.douban.com/author/4610691">László Lovász</a> &#x2F; [József Pelikán](<a href="https://book.douban.com/search/J%C3%B3zsef">https://book.douban.com/search/József</a> Pelikán) &#x2F; [Katalin Vesztergombi](<a href="https://book.douban.com/search/Katalin">https://book.douban.com/search/Katalin</a> Vesztergombi)</li>
<li><input disabled="" type="checkbox"> 《离散数学与组合数学》——[(美)Ralph P.Grimaldi](<a href="https://book.douban.com/search/Ralph">https://book.douban.com/search/Ralph</a> P.Grimaldi)</li>
<li><input disabled="" type="checkbox"> 《离散数学及其应用》——<a href="https://book.douban.com/author/224945">肯尼思 H.罗森 (Kenneth H.Rosen)</a></li>
<li><input disabled="" type="checkbox"> 《线性代数及其应用》——[[美] David C. Lay](<a href="https://book.douban.com/search/David">https://book.douban.com/search/David</a> C. Lay) &#x2F; [[美] Steven R. Lay](<a href="https://book.douban.com/search/Steven">https://book.douban.com/search/Steven</a> R. Lay) &#x2F; [[美] Judi J. McDonald](<a href="https://book.douban.com/search/Judi">https://book.douban.com/search/Judi</a> J. McDonald)</li>
<li><input disabled="" type="checkbox"> 《线性代数（第5版）》——[[美] Gilbert Strang](<a href="https://book.douban.com/search/Gilbert">https://book.douban.com/search/Gilbert</a> Strang)</li>
<li><input disabled="" type="checkbox"> 《概率统计》——[（美）Morris H．DeGroot](<a href="https://book.douban.com/search/Morris">https://book.douban.com/search/Morris</a> H．DeGroot) &#x2F; [（美）Mark J．Schervish](<a href="https://book.douban.com/search/Mark">https://book.douban.com/search/Mark</a> J．Schervish)</li>
</ul>
<h2 id="算法相关"><a href="#算法相关" class="headerlink" title="算法相关"></a>算法相关</h2><ul>
<li><p><input disabled="" type="checkbox"> 
《算法竞赛入门经典》——刘汝佳</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《算法竞赛入门经典–训练指南》——刘汝佳</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《算法竞赛入门经典–算法与实现》</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《算法竞赛入门经典–习题与解答》—— 陈锋</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《算法艺术与信息学竞赛》——刘汝佳 黄</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《算法竞赛进阶指南》——<a href="https://book.douban.com/search/%E6%9D%8E%E7%85%9C%E4%B8%9C">李煜东</a></p>
</li>
<li><p><input disabled="" type="checkbox"> 
《计算机算法设计与分析》—— <a href="https://book.douban.com/author/521232">Alfred V.Aho (阿霍)</a> &#x2F; [John E.Hopcroft (霍普克劳夫特)](<a href="https://book.douban.com/search/John">https://book.douban.com/search/John</a> E.Hopcroft) &#x2F; [Jeffrey D.Ullman (乌尔曼)](<a href="https://book.douban.com/search/Jeffrey">https://book.douban.com/search/Jeffrey</a> D.Ullman)</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《ACM国际大学生程序设计竞赛——基本算法》——俞勇</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《ACM国际大学生程序设计竞赛——知识与入门》——俞勇</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《ACM国际大学生程序设计竞赛——算法与实现》——俞勇</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《ACM国际大学生程序设计竞赛——题目与解读》——俞勇</p>
</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li><input checked="" disabled="" type="checkbox"> 《深入理解java虚拟机》——周志明</li>
<li><input disabled="" type="checkbox"> 《数据算法》</li>
<li><input disabled="" type="checkbox"> 《基于云计算的数据科学》</li>
<li><input disabled="" type="checkbox"> 《Architecting Modern Data Platforms》</li>
<li><input disabled="" type="checkbox"> 《Streaming Systems》</li>
<li><input disabled="" type="checkbox"> 《MapReduce Design Patterns》《MapReduce设计模式》</li>
<li><input disabled="" type="checkbox"> 《可视化流数据》</li>
<li><input disabled="" type="checkbox"> 《Hadoop: The Definitive Guide》</li>
<li><input disabled="" type="checkbox"> 《Hadoop Application Architectures》</li>
<li><input disabled="" type="checkbox"> 《Stream Processing with Apache Flink》</li>
<li><input disabled="" type="checkbox"> 《HBase权威指南》</li>
<li><input disabled="" type="checkbox"> 《HBase应用架构》</li>
<li><input disabled="" type="checkbox"> 《Flume》</li>
<li><input disabled="" type="checkbox"> </li>
<li><input disabled="" type="checkbox"> 《计算机图形学》—— PeterShirley</li>
<li><input disabled="" type="checkbox"> 《数理逻辑》——[Herbert B.Enderton](<a href="https://book.douban.com/search/Herbert">https://book.douban.com/search/Herbert</a> B.Enderton)</li>
<li><input disabled="" type="checkbox"> 《TCP&#x2F;IP基础教程基于实验的方法》——<a href="https://book.douban.com/search/ShivendraPan">ShivendraPan</a></li>
<li><input disabled="" type="checkbox"> 《计算机网络实验教程》——<a href="https://book.douban.com/search/%E9%A9%AC%E4%BF%AE">马修</a></li>
<li><input disabled="" type="checkbox"> 《TCP&#x2F;IP路由技术》——<a href="https://book.douban.com/search/%E5%A4%9A%E4%BC%8A%E5%B0%94%EF%BC%8C%E5%8D%A1%E7%BD%97%E5%B0%94">（美）多伊尔，（美）卡罗尔</a></li>
<li><input disabled="" type="checkbox"> </li>
<li><input disabled="" type="checkbox"> 《数字信号处理》</li>
<li><input disabled="" type="checkbox"> 《网络信息安全的真相》——布鲁斯 ● 施耐尔</li>
<li><input disabled="" type="checkbox"> 《深度探索嵌入式操作系统：从零开始设计、架构和开发》——彭东</li>
</ul>
<h3 id="大佬们推荐的书籍"><a href="#大佬们推荐的书籍" class="headerlink" title="大佬们推荐的书籍"></a>大佬们推荐的书籍</h3><ul>
<li><p><input disabled="" type="checkbox"> 
《Computer Organisation and Design》</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《深入理解 linux 内核架构》</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《奔跑吧 linux 内核》</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《linux kernel development》</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《Principle of Transaction Processing》</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《Modern X86 Assembly Language》</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《Practical Packet Analysis 3rd》</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《The Art of Unix Programming》</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《Understanding the Linux Kernel》</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《Understanding Linux Network internals》</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《The Art of Multiprocessor Programming》</p>
</li>
</ul>
]]></content>
      <categories>
        <category>读书计划</category>
      </categories>
      <tags>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式理论</title>
    <url>/2021/10/01/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h1><p>事务的基本特性</p>
<ul>
<li><strong>原子性（Atomicity）</strong> </li>
<li><strong>一致性（Consistency）</strong> </li>
<li><strong>隔离性（Isolation）</strong> </li>
<li><strong>持久性（Durability）</strong></li>
</ul>
<span id="more"></span>





<h1 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h1><p>CAP理论</p>
<ul>
<li>一致性(Consistency) </li>
<li>可用性(Availability) </li>
<li>分区容错性(Partition Tolerance)</li>
</ul>
<h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>例子：client 在 主节点写入数据x&#x3D;3，在从节点读取数据x&#x3D;3。从节点和主节点对client提供的服务数据是一份一致的数据。在主从未达到一致前，是不会对client的查询提供服务的。</p>
<p>作用：一致性说的是客户端的每次读操作，不管访问哪个节点，要么读到的都是同一份最新的数据，要么读取失败。</p>
<p>一般实现做法：写入主数据库后，在向从数据库同步期间要将从数据库锁定，待同步完成后再释放锁，以免在新数据写入成功后，向从数据库查询到旧的数据。</p>


<p>分布式一致性的特点：</p>
<p>client写入会有延迟，client读取会有延迟。因为对于client来说，集群是一个整体，各个节点需要达到数据一致才能对client提供服务。</p>
<p><strong>一致性强调 的不是数据完整，而是各节点间的数据一致。</strong>在客户端看来，集群和单机在数据一致性上是一样的。一旦数据更新完成并成功返回客户端后，那么分布式系统中所有节点在同一时间的数据完全一致。</p>
<h2 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h2><p>例子：client 在向集群写入和读取的时候必须是有响应的。（集群的成员可以有宕机的，但是集群这个整体必须有响应给client）</p>
<p>作用：集群是作为一个整体向外提供服务，集群的成员可以有宕机的，但是集群这个整体必须有响应给到client，不能有集群不可用的情况。</p>
<p>一般实现做法：写入主数据库后，主数据库同步数据给从节点。不对client的操作进行干涉</p>
<img src="/2021/10/01/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/distributed-Availability.drawio.png" class="">

<p>分布式可用性特点：所有请求都有响应，且不会出现响应超时或响应错误。整个集群只要不挂，就一定会有响应。client读取到的数据可能是旧数据。</p>
<p>可用性强调的是各个节点构成的整个集群的可用行。在客户端看来，集群和单机在可用行上是一样的。只要集群不挂或者说集群处于健康状态，就可以向集群发起请求并获得服务 </p>
<h2 id="分区容错性"><a href="#分区容错性" class="headerlink" title="分区容错性"></a>分区容错性</h2><p>例子：client 向集群写入 x&#x3D;3 ，当集群x&#x3D;3的leader宕机后，集群的其他节点依然保存着部分其他数据，client可以查y&#x3D;1，x的久数据x&#x3D;2</p>
<p>作用：集群其一个结点挂掉不影响另一个结点对外提供服务。</p>
<p>一般实现：给数据库添加复制节点和将leader数据库进行分区（例如三主三从）</p>
<img src="/2021/10/01/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/distributed-Partition-Tolerance.drawio.png" class="">

<p>分区容错性特点：集群高可用。</p>
<p>这样的系统不能达成一致性，需要给出数据冲突，给出数据冲突就需要维护数据版本。</p>
<p>CAP定律说的是在一个分布式计算机系统中，一致性，可用性和分区容错性这三种保证无法同时得到满足，最多满足两个。</p>
<p>一般来说 分区容错性是分布式系统必备的能力，所以分布式数据库就是在满足分区容错性的基础上，一致性和可用性两者选其一。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>CA：CA 模型，在分布式系统中不存在。因为舍弃 P，意味着舍弃分布式系统，就比如单机版 关系型数据库 MySQL</p>
<p>CP：CP 模型，采用 CP 模型的分布式系统，一旦因为消息丢失、延迟过高发生了网络分区， 就影响用户的体验和业务的可用性。因为为了防止数据不一致，集群将拒绝新数据的写</p>
<p>入，典型的应用是 ZooKeeper，Etcd 和 HBase。</p>
<p>AP：AP 模型，采用 AP 模型的分布式系统，实现了服务的高可用。用户访问系统的时候，都 能得到响应数据，不会出现响应错误，但当出现分区故障时，相同的读操作，访问不同 的节点，得到响应数据可能不一样。典型应用就比如 Cassandra 和 DynamoDB。</p>
<h1 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h1><p>分布式BASE理论 是由eBay架构师提出的。BASE是对CAP中一致性和可用性权衡的结果，其核心思想是即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来达到最终一致性（Eventual consistency）</p>
<p>BASE是<strong>Basically Available(基本可用）</strong>、<strong>Soft state(软状态）</strong>和<strong>Eventually consistent(最终一致性）</strong>三个短语的简写。</p>
<p><code>ACID</code>是传统数据库常用的设计理念，<code>追求强一致性</code>模型。</p>
<p><code>BASE</code>支持的是大型分布式系统，提出通过<code>牺牲强一致性</code>获得<code>高可用性</code>。</p>
<p>BASE理论本质就是AP</p>
<h2 id="Basically-Available（基本可用）"><a href="#Basically-Available（基本可用）" class="headerlink" title="Basically Available（基本可用）"></a>Basically Available（基本可用）</h2><p>一般来说，对于client 请求量大的情况，可以对请求进行一些降级等。让集群集群服务依然可以提供服务。达到可用例如常见的：</p>
<ul>
<li>限流&#x2F;服务熔断（client的部分请求是满足不了的。直接拒绝）</li>
<li>延迟响应（client的请求需要等待数据一致才能服务，这个服务请求延迟可能由原来的毫秒提升到要数秒）</li>
<li>服务降级（client的请求得到的不是实时数据）</li>
<li>弹性扩容（增加集群的分区节点。这样在达到数据最终一致性会降低延迟。每个节点处理数量降低，能为更多client请求提供服务）</li>
</ul>
<h2 id="Soft-state（软状态）"><a href="#Soft-state（软状态）" class="headerlink" title="Soft state（软状态）"></a>Soft state（软状态）</h2><p>允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。</p>
<h2 id="Eventually-consistent（最终一致性）"><a href="#Eventually-consistent（最终一致性）" class="headerlink" title="Eventually consistent（最终一致性）"></a>Eventually consistent（最终一致性）</h2><p>上面说软状态，然后不可能一直是软状态，必须有个时间期限。在期限过后，应当保证所有副本保持数据一致性，从而达到数据的最终一致性。这个时间期限取决于网络延时、系统负载、数据复制方案设计等等因素。</p>
]]></content>
      <categories>
        <category>分布式</category>
        <category>理论</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式协议</title>
    <url>/2022/11/27/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><ul>
<li>强一致性：在任意时刻，所有节点中的数据是一样的。</li>
<li>弱一致性：数据更新后，如果能容忍后续的访问只能访问到部分或者全部访问不到</li>
<li>最终一致性：不保证在任意时刻任意节点上的同一份数据都是相同的，但节点间的数据会最终达到一致状态。</li>
<li>线性一致性：&#x3D;强一致性&#x3D;原子一致性&#x3D;cap理论中的c</li>
<li>数字签名：非对称加密中，使用私钥加密，而别人只能通过公钥检查确认是否是配对的私钥加密的（只有本人才有私钥）</li>
<li>校验和：对数据的完整性进行检查的一种简单方法。不同的输入数据都会输出一个显著不同的值。（节省通信成本）</li>
<li>分布式互斥</li>
<li>临界资源</li>
<li>单节点变更</li>
<li>共识算法：分布式节点用来相互通信，达到一致性的算法</li>
<li>随机超时</li>
<li>任期：相当于数据版本，不同数据对应不同版本，而且版本号递增。</li>
<li>心跳</li>
<li>二阶段提交</li>
<li>TCC</li>
<li>操作顺序性</li>
<li>事务标识符</li>
<li>异步修复</li>
<li>反熵</li>
<li>幂等操作：任意多次执行所产生的影响均与一次执行的影响相同。f(x)&#x3D;f(f(x))</li>
</ul>
<span id="more"></span>



<p>分布式共识算法</p>
<h1 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a>Paxos算法</h1><p> Basic Paxos 算法，描述的是多节点之间如何就某个值(提案 Value)达成共 识;</p>
<p> Multi-Paxos 思想，描述的是执行多个 Basic Paxos 实例，就一系列值达成共 识。（Basic Paxos 是 Multi-Paxos 思想的核心，说白了，Multi-Paxos 就是多执行 几次 Basic Paxos）</p>
<p>Paxos有两个重要的特性: <strong>1. Paxos协议只能确定一个值，2. Paxos协议的值一旦确定便不可以修改。</strong></p>
<p>关于一个值不能修改的问题。是指一个事件的发生确定之后不能修改。可以理解为像日志一样， 记录设置一个key1&#x3D;v1，这个记录不能修改了。但是后续需要修改key1可以继续添加一个记录key1&#x3D;v2 。但是  key1&#x3D;v1和key1&#x3D;v2 这两条记录是被保存下来不能修改的。</p>
<p>paxos在处理的时候分为两阶段去处理，为什么要两阶段呢？第一阶段其实是为了获取节点的状态，是否已经确定值。</p>
<p>集群维护一致性的本质是依靠一个类似版本号的东西来确认每个节点的状态。节点的事件每次新增都对应不同的版本号。而这个版本号是线性递增的，通过这个特性就能确定事件的顺序性。</p>
<h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><ul>
<li>共识协商</li>
<li>提案</li>
<li>提案编号</li>
<li>二阶段提交</li>
<li>活锁问题：两个proposer提起prepare然后提交的时候被另一个proposer的prepare给抢占了。然后提交失败，议案编号+1后继续提又替换了另一个proposer的prepare，导致两个proposer一直在相互竞争，都没有提交成功</li>
</ul>
<h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ul>
<li>接受者(Acceptor)：集群中所有节点都是接受者,Acceptor 有 N 个，Proposer 提出的 value 必须获得超过半数(N&#x2F;2+1)的 Acceptor批准后才能通过。Acceptor 之间完全对等独立。</li>
<li>提议者(Proposer)：集群中接收到client请求的接受者节点同时具备提议者身份,Proposer 可以有多个，Proposer 提出议案（value）。所谓 value，可以是任何操作，比如“设置某个变量的值为value”。不同的 Proposer 可以提出不同的 value，例如某个Proposer 提议“将变量 X 设置为 1”，另一个 Proposer 提议“将变量 X 设置为 2”，但对同一轮 Paxos过程，最多只有一个 value 被批准。</li>
<li>学习者(Learner)：集群中备份节点，每个acceptor通过提议后，后发给learner，然后learner根据就收到的所有acceptor的提议情况。自己判断哪些值是集群共识的。然后再同步给所有acceptor，优化：由提议者同步给学习者，然后学习者同步给整个集群。因为只有提议者才知道整个集群的情况（因为提议者和所有接受者发起过提议，所以提议者是能判断某个值在这个集群的最新值的。），这样优化后可以减少不必要的网络io，因为在proposer就已经确定的值没必要让learner再次去和各个acceptor确定。</li>
</ul>
<p>整个共识协商的过程分为两个阶段：准备阶段和提交阶段</p>
<h2 id="共识协商过程"><a href="#共识协商过程" class="headerlink" title="共识协商过程"></a>共识协商过程</h2><h3 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h3><ul>
<li>Proposer选择一个提议编号n，向所有的Acceptor广播Prepare（n）请求。在准备请求中是不需要指定提议的值的，只需要携带提案编号。</li>
<li>Acceptor接收到Prepare（n）请求，若提议编号n比之前接收的Prepare请求都要大，则承诺将不会接收提议编号比n小的提议，并且带上之前Accept的提议中编号小于n的最大的提议，否则不予理会。</li>
</ul>
<h3 id="提交阶段"><a href="#提交阶段" class="headerlink" title="提交阶段"></a>提交阶段</h3><p>在收到大多数节点的准备响应之后，会分别 发送接受请求</p>
<ul>
<li>整个协议最为关键的点：Proposer得到了Acceptor响应<ul>
<li>如果<strong>未超过半数</strong>accpetor响应，直接转为提议失败；</li>
<li>如果<strong>超过多数</strong>Acceptor的承诺，又分为不同情况：<ul>
<li>如果所有Acceptor都未接收过值（都为null），那么向所有的Acceptor发起自己的值和提议编号n，一定是所有Acceptor都没接受过值；</li>
<li>如果有部分Acceptor接收过值，那么从所有接受过的值中<strong>选择对应的提议编号最大的</strong>作为提议的值，提议编号仍然为n。但此时Proposer就不能提议自己的值，只能信任Acceptor通过的值，维护一但获得确定性取值就不能更改原则；</li>
</ul>
</li>
</ul>
</li>
<li>Acceptor接收到提议后，如果该提议版本号不等于自身保存记录的版本号（第一阶段记录的），不接受该请求，相等则写入本地。</li>
</ul>
<p>当提议者收到大多数接受者的写入响应时，就同步给学习者，学习者同步给所有的接受者和备份等操作。</p>
<p>流程如下：</p>
<img src="/2022/11/27/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE/paxos-1.drawio.png" class="">



<p>记忆：</p>
<ol>
<li><p><em>理解第一阶段accpetor的处理流程</em>：如果本地已经写入了，不再接受和同意后面的所有请求，并返回本地写入的值；如果本地未写入，则本地记录该请求的版本号，并不再接受其他版本号的请求，简单来说只信任最后一次提交的版本号的请求，使其他版本号写入失效；</p>
</li>
<li><p><em>理解第二阶段proposer的处理流程</em>：未超过半数accpetor响应，提议失败；超过半数的accpetor值都为空才提交<strong>自身要写入的值</strong>，否则选择非空值里<strong>版本号最大的值</strong>提交，最大的区别在于是提交的值是自身的还是使用以前提交的。</p>
</li>
</ol>
<p><strong>proposer1和proposer2串行执行</strong></p>
<p>proposer1提议结束后，proposer2发起提议</p>
<img src="/2022/11/27/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE/paxos-3.drawio.png" class="">



<p><strong>proposer 和 acceptor 通信失败情况</strong></p>
<p>如果其中的某个Acceptor没响应怎么处理？</p>
<p>未超过半数，那么Proposer会递增版本号重新发起提议</p>
<img src="/2022/11/27/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE/paxos-4.drawio.png" class="">



<p><strong>proposer1和proposer2交错执行</strong></p>
<p>如果只写成功了一个accpetor又怎么处理，写成功两个呢？如果多个proposer并发写会导致accpetor写成不同值吗？</p>
<p>proposer1和proposer2同时发起提议</p>
<img src="/2022/11/27/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE/paxos-2.drawio.png" class="">



<p>问题：</p>
<ul>
<li>learner角色是做什么用？同步集群状态。</li>
<li>为什么是超过半数同意？只要超过半数，必然不会出现第二个数据不一致还能提议通过的proposer，因为为了获得accoptor提议通过，超过半数会至少和一个acceptor上的冲突。</li>
</ul>
<p>看到 learner 有两种设计方式：</p>
<ul>
<li>一种是只接收proposer的提议通过的消息，然后同步给所有的acceptor</li>
<li>一种是接收所有的acceptor的提议通过的消息，然后learner内部统计只要超过半数，就认为集群通过这个消息，同步给所有的acceptor</li>
</ul>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;os/signal&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;syscall&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var addrP string</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">init</span></span>() &#123;</span><br><span class="line">	flag.StringVar(&amp;addrP, <span class="string">&quot;addr&quot;</span>, <span class="string">&quot;localhost:9090&quot;</span>, <span class="string">&quot;input addr&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var srv Server</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	flag.Parse()</span><br><span class="line"></span><br><span class="line">	//var err error</span><br><span class="line">	//////  临时配置</span><br><span class="line">	var ClusterMember = []string&#123;</span><br><span class="line">		<span class="string">&quot;localhost:9090&quot;</span>,</span><br><span class="line">		<span class="string">&quot;localhost:9091&quot;</span>,</span><br><span class="line">		<span class="string">&quot;localhost:9092&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	srv.Events = make(map[string]interface&#123;&#125;) // todo 检查读写</span><br><span class="line">	srv.Addr = addrP</span><br><span class="line">	srv.ClusterMember = ClusterMember</span><br><span class="line">	srv.Proposal = 1</span><br><span class="line"></span><br><span class="line">	srv.context, srv.cancel = context.WithCancel(context.TODO())</span><br><span class="line"></span><br><span class="line">	srv.Start()</span><br><span class="line">	sig := make(chan os.Signal)</span><br><span class="line">	signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">	&lt;-sig</span><br><span class="line">	srv.Stop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">	ApiPrepare = <span class="string">&quot;ServerApi.Prepare&quot;</span></span><br><span class="line">	ApiAccept  = <span class="string">&quot;ServerApi.Accept&quot;</span></span><br><span class="line">	ApiSync    = <span class="string">&quot;ServerApi.Sync&quot;</span></span><br><span class="line">	ApiLearn   = <span class="string">&quot;ServerApi.Learn&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> Server struct &#123;</span><br><span class="line">	ClusterMember []string</span><br><span class="line">	Addr          string</span><br><span class="line">	Events        map[string]interface&#123;&#125; // 确定后不可改变的 key value</span><br><span class="line"></span><br><span class="line">	Proposal int64 //每个节点已知的最大提案编号。</span><br><span class="line"></span><br><span class="line">	Api      *ServerApi</span><br><span class="line">	Listener net.Listener</span><br><span class="line"></span><br><span class="line">	context context.Context</span><br><span class="line">	cancel  context.CancelFunc</span><br><span class="line"></span><br><span class="line">	sync.WaitGroup</span><br><span class="line">	sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *Server) Start() error &#123;</span><br><span class="line">	// 启动api</span><br><span class="line">	go <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;启动rpc服务&quot;</span>)</span><br><span class="line">		s.Add(1)</span><br><span class="line">		s.RpcServer()</span><br><span class="line">		s.Done()</span><br><span class="line">		log.Println(<span class="string">&quot;关闭rpc服务&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	//for <span class="built_in">test</span></span><br><span class="line">	go <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">		ticker := time.NewTicker(3 * time.Second)</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			&lt;-ticker.C</span><br><span class="line">			s.Lock()</span><br><span class="line">			log.Printf(<span class="string">&quot;events:%+v \n&quot;</span>, s.Events)</span><br><span class="line">			log.Printf(<span class="string">&quot;sever:%+v \n&quot;</span>, s.Proposal)</span><br><span class="line">			s.Unlock()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="built_in">return</span> nil</span><br><span class="line">&#125;</span><br><span class="line">func (s *Server) Stop() error &#123;</span><br><span class="line">	s.cancel()</span><br><span class="line">	s.Listener.Close()</span><br><span class="line">	s.Wait()</span><br><span class="line">	log.Println(<span class="string">&quot;安全退出&quot;</span>)</span><br><span class="line">	<span class="built_in">return</span> nil</span><br><span class="line">&#125;</span><br><span class="line">func (s *Server) RpcServer() (err error) &#123;</span><br><span class="line">	// rpc服务</span><br><span class="line">	api := new(ServerApi)</span><br><span class="line">	api.server = s</span><br><span class="line">	s.Api = api</span><br><span class="line"></span><br><span class="line">	err = rpc.Register(api)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_, port, _ := net.SplitHostPort(s.Addr)</span><br><span class="line">	listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, fmt.Sprintf(<span class="string">&quot;:%s&quot;</span>, port))</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	log.Println(<span class="string">&quot;listen on&quot;</span>, s.Addr)</span><br><span class="line">	s.Listener = listener</span><br><span class="line">	var tempDelay time.Duration</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn, err := s.Listener.Accept()</span><br><span class="line">		// 直接仿照 net/http 包的异常处理</span><br><span class="line">		<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">			select &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-s.context.Done():</span><br><span class="line">				//log.Println(err)</span><br><span class="line">				<span class="built_in">return</span> err</span><br><span class="line">			default:</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> ne, ok := err.(net.Error); ok &amp;&amp; ne.<span class="function"><span class="title">Temporary</span></span>() &#123;</span><br><span class="line">				<span class="keyword">if</span> tempDelay == 0 &#123;</span><br><span class="line">					tempDelay = 5 * time.Millisecond</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					tempDelay *= 2</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> max := 1 * time.Second; tempDelay &gt; max &#123;</span><br><span class="line">					tempDelay = max</span><br><span class="line">				&#125;</span><br><span class="line">				time.Sleep(tempDelay)</span><br><span class="line">				<span class="built_in">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			//log.Println(err)</span><br><span class="line">			<span class="built_in">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		go s.serve(conn)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> nil</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">func (s *Server) serve(conn net.Conn) &#123;</span><br><span class="line">	s.Add(1)</span><br><span class="line">	rpc.ServeConn(conn)</span><br><span class="line">	s.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> ItemReq struct &#123;</span><br><span class="line">	Key      string</span><br><span class="line">	Proposal int64       // 提案编号</span><br><span class="line">	Value    interface&#123;&#125; // 在prepare请求中为nil,共用下请求体</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">type</span> ItemReply struct &#123;</span><br><span class="line">	IsSuccess bool</span><br><span class="line">	Err       error</span><br><span class="line"></span><br><span class="line">	// [k,n,v]</span><br><span class="line">	Key      string</span><br><span class="line">	Proposal int64</span><br><span class="line">	Value    interface&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">发起提议</span><br><span class="line">接收提议</span><br><span class="line">接收learner的同步信息</span><br><span class="line">接收proposser的提议通过信息（收到信息的节点成为learner），然后通知同步各个acceptor</span><br><span class="line">*/</span><br><span class="line"><span class="built_in">type</span> ServerApi struct &#123;</span><br><span class="line">	server *Server</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// acceptor Job：接收提议 （准备阶段）</span><br><span class="line">func (s *ServerApi) Prepare(req ItemReq, reply *ItemReply) (err error) &#123;</span><br><span class="line">	log.Printf(<span class="string">&quot;调用 Prepare %+v&quot;</span>, req)</span><br><span class="line">	// todo 检查</span><br><span class="line">	server := s.server</span><br><span class="line">	server.Lock()</span><br><span class="line">	defer server.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> req.Proposal &lt;= server.Proposal &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;提案编号过小不处理&quot;</span>)</span><br><span class="line">		reply.IsSuccess = <span class="literal">false</span></span><br><span class="line">		reply.Err = fmt.Errorf(<span class="string">&quot;提案编号过小不处理&quot;</span>)</span><br><span class="line">		// todo 是否需要把 最大的proposal同步回去？避免让proposer做无用功</span><br><span class="line">		reply.Proposal = server.Proposal</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	val := server.Events[req.Key]</span><br><span class="line">	// todo 是否要对存在与否进行判断，还是不管</span><br><span class="line"></span><br><span class="line">	//[n,v]</span><br><span class="line">	reply.IsSuccess = <span class="literal">true</span></span><br><span class="line">	reply.Proposal = server.Proposal</span><br><span class="line">	reply.Value = val</span><br><span class="line"></span><br><span class="line">	server.Proposal = req.Proposal // 节点 承诺处理的提案编号，只有更大的编号过来才能让节点改变</span><br><span class="line">	<span class="built_in">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// acceptor Job：接收提交 （提交阶段）</span><br><span class="line">func (s *ServerApi) Accept(req ItemReq, reply *ItemReply) (err error) &#123;</span><br><span class="line">	log.Printf(<span class="string">&quot;调用 Accept %+v&quot;</span>, req)</span><br><span class="line">	// todo 检查</span><br><span class="line">	server := s.server</span><br><span class="line">	server.Lock()</span><br><span class="line">	defer server.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> req.Proposal != server.Proposal &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;提案编号不等于提议阶段的编号,需要先进行提议&quot;</span>)</span><br><span class="line">		reply.IsSuccess = <span class="literal">false</span></span><br><span class="line">		reply.Err = fmt.Errorf(<span class="string">&quot;提案编号不等于提议阶段的编号&quot;</span>)</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	server.Events[req.Key] = req.Value</span><br><span class="line">	reply.IsSuccess = <span class="literal">true</span></span><br><span class="line">	//reply.Key = req.Key</span><br><span class="line">	//reply.Proposal = req.Proposal</span><br><span class="line">	//reply.Value = req.Value</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// acceptor Job ：接收leaner的同步信息（learner的信息是代表集群议案通过的。需要无条件接收）</span><br><span class="line">func (s *ServerApi) Sync(req ItemReq, reply *ItemReply) (err error) &#123;</span><br><span class="line">	log.Println(<span class="string">&quot;调用Sync&quot;</span>)</span><br><span class="line">	// todo 检查</span><br><span class="line">	server := s.server</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> req.Proposal &lt; server.Proposal &#123;</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	server.Lock()</span><br><span class="line">	defer server.Unlock()</span><br><span class="line"></span><br><span class="line">	server.Events[req.Key] = req.Value</span><br><span class="line">	reply.IsSuccess = <span class="literal">true</span></span><br><span class="line">	<span class="built_in">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// learner Job ：被proposer指定为learner了。负责同步提案信息给所有节点。</span><br><span class="line">func (s *ServerApi) Learn(req ItemReq, reply *ItemReply) (err error) &#123;</span><br><span class="line">	log.Println(<span class="string">&quot;调用Learn&quot;</span>)</span><br><span class="line">	// todo 检查</span><br><span class="line">	server := s.server</span><br><span class="line"></span><br><span class="line">	var wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> i, addr := range server.ClusterMember &#123;</span><br><span class="line">		<span class="keyword">if</span> addr == s.server.Addr &#123;</span><br><span class="line">			s.Sync(ItemReq&#123;</span><br><span class="line">				Key:      req.Key,</span><br><span class="line">				Value:    req.Value,</span><br><span class="line">				Proposal: req.Proposal,</span><br><span class="line">			&#125;, &amp;ItemReply&#123;&#125;)</span><br><span class="line">			<span class="built_in">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		wg.Add(1)</span><br><span class="line">		go func(i int, addr string) &#123;</span><br><span class="line">			defer wg.Done()</span><br><span class="line">			var e error</span><br><span class="line">			client, e := rpc.Dial(<span class="string">&quot;tcp&quot;</span>, addr)</span><br><span class="line">			<span class="keyword">if</span> e != nil &#123;</span><br><span class="line">				log.Println(e)</span><br><span class="line">				<span class="built_in">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			req := ItemReq&#123;</span><br><span class="line">				Key:      req.Key,</span><br><span class="line">				Value:    req.Value,</span><br><span class="line">				Proposal: req.Proposal,</span><br><span class="line">			&#125;</span><br><span class="line">			reply := &amp;ItemReply&#123;&#125;</span><br><span class="line">			select &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-time.After(1 * time.Second):</span><br><span class="line">				e = fmt.Errorf(<span class="string">&quot;call timeout&quot;</span>)</span><br><span class="line">			<span class="keyword">case</span> call := &lt;-client.Go(ApiSync, req, reply, nil).Done:</span><br><span class="line">				e = call.Error</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> e != nil &#123;</span><br><span class="line">				client.Close()</span><br><span class="line">			&#125;</span><br><span class="line">			client.Close()</span><br><span class="line">			// 不管同步成不成功，都直接不处理了</span><br><span class="line">		&#125;(i, addr)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	<span class="built_in">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *ServerApi) Get(req ItemReq, reply *ItemReply) (err error) &#123;</span><br><span class="line">	log.Println(<span class="string">&quot;调用GET&quot;</span>)</span><br><span class="line">	// todo 检查</span><br><span class="line">	server := s.server</span><br><span class="line">	server.Lock()</span><br><span class="line">	defer server.Unlock()</span><br><span class="line"></span><br><span class="line">	val, ok := server.Events[req.Key]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		err = fmt.Errorf(<span class="string">&quot;empty key&quot;</span>)</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	reply.IsSuccess = <span class="literal">true</span></span><br><span class="line">	reply.Key = req.Key</span><br><span class="line">	reply.Proposal = server.Proposal</span><br><span class="line">	reply.Value = val</span><br><span class="line">	<span class="built_in">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 改变节点状态 proposer</span><br><span class="line">// 发起提议</span><br><span class="line">// 根据提议情况</span><br><span class="line">// 进行提交</span><br><span class="line">// 根据提交情况</span><br><span class="line">// 提交成功后挑选一个learner节点</span><br><span class="line">func (s *ServerApi) Set(req ItemReq, reply *ItemReply) (errs error) &#123;</span><br><span class="line">	log.Println(<span class="string">&quot;调用SET&quot;</span>)</span><br><span class="line">	// todo 检查</span><br><span class="line">	server := s.server</span><br><span class="line">	//log.Println(req)</span><br><span class="line"></span><br><span class="line">	server.Lock()</span><br><span class="line">	server.Proposal = server.Proposal + 1</span><br><span class="line">	req.Proposal = server.Proposal</span><br><span class="line">	server.Unlock()</span><br><span class="line"></span><br><span class="line">	// 发起提议</span><br><span class="line">	log.Println(<span class="string">&quot;发起提议准备&quot;</span>)</span><br><span class="line">	prepareReplys := make([]*ItemReply, len(server.ClusterMember))</span><br><span class="line">	var wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> i, addr := range server.ClusterMember &#123;</span><br><span class="line">		<span class="keyword">if</span> addr == s.server.Addr &#123;</span><br><span class="line">			// todo</span><br><span class="line">			<span class="built_in">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		wg.Add(1)</span><br><span class="line">		go func(i int, addr string) &#123;</span><br><span class="line">			defer wg.Done()</span><br><span class="line">			var e error</span><br><span class="line">			client, e := rpc.Dial(<span class="string">&quot;tcp&quot;</span>, addr)</span><br><span class="line">			<span class="keyword">if</span> e != nil &#123;</span><br><span class="line">				log.Println(e)</span><br><span class="line">				<span class="built_in">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			proposeReq := ItemReq&#123;</span><br><span class="line">				Key:      req.Key,</span><br><span class="line">				Value:    req.Value,</span><br><span class="line">				Proposal: req.Proposal,</span><br><span class="line">			&#125;</span><br><span class="line">			proposeReply := &amp;ItemReply&#123;&#125;</span><br><span class="line">			select &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-time.After(1 * time.Second):</span><br><span class="line">				e = fmt.Errorf(<span class="string">&quot;call timeout&quot;</span>)</span><br><span class="line">			<span class="keyword">case</span> call := &lt;-client.Go(ApiPrepare, proposeReq, proposeReply, nil).Done:</span><br><span class="line">				e = call.Error</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> e != nil &#123;</span><br><span class="line">				log.Printf(<span class="string">&quot;err :%+v&quot;</span>, e)</span><br><span class="line">				client.Close()</span><br><span class="line">			&#125;</span><br><span class="line">			prepareReplys[i] = proposeReply</span><br><span class="line">			client.Close()</span><br><span class="line">		&#125;(i, addr)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">	// 判断</span><br><span class="line">	var proposal int64</span><br><span class="line">	var value interface&#123;&#125; = nil</span><br><span class="line">	acceptCount := 0</span><br><span class="line">	<span class="keyword">for</span> _, r := range prepareReplys &#123;</span><br><span class="line">		<span class="keyword">if</span> r == nil &#123;</span><br><span class="line">			<span class="built_in">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> r.IsSuccess &#123;</span><br><span class="line">			acceptCount++</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> r.Value != nil &amp;&amp; r.Proposal &gt; proposal &#123; // 使用响应中最大的提案编号的值</span><br><span class="line">			proposal = r.Proposal</span><br><span class="line">			value = r.Value</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> acceptCount &lt;= len(server.ClusterMember)/2 &#123;</span><br><span class="line">		//reply.</span><br><span class="line">		reply.Err = fmt.Errorf(<span class="string">&quot;提议未经半数节点以上通过&quot;</span>)</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> value == nil &#123; //说明上面所有节点都没有值,使用自己的值</span><br><span class="line">		//proposal = req.Proposal</span><br><span class="line">		value = req.Value</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 发起提交</span><br><span class="line">	log.Println(<span class="string">&quot;发起提交&quot;</span>)</span><br><span class="line">	acceptReplys := make([]*ItemReply, len(server.ClusterMember))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, addr := range server.ClusterMember &#123;</span><br><span class="line">		<span class="keyword">if</span> addr == s.server.Addr &#123;</span><br><span class="line">			// todo</span><br><span class="line">			<span class="built_in">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		wg.Add(1)</span><br><span class="line">		go func(i int, addr string) &#123;</span><br><span class="line">			defer wg.Done()</span><br><span class="line">			var e error</span><br><span class="line">			client, e := rpc.Dial(<span class="string">&quot;tcp&quot;</span>, addr)</span><br><span class="line">			<span class="keyword">if</span> e != nil &#123;</span><br><span class="line">				log.Println(e)</span><br><span class="line">				<span class="built_in">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			req := ItemReq&#123;</span><br><span class="line">				Key:      req.Key,</span><br><span class="line">				Proposal: req.Proposal,</span><br><span class="line">				Value:    value,</span><br><span class="line">			&#125;</span><br><span class="line">			reply := &amp;ItemReply&#123;&#125;</span><br><span class="line">			select &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-time.After(1 * time.Second):</span><br><span class="line">				e = fmt.Errorf(<span class="string">&quot;call timeout&quot;</span>)</span><br><span class="line">			<span class="keyword">case</span> call := &lt;-client.Go(ApiAccept, req, reply, nil).Done:</span><br><span class="line">				e = call.Error</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> e != nil &#123;</span><br><span class="line">				client.Close()</span><br><span class="line">			&#125;</span><br><span class="line">			acceptReplys[i] = reply</span><br><span class="line">			client.Close()</span><br><span class="line">		&#125;(i, addr)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">	// 判断，超过一半提交成功就可以确认同步给集群</span><br><span class="line">	successCount := 0</span><br><span class="line">	<span class="keyword">for</span> _, r := range acceptReplys &#123;</span><br><span class="line">		<span class="keyword">if</span> r == nil &#123;</span><br><span class="line">			<span class="built_in">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> r.IsSuccess &#123;</span><br><span class="line">			successCount++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> successCount &lt;= len(server.ClusterMember)/2 &#123;</span><br><span class="line">		//reply.</span><br><span class="line">		reply.Err = fmt.Errorf(<span class="string">&quot;提交未经半数节点以上通过&quot;</span>)</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	server.Lock()</span><br><span class="line">	server.Events[req.Key] = value</span><br><span class="line">	server.Unlock()</span><br><span class="line"></span><br><span class="line">	reply.IsSuccess = <span class="literal">true</span></span><br><span class="line">	reply.Key = req.Key</span><br><span class="line">	reply.Proposal = server.Proposal</span><br><span class="line">	reply.Value = value</span><br><span class="line"></span><br><span class="line">	//return</span><br><span class="line">	// 选一个learner去同步集群,这里直接先用自己的leaner</span><br><span class="line">	//server.ClusterMember[]</span><br><span class="line">	log.Println(<span class="string">&quot;指定节点去学习&quot;</span>)</span><br><span class="line">	client, err := rpc.Dial(<span class="string">&quot;tcp&quot;</span>, server.Addr)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		reply.Err = err</span><br><span class="line">	&#125;</span><br><span class="line">	learnReq := ItemReq&#123;</span><br><span class="line">		Key:   req.Key,</span><br><span class="line">		Value: value,</span><br><span class="line">		//Version: 0,</span><br><span class="line">	&#125;</span><br><span class="line">	learnReply := &amp;ItemReply&#123;&#125;</span><br><span class="line">	select &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(1 * time.Second):</span><br><span class="line">		err = fmt.Errorf(<span class="string">&quot;call timeout&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> call := &lt;-client.Go(ApiLearn, learnReq, learnReply, nil).Done:</span><br><span class="line">		err = call.Error</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		log.Println(err)</span><br><span class="line">		client.Close()</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	client.Close()</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<p>多个节点可以同时写入不同的记录，在这种情况下，如何做到分布式集群间的强一致性呢 ？ 所以这里需要引入日志或者队列，只要保证所有的记录在所有的节点上的日志或者队列中是一致的，最终按照日志或队列的顺序执行，那么数据就一定是一致的。这种对多个不同的记录分别进行Paxos协议的过程，我们称之为Multi Paxos。例如raft就是multi-paxos理论的一种具体实现。</p>
<h1 id="Raft算法"><a href="#Raft算法" class="headerlink" title="Raft算法"></a>Raft算法</h1><p>raft算法是以领导者为准，同步日志给跟随者，以实现分布式共识，达到最终一致性的算法。</p>
<p>主要分为三个点：</p>
<ul>
<li>领导者选举</li>
<li>日志同步</li>
<li>集群成员节点变更</li>
</ul>
<h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>任期：</p>
<p>任期编号：可以理解为集群的版本号（不是代码的版本号）。谁的版本号高就以哪个节点为准。</p>
<p>日志：主要包含每次执行的指令，版本号等信息，类似于mysql的binlog。（是否有必要做一个redolog？没有必要，集群不需要支持事务。）</p>
<p>随机超时：避免所有候选人发起选举，出现分票，大家都选举失败的情况。以及避免羊群效应，如果所有节点同时进行选举，最终其实只有一个能成为leader，其他人没必要发起选举。</p>
<p>状态机：对于相同的输入，不管重复运行多少次，最终的内部状态和输出都是相同的。一般只要操作具备顺序性，就可以认为是一种状态机的机制。例如日志就可以实现一种状态机。</p>
<p>单节点变更：集群添加新节点或者移除节点的时候一个一个移，每移动一个等待集群稳定后才能移动下一个。</p>
<p>集群成员节点有三种角色身份：</p>
<ul>
<li><strong>Leader</strong>，即主节点，同一时刻只有一个 Leader，负责协调和管理其他节点；</li>
<li><strong>Candidate</strong>，即候选者，每一个节点都可以成为 Candidate，节点在该角色下才可以被选为新的 Leader；</li>
<li><strong>Follower</strong>，Leader 的跟随者，不可以发起选举。</li>
</ul>
<p>领导者负责写入，所有访问到跟随者节点的请求都转发到领导者那里进行写入。</p>
<p>选举规则：多数派投票选举算法，核心思想是“少数服从多数”，获得投票最多的节点成为主。</p>
<p>当集群leader宕机后，集群处于选举状态的时候不能提供服务，要等下一个leader出现才能提供服务。</p>
<h2 id="共识协商过程-1"><a href="#共识协商过程-1" class="headerlink" title="共识协商过程"></a>共识协商过程</h2><p>1.每个节点初始化都是follower，并实时接收leader的心跳，如果一定时间内没有收到leader的心跳，就会转换为candidate状态，然后发起选举（发给每个节点，不管这个节点是什么状态），这次选举是带着 选举版号的。一个节点只能投出一张票，若发起选举请求的节点获得超过一半的投票，则成为主节点，状态转换为leader，并负责给所有节点发送心跳，而其他不管是正在选举的candidate还是leader还是follower，收到leader的的心跳都会自己转为follower（candidate看这个心跳的选举版本是否高于自己，看票数是否高于自己，leader看选举版号是否大于自己）。其他节点根据接收到的选举请求的先后顺序，回复是否同意成为主。这里需要注意的是，在每一轮选举中，一个节点只能投出一张票。</p>
<p>集群只有leader处理写请求，follower收到写请求有两种处理方式</p>
<ul>
<li>follower代理转发给leader。</li>
<li>follower直接返回leader的地址给client，让client去处理。</li>
</ul>
<h3 id="关于选举领导者"><a href="#关于选举领导者" class="headerlink" title="关于选举领导者"></a>关于选举领导者</h3><p>1.每个节点初始化都是follower，并周期性检查leader的心跳，如果跟随者的定期检查中发现领导者的心跳超时了。可以认为领导者已经死了（宕机）。自己成为候选人，向其他人发起投票选举（让别人投自己为领导者）。赢得大多数选票的候选人人成为领导者。</p>
<p>2.领导者周期性地向所有跟随者发送心跳，用于通知别人自己是领导者和通知别人自己还活着。</p>
<p>3.每个节点提供选举接口，当收到候选人的投票请求的时候，根据自身情况投出自己的一票。每个节点对于一个任期（版本）只能投一票。（这个根据自身情况是看自己是否已经投票了。和检查候选人的日志是否比自己的日志更加新。拥有最新日志的候选人成为领导者才是健康的。和投票的版本号大小。）</p>
<img src="/2022/11/27/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE/raft-%E8%A7%92%E8%89%B2%E8%BD%AC%E6%8D%A2%E5%9B%BE.drawio.png" class="">



<h3 id="关于日志复制"><a href="#关于日志复制" class="headerlink" title="关于日志复制"></a>关于日志复制</h3><p>领导者处理客户端请求，写入本地日志后，将日志项提交到本地状态机，同步给其他节点（也可以异步同步给其他节点，看请求设置的安全等级。）等待其他的跟随者节点同步成功后。返回客户端请求。异步可以放在心跳中同步给跟随者。</p>
<img src="/2022/11/27/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE/raft-log-1.drawio.png" class="">



<h3 id="关于集群节点变更"><a href="#关于集群节点变更" class="headerlink" title="关于集群节点变更"></a>关于集群节点变更</h3><p>集群成员变更的最大哦问题是可能会出现两个leader</p>
<p>疑问： 如果同时都成为 candidate，然后每个人的投票都没有集中，a给b，b给c，c给d，d给e，e给a，怎么办？引入随机超时，错开</p>
<p>随机超时还有一个好处是可以避免羊群效应</p>
<h2 id="Raft的设计"><a href="#Raft的设计" class="headerlink" title="Raft的设计"></a>Raft的设计</h2><p>ps：以下只是便于自己学习和理解raft而写的demo。并非成熟的实现raft的服务。</p>
<p>集群选举设计关注点：</p>
<ul>
<li><p>集群成员的角色转化</p>
</li>
<li><p>集群成员以谁的优先级高</p>
</li>
<li><p>集群成员的任务</p>
</li>
<li><p>集群成员的投票</p>
</li>
</ul>
<p>节点主要有两个任务：</p>
<ul>
<li><p>一个是提供接口和集群成员通信</p>
</li>
<li><p>一个是根据自身的角色去做对应的事情</p>
<ul>
<li>Follower：检查心跳</li>
<li>Candidate：发起选举</li>
<li>Leader：发送心跳</li>
</ul>
</li>
</ul>
<p>架构图如下：</p>
<img src="/2022/11/27/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE/raft-design.drawio.png" class="">



<p>第一个任务要提供 tcp 服务，这里为了方便直接使用golang提供的rpc</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;os/signal&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;syscall&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> addrP <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> referrerP <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.StringVar(&amp;addrP, <span class="string">&quot;addr&quot;</span>, <span class="string">&quot;localhost:9090&quot;</span>, <span class="string">&quot;input addr&quot;</span>)</span><br><span class="line">	flag.StringVar(&amp;referrerP, <span class="string">&quot;ref&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;input referrer&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> srv Server</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	flag.Parse()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//var err error</span></span><br><span class="line">	<span class="comment">//////  临时配置</span></span><br><span class="line">	<span class="keyword">var</span> ClusterMember = []<span class="type">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;localhost:9090&quot;</span>,</span><br><span class="line">		<span class="string">&quot;localhost:9091&quot;</span>,</span><br><span class="line">		<span class="string">&quot;localhost:9092&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> HeartbeatTimeout = <span class="type">int64</span>(<span class="number">3</span>) <span class="comment">//单位秒</span></span><br><span class="line"></span><br><span class="line">	srv.Data = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;) <span class="comment">// todo 检查读写</span></span><br><span class="line">	srv.Term = <span class="number">0</span></span><br><span class="line">	srv.State = Follower</span><br><span class="line">	srv.Addr = addrP</span><br><span class="line">	srv.Referrer = referrerP</span><br><span class="line">	srv.ClusterMember = ClusterMember</span><br><span class="line">	srv.HeartbeatTimeout = HeartbeatTimeout</span><br><span class="line">	srv.LogFilePath = <span class="string">&quot;/tmp/log-&quot;</span> + addrP</span><br><span class="line">	srv.context, srv.cancel = context.WithCancel(context.TODO())</span><br><span class="line"></span><br><span class="line">	srv.Start()</span><br><span class="line">	sig := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">	signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">	&lt;-sig</span><br><span class="line">	srv.Stop()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Follower = <span class="literal">iota</span></span><br><span class="line">	Candidate</span><br><span class="line">	Leader</span><br><span class="line">	Nobody <span class="comment">// Candidate 日志落后，竞选失败 啥也不是，等待leader 发心跳过来，转成follower</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	ApiGet = <span class="string">&quot;ServerApi.Get&quot;</span></span><br><span class="line">	ApiSet = <span class="string">&quot;ServerApi.Set&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	CommunicateHeartbeat = <span class="string">&quot;ServerApi.Heartbeat&quot;</span></span><br><span class="line">	CommunicateElection  = <span class="string">&quot;ServerApi.Election&quot;</span></span><br><span class="line">	CommunicateSyncLog   = <span class="string">&quot;ServerApi.SyncLog&quot;</span></span><br><span class="line"></span><br><span class="line">	CommunicateRegister = <span class="string">&quot;ServerApi.Register&quot;</span></span><br><span class="line">	CommunicateLogout   = <span class="string">&quot;ServerApi.Logout&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">server</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	Api    *ServerApi</span><br><span class="line">	Logger *ServerLog</span><br><span class="line"></span><br><span class="line">	ClusterMember []<span class="type">string</span></span><br><span class="line">	Addr          <span class="type">string</span></span><br><span class="line">	State         <span class="type">int</span> <span class="comment">// 角色</span></span><br><span class="line"></span><br><span class="line">	Leader           <span class="type">string</span></span><br><span class="line">	Heartbeat        <span class="type">int64</span></span><br><span class="line">	HeartbeatTimeout <span class="type">int64</span></span><br><span class="line">	Term             <span class="type">int64</span></span><br><span class="line"></span><br><span class="line">	VoteTerm <span class="type">int64</span> <span class="comment">// 投票给的那个任期；本节点已知的最大的任期</span></span><br><span class="line">	VoteTo   <span class="type">string</span></span><br><span class="line"></span><br><span class="line">	Data <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	Listener    net.Listener</span><br><span class="line">	LogFile     *os.File</span><br><span class="line">	LogFilePath <span class="type">string</span></span><br><span class="line"></span><br><span class="line">	Referrer <span class="type">string</span> <span class="comment">//推荐人，用于新节点加入集群，先指定一个已经在集群中的节点</span></span><br><span class="line"></span><br><span class="line">	context context.Context</span><br><span class="line">	cancel  context.CancelFunc</span><br><span class="line"></span><br><span class="line">	sync.WaitGroup</span><br><span class="line">	sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> Start() <span class="type">error</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动日志</span></span><br><span class="line">	<span class="comment">//go func() &#123;</span></span><br><span class="line">	log.Println(<span class="string">&quot;启动日志服务&quot;</span>)</span><br><span class="line">	<span class="comment">//	s.Add(1)</span></span><br><span class="line">	s.LogServer()</span><br><span class="line">	<span class="comment">//	s.Done()</span></span><br><span class="line">	<span class="comment">//	log.Println(&quot;关闭日志服务&quot;)</span></span><br><span class="line">	<span class="comment">//&#125;()</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动api</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;启动rpc服务&quot;</span>)</span><br><span class="line">		s.Add(<span class="number">1</span>)</span><br><span class="line">		s.RpcServer()</span><br><span class="line">		s.Done()</span><br><span class="line">		log.Println(<span class="string">&quot;关闭rpc服务&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 单节点加入集群。</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s.Referrer) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">			err := s.Register()</span><br><span class="line">			<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			log.Println(err)</span><br><span class="line">		&#125;</span><br><span class="line">		log.Println(<span class="string">&quot;单节点加入集群：&quot;</span>, s.ClusterMember)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动角色工作，心跳，选举</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;启动角色服务&quot;</span>)</span><br><span class="line">		s.Add(<span class="number">1</span>)</span><br><span class="line">		s.Work()</span><br><span class="line">		s.Done()</span><br><span class="line">		log.Println(<span class="string">&quot;关闭角色服务&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> Stop() <span class="type">error</span> &#123;</span><br><span class="line">	s.cancel()</span><br><span class="line">	s.Logout()</span><br><span class="line">	s.Listener.Close()</span><br><span class="line">	s.Logger.Close()</span><br><span class="line">	s.Wait()</span><br><span class="line">	log.Println(<span class="string">&quot;安全退出&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> Work() (err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 各个角色要做的事情</span></span><br><span class="line">	ticker := time.NewTicker(<span class="number">2</span> * time.Second)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-s.context.Done():</span><br><span class="line">			<span class="comment">// 收到退出通知，关闭下游</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">			<span class="keyword">switch</span> s.State &#123;</span><br><span class="line">			<span class="keyword">case</span> Follower:</span><br><span class="line">				<span class="comment">// 检查心跳</span></span><br><span class="line">				s.followerJob()</span><br><span class="line">			<span class="keyword">case</span> Candidate:</span><br><span class="line">				<span class="comment">// 发起选举, 检查选举资格是否被否决</span></span><br><span class="line">				s.electionJob()</span><br><span class="line">			<span class="keyword">case</span> Leader:</span><br><span class="line">				<span class="comment">// 发送心跳</span></span><br><span class="line">				s.leaderJob()</span><br><span class="line">			<span class="keyword">case</span> Nobody:</span><br><span class="line">				<span class="comment">// 啥也不做，等待leader产生</span></span><br><span class="line">				time.Sleep(time.Second)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> leaderJob() (err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> _, addr := <span class="keyword">range</span> s.ClusterMember &#123;</span><br><span class="line">		req := HeartbeatReq&#123;</span><br><span class="line">			Addr:      s.Addr,</span><br><span class="line">			Heartbeat: time.Now().Unix(),</span><br><span class="line">			Term:      s.Term,</span><br><span class="line">			Offset:    s.Logger.Offset(),</span><br><span class="line">			Member:    s.ClusterMember,</span><br><span class="line">		&#125;</span><br><span class="line">		resp := HeartbeatReply&#123;&#125;</span><br><span class="line">		conn, err := net.DialTimeout(<span class="string">&quot;tcp&quot;</span>, addr, time.Second)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="comment">//有节点宕机了。先不管</span></span><br><span class="line">			log.Println(err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		client := rpc.NewClient(conn)</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(time.Second):</span><br><span class="line">			log.Printf(<span class="string">&quot;%s call timeout \n&quot;</span>, addr)</span><br><span class="line">			err = fmt.Errorf(<span class="string">&quot;call timeout&quot;</span>)</span><br><span class="line">		<span class="keyword">case</span> call := &lt;-client.Go(CommunicateHeartbeat, req, &amp;resp, <span class="literal">nil</span>).Done:</span><br><span class="line">			err = call.Error</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Println(err)</span><br><span class="line">			<span class="comment">// 不管。leader 只管发心跳</span></span><br><span class="line">			client.Close()</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> resp.Deviation == <span class="number">0</span> &#123; <span class="comment">// 日志没有偏差，继续发下一个节点</span></span><br><span class="line">			client.Close()</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		buff, err := s.Logger.ReadItem(resp.Deviation)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		logItemReq := LogItemReq&#123;Data: buff&#125;</span><br><span class="line">		logItemReply := LogItemReply&#123;&#125;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(time.Second):</span><br><span class="line">			log.Printf(<span class="string">&quot;%s call timeout \n&quot;</span>, addr)</span><br><span class="line">			err = fmt.Errorf(<span class="string">&quot;call timeout&quot;</span>)</span><br><span class="line">		<span class="keyword">case</span> call := &lt;-client.Go(CommunicateSyncLog, logItemReq, &amp;logItemReply, <span class="literal">nil</span>).Done:</span><br><span class="line">			err = call.Error</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Println(err)</span><br><span class="line">			<span class="comment">// 不管。// todo</span></span><br><span class="line">			client.Close()</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> logItemReply.IsSuccess &#123;</span><br><span class="line">			client.Close()</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//todo 日志同步失败处理</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> electionJob() (err <span class="type">error</span>) &#123;</span><br><span class="line">	log.Println(<span class="string">&quot;开始选举&quot;</span>)</span><br><span class="line">	s.VoteTerm = s.Term</span><br><span class="line">	count := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, addr := <span class="keyword">range</span> s.ClusterMember &#123;</span><br><span class="line">		req := ElectionReq&#123;</span><br><span class="line">			Addr:   s.Addr,</span><br><span class="line">			Term:   s.Term,</span><br><span class="line">			Offset: s.Logger.Offset(),</span><br><span class="line">		&#125;</span><br><span class="line">		resp := ElectionReply&#123;&#125;</span><br><span class="line">		client, err := rpc.Dial(<span class="string">&quot;tcp&quot;</span>, addr) <span class="comment">// todo timeout</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;                      <span class="comment">// 可能有宕机的，出错可以先不管，只考虑能收到的选票</span></span><br><span class="line">			log.Printf(<span class="string">&quot;%s unreachable \n&quot;</span>, addr)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// todo 超时</span></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">			log.Printf(<span class="string">&quot;%s call timeout \n&quot;</span>, addr)</span><br><span class="line">			err = fmt.Errorf(<span class="string">&quot;call timeout&quot;</span>)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		<span class="keyword">case</span> call := &lt;-client.Go(CommunicateElection, req, &amp;resp, <span class="literal">nil</span>).Done:</span><br><span class="line">			err = call.Error</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Println(err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> resp.IsVote &#123;</span><br><span class="line">			count++</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> resp.IsRejected &#123;</span><br><span class="line">			s.State = Nobody</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		client.Close()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> s.State == Nobody &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;日志落后，成为 nobody&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	log.Println(<span class="string">&quot;获得选票&quot;</span>, count)</span><br><span class="line">	<span class="keyword">if</span> count &gt; <span class="built_in">len</span>(s.ClusterMember)/<span class="number">2</span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;选举成功&quot;</span>)</span><br><span class="line">		s.State = Leader</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	log.Println(<span class="string">&quot;选举失败&quot;</span>) <span class="comment">// 选举失败的不要马上发起下一次选举</span></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> followerJob() (err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (s.Heartbeat + s.HeartbeatTimeout) &gt; time.Now().Unix() &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	log.Println(<span class="string">&quot;心跳超时&quot;</span>)</span><br><span class="line">	s.State = Candidate <span class="comment">// 转换角色</span></span><br><span class="line">	s.Term = s.Term + <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> RpcServer() (err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// rpc服务</span></span><br><span class="line">	api := <span class="built_in">new</span>(ServerApi)</span><br><span class="line">	api.server = s</span><br><span class="line">	s.Api = api</span><br><span class="line"></span><br><span class="line">	err = rpc.Register(api)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_, port, _ := net.SplitHostPort(s.Addr)</span><br><span class="line">	listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, fmt.Sprintf(<span class="string">&quot;:%s&quot;</span>, port))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	log.Println(<span class="string">&quot;listen on&quot;</span>, s.Addr)</span><br><span class="line">	s.Listener = listener</span><br><span class="line">	<span class="keyword">var</span> tempDelay time.Duration</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn, err := s.Listener.Accept()</span><br><span class="line">		<span class="comment">// 直接仿照 net/http 包的异常处理</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-s.context.Done():</span><br><span class="line">				<span class="comment">//log.Println(err)</span></span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> ne, ok := err.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class="line">				<span class="keyword">if</span> tempDelay == <span class="number">0</span> &#123;</span><br><span class="line">					tempDelay = <span class="number">5</span> * time.Millisecond</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					tempDelay *= <span class="number">2</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> max := <span class="number">1</span> * time.Second; tempDelay &gt; max &#123;</span><br><span class="line">					tempDelay = max</span><br><span class="line">				&#125;</span><br><span class="line">				time.Sleep(tempDelay)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//log.Println(err)</span></span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">go</span> s.serve(conn)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> serve(conn net.Conn) &#123;</span><br><span class="line">	s.Add(<span class="number">1</span>)</span><br><span class="line">	rpc.ServeConn(conn)</span><br><span class="line">	s.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> LogServer() (err <span class="type">error</span>) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查</span></span><br><span class="line">	<span class="comment">//_,err := os.Stat(s.LogFilePath)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 日志服务</span></span><br><span class="line">	f, err := os.OpenFile(s.LogFilePath, os.O_RDWR|os.O_CREATE|os.O_APPEND, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	serverLog := <span class="built_in">new</span>(ServerLog)</span><br><span class="line">	serverLog.server = s</span><br><span class="line">	s.Logger = serverLog</span><br><span class="line">	s.Logger.File = f</span><br><span class="line">	s.LogFile = f</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 每次重起要读log文件重放到 Data中</span></span><br><span class="line">	err = s.Logger.Replay(s.Data)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// todo</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// todo 不应该直接让server操作文件。应该加一个中间件。但是简单做直接写文件吧</span></span><br><span class="line">	<span class="comment">// 启动循环定期更新日志到磁盘中</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> Register() (err <span class="type">error</span>) &#123;</span><br><span class="line"></span><br><span class="line">	client, err := rpc.Dial(<span class="string">&quot;tcp&quot;</span>, s.Referrer)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> client.Close()</span><br><span class="line"></span><br><span class="line">	req := MemberReq&#123;Addr: s.Addr&#125;</span><br><span class="line">	reply := &amp;MemberReply&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">		err = fmt.Errorf(<span class="string">&quot;call timeout&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> call := &lt;-client.Go(CommunicateRegister, req, reply, <span class="literal">nil</span>).Done:</span><br><span class="line">		reply.Err = call.Error</span><br><span class="line">		err = call.Error</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;注册到集群失败&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> reply.IsSuccess &#123;</span><br><span class="line">		s.ClusterMember = reply.Member</span><br><span class="line">		log.Println(<span class="string">&quot;注册到集群成功&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// todo , 如果是leader节点退出要做特殊处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> Logout() (err <span class="type">error</span>) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> s.State == Leader &#123;</span><br><span class="line"></span><br><span class="line">		oldMember := s.ClusterMember</span><br><span class="line">		newMember := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(oldMember))</span><br><span class="line">		<span class="keyword">for</span> _, addr := <span class="keyword">range</span> oldMember &#123;</span><br><span class="line">			<span class="keyword">if</span> addr == s.Addr &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			newMember = <span class="built_in">append</span>(newMember, addr)</span><br><span class="line">		&#125;</span><br><span class="line">		s.ClusterMember = newMember</span><br><span class="line"></span><br><span class="line">		s.leaderJob() <span class="comment">// 最后把clusterMember同步给follower</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	client, err := rpc.Dial(<span class="string">&quot;tcp&quot;</span>, s.Leader)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> client.Close()</span><br><span class="line"></span><br><span class="line">	req := MemberReq&#123;Addr: s.Addr&#125;</span><br><span class="line">	reply := &amp;MemberReply&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">		err = fmt.Errorf(<span class="string">&quot;call timeout&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> call := &lt;-client.Go(CommunicateLogout, req, reply, <span class="literal">nil</span>).Done:</span><br><span class="line">		reply.Err = call.Error</span><br><span class="line">		err = call.Error</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;从集群注销失败&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> reply.IsSuccess &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;从集群注销成功&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">api</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> ServerApi <span class="keyword">struct</span> &#123;</span><br><span class="line">	server *Server</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">conmunicate</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> HeartbeatReq <span class="keyword">struct</span> &#123;</span><br><span class="line">	Addr      <span class="type">string</span></span><br><span class="line">	Heartbeat <span class="type">int64</span></span><br><span class="line">	Term      <span class="type">int64</span></span><br><span class="line"></span><br><span class="line">	Offset <span class="type">int64</span></span><br><span class="line"></span><br><span class="line">	Member []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> HeartbeatReply <span class="keyword">struct</span> &#123;</span><br><span class="line">	Deviation <span class="type">int64</span> <span class="comment">// 数据偏差</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ElectionReq <span class="keyword">struct</span> &#123;</span><br><span class="line">	Addr   <span class="type">string</span> <span class="comment">// 发起选举的候选人</span></span><br><span class="line">	Term   <span class="type">int64</span>  <span class="comment">// 任期</span></span><br><span class="line">	Offset <span class="type">int64</span>  <span class="comment">// 日志偏移量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ElectionReply <span class="keyword">struct</span> &#123;</span><br><span class="line">	IsRejected <span class="type">bool</span></span><br><span class="line">	IsVote     <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 心跳做三件事情</span></span><br><span class="line"><span class="comment">// 同步leader</span></span><br><span class="line"><span class="comment">// 同步日志</span></span><br><span class="line"><span class="comment">// 同步集群成员</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServerApi)</span></span> Heartbeat(req HeartbeatReq, reply *HeartbeatReply) (err <span class="type">error</span>) &#123;</span><br><span class="line"></span><br><span class="line">	log.Printf(<span class="string">&quot;[debug] %+v, %+v, %+v \n&quot;</span>, s.server.ClusterMember, s.server.State, s.server.Data)</span><br><span class="line">	<span class="keyword">if</span> req.Term &lt; s.server.Term &#123; <span class="comment">// 旧leader 发的，通知他转为follower，或者不管，这样旧leader会等到新leader给他发的心跳，自己转为follower</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// req.Term &gt;= s.server.Term</span></span><br><span class="line">	<span class="comment">// 设置心跳</span></span><br><span class="line">	s.server.Term = req.Term</span><br><span class="line">	s.server.Heartbeat = req.Heartbeat</span><br><span class="line">	s.server.Leader = req.Addr</span><br><span class="line">	<span class="comment">// 极端情况下，可能会有一个和leader 相同term的candidate</span></span><br><span class="line">	<span class="keyword">if</span> req.Addr != s.server.Addr &#123; <span class="comment">//一旦收到新的leader，leader以外的所有人都转为follower</span></span><br><span class="line">		s.server.State = Follower</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 新的leader已经产生，重制投票，为下次投票准备</span></span><br><span class="line">	s.server.VoteTo = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断log offset</span></span><br><span class="line">	<span class="keyword">if</span> s.server.State == Leader &#123; <span class="comment">// 如果自己是leader 就不用去同步log了</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//if req.Offset == s.server.Logger.Offset() &#123;</span></span><br><span class="line">	<span class="comment">//	return</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="keyword">if</span> req.Offset &gt; s.server.Logger.Offset() &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;发现日志偏移&quot;</span>)</span><br><span class="line">		reply.Deviation = s.server.Logger.Offset() - req.Offset</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 同步集群成员</span></span><br><span class="line">	<span class="comment">//if req.Member == nil || len(req.Member) == 0 || len(req.Member) == len(s.server.ClusterMember) &#123;</span></span><br><span class="line">	<span class="comment">//	return</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="keyword">if</span> req.Member != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(req.Member) &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(req.Member) != <span class="built_in">len</span>(s.server.ClusterMember) &#123;</span><br><span class="line">		s.server.ClusterMember = req.Member</span><br><span class="line">		log.Println(<span class="string">&quot;集群成员变更&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServerApi)</span></span> Election(req ElectionReq, reply *ElectionReply) (err <span class="type">error</span>) &#123;</span><br><span class="line"></span><br><span class="line">	log.Println(<span class="string">&quot;选举投票&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 先比较日志，是否比自己新或者等于自己</span></span><br><span class="line">	<span class="keyword">if</span> req.Offset &lt; s.server.Logger.Offset() &#123;</span><br><span class="line">		reply.IsRejected = <span class="literal">true</span>    <span class="comment">// 有这一票直接禁止选举</span></span><br><span class="line">		s.server.State = Candidate <span class="comment">// 自己的日志更新，自己来当候选人</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 再比较版本，是否大于等于自己投的那个版本</span></span><br><span class="line">	<span class="keyword">if</span> req.Term &lt; s.server.VoteTerm &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> req.Term &gt; s.server.VoteTerm &#123;</span><br><span class="line">		<span class="comment">// 任期更大，直接投给这个人，记录以下投给了谁</span></span><br><span class="line">		s.server.VoteTo = req.Addr</span><br><span class="line">		s.server.VoteTerm = req.Term</span><br><span class="line">		reply.IsVote = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// req.Term == s.server.VoteTerm</span></span><br><span class="line">	<span class="comment">// 再判断自己是否投票了</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s.server.VoteTo) == <span class="number">0</span> &#123; <span class="comment">//还没投给别人</span></span><br><span class="line">		s.server.VoteTo = req.Addr</span><br><span class="line">		s.server.VoteTerm = req.Term</span><br><span class="line">		reply.IsVote = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> s.server.VoteTo == req.Addr &#123; <span class="comment">// 之前投过的人，继续来找我们确认选票了</span></span><br><span class="line">		s.server.VoteTo = req.Addr</span><br><span class="line">		s.server.VoteTerm = req.Term</span><br><span class="line">		reply.IsVote = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LogItemReq <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data []<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> LogItemReply <span class="keyword">struct</span> &#123;</span><br><span class="line">	IsSuccess <span class="type">bool</span></span><br><span class="line">	Err       <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServerApi)</span></span> SyncLog(req LogItemReq, reply *LogItemReply) (err <span class="type">error</span>) &#123;</span><br><span class="line">	log.Println(<span class="string">&quot;同步日志&quot;</span>)</span><br><span class="line"></span><br><span class="line">	_, err = s.server.LogFile.Write(req.Data)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		reply.IsSuccess = <span class="literal">false</span></span><br><span class="line">		reply.Err = err</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	err = s.server.Logger.Load(s.server.Data, req.Data)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		reply.IsSuccess = <span class="literal">false</span></span><br><span class="line">		reply.Err = err</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	reply.IsSuccess = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">store</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> ItemReq <span class="keyword">struct</span> &#123;</span><br><span class="line">	Key   <span class="type">string</span></span><br><span class="line">	Val   <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	Level <span class="type">int</span> <span class="comment">// 同步级别  0-异步;1-半同步;2-同步</span></span><br><span class="line">	Node  <span class="type">int</span> <span class="comment">// 要同步的节点数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ItemReply <span class="keyword">struct</span> &#123;</span><br><span class="line">	IsSuccess <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">	Val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	Err <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServerApi)</span></span> Set(req ItemReq, reply *ItemReply) (err <span class="type">error</span>) &#123;</span><br><span class="line"></span><br><span class="line">	server := s.server</span><br><span class="line">	<span class="keyword">if</span> server.State != Leader &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;请求到了follower,代理写请求&quot;</span>)</span><br><span class="line">		<span class="comment">// todo 根据当前是否leader 进行转发处理，非leader不处理写请求，有两种处理方式，1.代转发和2.直接返回给client leader地址让client自己写</span></span><br><span class="line">		client, err := rpc.Dial(<span class="string">&quot;tcp&quot;</span>, server.Leader)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			reply.Err = err</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">			reply.Err = fmt.Errorf(<span class="string">&quot;call timeout&quot;</span>)</span><br><span class="line">			err = fmt.Errorf(<span class="string">&quot;call timeout&quot;</span>)</span><br><span class="line">		<span class="keyword">case</span> call := &lt;-client.Go(ApiSet, req, reply, <span class="literal">nil</span>).Done:</span><br><span class="line">			reply.Err = call.Error</span><br><span class="line">			err = call.Error</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			client.Close()</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		client.Close()</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// todo  根据 同步级别 和 指定同步节点个数 记录日志，这里简单做就先做 [半同步,1个节点] ps:详见blog</span></span><br><span class="line">	err = server.Logger.Record(req.Key, req.Val, <span class="string">&quot;U&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	reply.IsSuccess = <span class="literal">true</span></span><br><span class="line">	server.Lock()</span><br><span class="line">	<span class="keyword">defer</span> server.Unlock()</span><br><span class="line"></span><br><span class="line">	server.Data[req.Key] = req.Val</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServerApi)</span></span> Get(req ItemReq, reply *ItemReply) (err <span class="type">error</span>) &#123;</span><br><span class="line">	server := s.server</span><br><span class="line">	server.Lock()</span><br><span class="line">	<span class="keyword">defer</span> server.Unlock()</span><br><span class="line"></span><br><span class="line">	v, ok := server.Data[req.Key]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;not exist key&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	reply.IsSuccess = <span class="literal">true</span></span><br><span class="line">	reply.Val = v</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">log</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> ServerLog <span class="keyword">struct</span> &#123;</span><br><span class="line">	server *Server</span><br><span class="line">	File   *os.File</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServerLog)</span></span> Offset() <span class="type">int64</span> &#123;</span><br><span class="line">	ret, _ := s.File.Seek(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServerLog)</span></span> Sync() &#123;</span><br><span class="line">	s.File.Sync()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServerLog)</span></span> ReadItem(deviation <span class="type">int64</span>) (buff []<span class="type">byte</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	log.Println(<span class="string">&quot;读取同步日志&quot;</span>)</span><br><span class="line"></span><br><span class="line">	offset, err := s.File.Seek(deviation, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	buff = <span class="built_in">make</span>([]<span class="type">byte</span>, -deviation)</span><br><span class="line">	_, err = s.File.ReadAt(buff, offset)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServerLog)</span></span> Record(key <span class="type">string</span>, val <span class="keyword">interface</span>&#123;&#125;, action <span class="type">string</span>) (err <span class="type">error</span>) &#123;</span><br><span class="line">	log.Println(<span class="string">&quot;记录日志数据&quot;</span>)</span><br><span class="line"></span><br><span class="line">	_, err = s.File.Write([]<span class="type">byte</span>(action + <span class="string">&quot;:&quot;</span> + key + <span class="string">&quot;:&quot;</span> + val.(<span class="type">string</span>) + <span class="string">&quot;\n&quot;</span>))</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServerLog)</span></span> Replay(data <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;) (err <span class="type">error</span>) &#123;</span><br><span class="line"></span><br><span class="line">	log.Println(<span class="string">&quot;加载日志数据&quot;</span>)</span><br><span class="line"></span><br><span class="line">	size, err := s.File.Seek(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	buff := <span class="built_in">make</span>([]<span class="type">byte</span>, size)</span><br><span class="line">	_, err = s.File.ReadAt(buff, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	err = s.Load(data, buff)</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServerLog)</span></span> Load(data <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;, buff []<span class="type">byte</span>) (err <span class="type">error</span>) &#123;</span><br><span class="line">	str := <span class="type">string</span>(buff)</span><br><span class="line">	entrys := strings.Split(str, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">	s.server.Lock()</span><br><span class="line">	<span class="keyword">defer</span> s.server.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, entry := <span class="keyword">range</span> entrys &#123;</span><br><span class="line">		<span class="keyword">if</span> i == <span class="built_in">len</span>(entrys)<span class="number">-1</span> &#123; <span class="comment">// 最后一个是空的 因为每个项 是 xxx\n</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		e := strings.Split(entry, <span class="string">&quot;:&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(e) != <span class="number">3</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid log entry&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">switch</span> e[<span class="number">0</span>] &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;A&quot;</span>:</span><br><span class="line">			data[e[<span class="number">1</span>]] = e[<span class="number">2</span>]</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;U&quot;</span>:</span><br><span class="line">			data[e[<span class="number">1</span>]] = e[<span class="number">2</span>]</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;D&quot;</span>: <span class="comment">// todo</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServerLog)</span></span> Close() &#123;</span><br><span class="line">	s.File.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MemberReq <span class="keyword">struct</span> &#123;</span><br><span class="line">	Addr <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> MemberReply <span class="keyword">struct</span> &#123;</span><br><span class="line">	IsSuccess <span class="type">bool</span></span><br><span class="line">	Member    []<span class="type">string</span></span><br><span class="line">	Err       <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个接口负责把新节点的信息同步到leader手中。leader再负责心跳把全局的member同步给follower</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServerApi)</span></span> Register(req MemberReq, reply *MemberReply) (err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(req.Addr) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> s.server.State != Leader &#123; <span class="comment">// 不是leader代转发</span></span><br><span class="line"></span><br><span class="line">		log.Println(<span class="string">&quot;请求到了follower,代理写注册&quot;</span>)</span><br><span class="line"></span><br><span class="line">		client, err := rpc.Dial(<span class="string">&quot;tcp&quot;</span>, s.server.Leader)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			reply.Err = err</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">			reply.Err = fmt.Errorf(<span class="string">&quot;call timeout&quot;</span>)</span><br><span class="line">			err = fmt.Errorf(<span class="string">&quot;call timeout&quot;</span>)</span><br><span class="line">		<span class="keyword">case</span> call := &lt;-client.Go(CommunicateRegister, req, reply, <span class="literal">nil</span>).Done:</span><br><span class="line">			reply.Err = call.Error</span><br><span class="line">			err = call.Error</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			client.Close()</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		client.Close()</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 单节点变更，不会有其他人写ClusterMember，所以不需要加锁</span></span><br><span class="line">	s.server.ClusterMember = <span class="built_in">append</span>(s.server.ClusterMember, req.Addr)</span><br><span class="line">	reply.Member = s.server.ClusterMember</span><br><span class="line">	reply.IsSuccess = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServerApi)</span></span> Logout(req MemberReq, reply *MemberReply) (err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(req.Addr) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 单节点变更，不会有其他人写ClusterMember，所以不需要加锁</span></span><br><span class="line">	oldMember := s.server.ClusterMember</span><br><span class="line">	newMember := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(oldMember))</span><br><span class="line">	<span class="keyword">for</span> _, addr := <span class="keyword">range</span> oldMember &#123;</span><br><span class="line">		<span class="keyword">if</span> addr == req.Addr &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		newMember = <span class="built_in">append</span>(newMember, addr)</span><br><span class="line">	&#125;</span><br><span class="line">	s.server.ClusterMember = newMember</span><br><span class="line">	reply.IsSuccess = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>















<h1 id="Gossip协议"><a href="#Gossip协议" class="headerlink" title="Gossip协议"></a>Gossip协议</h1><h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><p>直接邮寄(Direct Mail)：直接发送更新数据，当数据发送失败时，将数据缓存下来，然后重传。</p>
<p>反熵(Anti-entropy)：集群中的节点，每隔段时间就随机选择某个其他节点，然后通过互相交换自己的所有数据来消除两者之间的差异，实现数据的最终一致性。</p>
<p>谣言传播(Rumor mongering)：当一个节点有了新数据后，这个节点变成活跃状态，并周期性地联系其他节点向其发送新数据，直到所有的节点都存储了该新数据</p>
<p>反墒的实现可以有三种：推，拉，推拉。</p>
<p>因为反墒通讯成本会很高。所以一般是先进行校验和对比，不符才进行反墒。</p>
<p>gossip 适合在节点不多，节点动态变化的分布式系统。</p>
<p>如何实现最终一致性呢？反熵</p>
<h2 id="共识协商过程-2"><a href="#共识协商过程-2" class="headerlink" title="共识协商过程"></a>共识协商过程</h2><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><img src="/2022/11/27/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE/gossip-1.drawio.png" class="">



<h3 id="加入节点"><a href="#加入节点" class="headerlink" title="加入节点"></a>加入节点</h3><img src="/2022/11/27/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE/gossip-2.drawio.png" class="">



<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>gossip中，遇到数据冲突，以谁为准呢?</p>
<ul>
<li>可以在client 写时带上时间戳，这样只有同一个client才保证顺序，不同client上的写不能保证顺序性。</li>
<li>参考git，给key设置一个版本号。</li>
<li>参考redis 集群的 epoch和failover 做法</li>
</ul>
<p>如何选择路径来给其他主机发送广播内容时避免重复发送形成广播风暴？</p>
<ul>
<li>源头节点广播（源头负责广播给所有人）</li>
<li>图广播（维护一个图，源头开始进行图广度优先遍历；）</li>
</ul>
<p>在图广播中，如果有一个节点a关联节点b，节点b只有节点a关联上，万一a挂了，b怎么办？</p>
<h2 id="设计-1"><a href="#设计-1" class="headerlink" title="设计"></a>设计</h2><p>1.提供api给gossip传播，更新，新节点</p>
<p>2.自身定期反熵</p>
<p>3.提供服务接口</p>
<p>注意问题：</p>
<p>数据冲突——时间戳</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/md5&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/hex&quot;</span></span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;os/signal&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;syscall&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Rumor1 = <span class="string">&quot;Api.Rumor1&quot;</span></span><br><span class="line">	Rumor2 = <span class="string">&quot;Api.Rumor2&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Node *ServerNode</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> addr <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.StringVar(&amp;addr, <span class="string">&quot;addr&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>, <span class="string">&quot;addr &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	flag.Parse()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//////  临时配置</span></span><br><span class="line">	<span class="keyword">var</span> ClusterMember = []<span class="type">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;localhost:9090&quot;</span>,</span><br><span class="line">		<span class="string">&quot;localhost:9091&quot;</span>,</span><br><span class="line">		<span class="string">&quot;localhost:9092&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/////  初始化</span></span><br><span class="line">	Node = <span class="built_in">new</span>(ServerNode)</span><br><span class="line">	Node.ClusterMember = ClusterMember</span><br><span class="line">	Node.context, Node.cancel = context.WithCancel(context.TODO())</span><br><span class="line">	Node.Data = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]Obj, <span class="number">16</span>)</span><br><span class="line">	Node.Addr = addr</span><br><span class="line"></span><br><span class="line">	<span class="comment">/////  启动服务</span></span><br><span class="line">	Node.Start()</span><br><span class="line">	log.Println(<span class="string">&quot;启动服务&quot;</span>)</span><br><span class="line"></span><br><span class="line">	sig := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">	signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">	&lt;-sig</span><br><span class="line"></span><br><span class="line">	Node.Stop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Obj <span class="keyword">struct</span> &#123;</span><br><span class="line">	Key     <span class="type">string</span></span><br><span class="line">	Value   <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	Version <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Obj)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> o.Value.(<span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ServerNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	Addr          <span class="type">string</span></span><br><span class="line">	ClusterMember []<span class="type">string</span></span><br><span class="line"></span><br><span class="line">	Data <span class="keyword">map</span>[<span class="type">string</span>]Obj</span><br><span class="line"></span><br><span class="line">	Listener net.Listener</span><br><span class="line"></span><br><span class="line">	context context.Context</span><br><span class="line">	cancel  context.CancelFunc</span><br><span class="line"></span><br><span class="line">	sync.WaitGroup</span><br><span class="line">	sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Checksum</span><span class="params">(arr []<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	md5Ctx := md5.New()</span><br><span class="line">	sort.Strings(arr)</span><br><span class="line">	<span class="keyword">for</span> _, s := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		md5Ctx.Write([]<span class="type">byte</span>(s))</span><br><span class="line">	&#125;</span><br><span class="line">	cipherStr := md5Ctx.Sum(<span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">return</span> hex.EncodeToString(cipherStr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServerNode)</span></span> AntiEntropy() &#123;</span><br><span class="line"></span><br><span class="line">	arr := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(s.Data))</span><br><span class="line">	s.Lock()</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> s.Data &#123;</span><br><span class="line">		arr = <span class="built_in">append</span>(arr, k+v.String())</span><br><span class="line">	&#125;</span><br><span class="line">	s.Unlock()</span><br><span class="line">	checksum := Checksum(arr)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历自己要Rumor传播的节点（目前先源节点传播。传给所有节点）</span></span><br><span class="line">	<span class="keyword">for</span> _, addr := <span class="keyword">range</span> s.ClusterMember &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> addr == s.Addr &#123; <span class="comment">// 不用发给自己</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		client, err := rpc.Dial(<span class="string">&quot;tcp&quot;</span>, addr) <span class="comment">// todo timeout</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;                      <span class="comment">// 可能有宕机的</span></span><br><span class="line">			log.Printf(<span class="string">&quot;%s unreachable \n&quot;</span>, addr)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		req := RumorReq&#123;</span><br><span class="line">			<span class="comment">//Addr:    s.Addr,</span></span><br><span class="line">			Checksum: checksum,</span><br><span class="line">		&#125;</span><br><span class="line">		resp := RumorReply&#123;&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">			err = fmt.Errorf(<span class="string">&quot;timeout&quot;</span>)</span><br><span class="line">			client.Close()</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		<span class="keyword">case</span> call := &lt;-client.Go(Rumor1, req, &amp;resp, <span class="literal">nil</span>).Done:</span><br><span class="line">			err = call.Error</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			client.Close()</span><br><span class="line">			log.Println(err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> !resp.IsChanged &#123;</span><br><span class="line">			<span class="comment">//log.Println(&quot;反熵：无变化&quot;)</span></span><br><span class="line">			client.Close()</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 改变了，需要同步</span></span><br><span class="line">		req.Data = s.Data</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">			err = fmt.Errorf(<span class="string">&quot;timeout&quot;</span>)</span><br><span class="line">			client.Close()</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		<span class="keyword">case</span> call := &lt;-client.Go(Rumor2, req, &amp;resp, <span class="literal">nil</span>).Done:</span><br><span class="line">			err = call.Error</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			client.Close()</span><br><span class="line">			log.Println(err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		log.Printf(<span class="string">&quot;反熵 更新:%+v\n&quot;</span>, resp)</span><br><span class="line">		s.Data = resp.Data</span><br><span class="line">		client.Close()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServerNode)</span></span> Start() &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// rpc 接口</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;启动 rpc 服务&quot;</span>)</span><br><span class="line">		s.Add(<span class="number">1</span>)</span><br><span class="line">		s.Worker1()</span><br><span class="line">		s.Done()</span><br><span class="line">		log.Println(<span class="string">&quot;关闭 rpc 服务&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 定期反熵</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;启动 反熵 服务&quot;</span>)</span><br><span class="line">		s.Add(<span class="number">1</span>)</span><br><span class="line">		s.Worker2()</span><br><span class="line">		s.Done()</span><br><span class="line">		log.Println(<span class="string">&quot;关闭 反熵 服务&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServerNode)</span></span> Stop() &#123;</span><br><span class="line"></span><br><span class="line">	log.Println(<span class="string">&quot;退出&quot;</span>)</span><br><span class="line">	s.cancel()</span><br><span class="line"></span><br><span class="line">	s.Listener.Close()</span><br><span class="line"></span><br><span class="line">	s.Wait()</span><br><span class="line">	log.Println(<span class="string">&quot;安全退出&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServerNode)</span></span> Worker2() &#123;</span><br><span class="line"></span><br><span class="line">	ticker := time.NewTicker(<span class="number">3</span> * time.Second)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-s.context.Done():</span><br><span class="line">			<span class="comment">// 关闭下游</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">			<span class="comment">//log.Println(&quot;反熵开始&quot;)</span></span><br><span class="line">			<span class="comment">//fmt.Printf(&quot;debug %+v\n&quot;, Node.Data[&quot;key-1&quot;])</span></span><br><span class="line">			s.AntiEntropy()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServerNode)</span></span> Worker1() <span class="type">error</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/////  通信角色</span></span><br><span class="line">	c := <span class="built_in">new</span>(Api)</span><br><span class="line">	err := rpc.Register(c)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_, port, _ := net.SplitHostPort(s.Addr)</span><br><span class="line">	listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, fmt.Sprintf(<span class="string">&quot;:%s&quot;</span>, port))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;ListenTCP error:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	s.Listener = listener</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> tempDelay time.Duration</span><br><span class="line"></span><br><span class="line">	log.Println(<span class="string">&quot;启动 rpc服务 监听 端口 &quot;</span>, s.Addr)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn, err := s.Listener.Accept()</span><br><span class="line">		<span class="comment">// 直接仿照 net/http 包的异常处理</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-s.context.Done():</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> ne, ok := err.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class="line">				<span class="keyword">if</span> tempDelay == <span class="number">0</span> &#123;</span><br><span class="line">					tempDelay = <span class="number">5</span> * time.Millisecond</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					tempDelay *= <span class="number">2</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> max := <span class="number">1</span> * time.Second; tempDelay &gt; max &#123;</span><br><span class="line">					tempDelay = max</span><br><span class="line">				&#125;</span><br><span class="line">				time.Sleep(tempDelay)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">go</span> s.serve(conn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServerNode)</span></span> serve(conn net.Conn) &#123;</span><br><span class="line">	s.Add(<span class="number">1</span>)</span><br><span class="line">	rpc.ServeConn(conn)</span><br><span class="line">	s.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Api <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RumorReq <span class="keyword">struct</span> &#123;</span><br><span class="line">	Checksum <span class="type">string</span></span><br><span class="line">	Data     <span class="keyword">map</span>[<span class="type">string</span>]Obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> RumorReply <span class="keyword">struct</span> &#123;</span><br><span class="line">	IsChanged <span class="type">bool</span></span><br><span class="line">	Data      <span class="keyword">map</span>[<span class="type">string</span>]Obj <span class="comment">// todo 改成需要处理的行为，减少通讯成本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Api)</span></span> Rumor1(req RumorReq, reply *RumorReply) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// 检查 校验和 (Checksum)等机制</span></span><br><span class="line">	checksumR := req.Checksum</span><br><span class="line"></span><br><span class="line">	arr2 := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(Node.Data))</span><br><span class="line">	Node.Lock()</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> Node.Data &#123;</span><br><span class="line">		arr2 = <span class="built_in">append</span>(arr2, k+v.String())</span><br><span class="line">	&#125;</span><br><span class="line">	Node.Unlock()</span><br><span class="line">	checksumN := Checksum(arr2)</span><br><span class="line">	<span class="keyword">if</span> checksumN != checksumR &#123;</span><br><span class="line">		reply.IsChanged = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Api)</span></span> Rumor2(req RumorReq, reply *RumorReply) <span class="type">error</span> &#123;</span><br><span class="line">	Node.Lock()</span><br><span class="line">	<span class="keyword">defer</span> Node.Unlock()</span><br><span class="line">	<span class="comment">// 同步req中的数据和本服务中的数据</span></span><br><span class="line">	<span class="keyword">for</span> k, rv := <span class="keyword">range</span> req.Data &#123;</span><br><span class="line">		nv, ok := Node.Data[k]</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			Node.Data[k] = rv</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> rv.Version &gt; nv.Version &#123;</span><br><span class="line">			Node.Data[k] = rv</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			Node.Data[k] = nv</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	reply.Data = Node.Data</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步 set</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Api)</span></span> Set(req Obj, reply *Obj) <span class="type">error</span> &#123;</span><br><span class="line">	Node.Lock()</span><br><span class="line">	<span class="keyword">defer</span> Node.Unlock()</span><br><span class="line">	Node.Data[req.Key] = Obj&#123;Value: req.Value, Version: time.Now().UnixNano()&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Api)</span></span> Get(req Obj, reply *Obj) <span class="type">error</span> &#123;</span><br><span class="line">	Node.Lock()</span><br><span class="line">	<span class="keyword">defer</span> Node.Unlock()</span><br><span class="line">	obj, ok := Node.Data[req.Key]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	reply.Key = obj.Key</span><br><span class="line">	reply.Value = obj.Value</span><br><span class="line">	reply.Version = obj.Version</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	func (c *Api) Del() error &#123;</span></span><br><span class="line"><span class="comment">//		return nil</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Api)</span></span> NewMember() <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// todo</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>















<h1 id="Quorum-NWR"><a href="#Quorum-NWR" class="headerlink" title="Quorum NWR"></a>Quorum NWR</h1><p>扩展功能，在分布式集群环境中，为了性能和吞吐量，集群基于BASE理论不可能真正做到强一致性，都是实现的最终一致性。但是有时需要有个操作能获取实时数据，这个操作可能不是那么频繁，那就可以使用这个 NWR，这个做法缺陷是性能不高，但是确实可以实现一致性。</p>
<h2 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h2><p>最终一致性：最终一致性只能保证如果对某个对象没有新的写操作了，最终所有后续访问都能读到相同的最近更新的值。</p>
<p>强一致性：强一致性能保证写操作完成后，任何后续访问都能读到更新后的值</p>
<p>N-复制因子：N 表示集群中同一份 数据有多少个副本。</p>
<p>W-写一致性级别(Write Consistency Level)，表示成功完成 W 个副本更新，才完 成写操作</p>
<p>R-读一致性级别(Read Consistency Level)，表示读取一个数据对象时需要读 R 个副本，然后返回 R 个副本中最新的那份数据:</p>
<h2 id="共识协商过程-3"><a href="#共识协商过程-3" class="headerlink" title="共识协商过程"></a>共识协商过程</h2><p>写入的时候，设置W&gt;1&#x2F;2N,要求写入超过一半节点成功才算成功写入</p>
<p>读取的时候，设置R&gt;1&#x2F;2N,要起读取超过一半节点成功，然后在这1&#x2F;2N个节点中取最新的数据。</p>
<p>因为写入的时候是大于一半的节点，读取的时候大于一半的节点，所以读取必然会读取到至少一个是最新的节点。</p>
<img src="/2022/11/27/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE/quorumNWR-1.drawio.png" class="">



<h2 id="设计-2"><a href="#设计-2" class="headerlink" title="设计"></a>设计</h2><p>Quorum NWR并非一个单独的协议，而是在其他共识算法上读写数据的一个扩展，所以我们这里直接使用在gossip基础上添加这个QuorumNWR的读写。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/md5&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/hex&quot;</span></span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;os/signal&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;syscall&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Rumor1 = <span class="string">&quot;Api.Rumor1&quot;</span></span><br><span class="line">	Rumor2 = <span class="string">&quot;Api.Rumor2&quot;</span></span><br><span class="line"></span><br><span class="line">	Set = <span class="string">&quot;Api.Set&quot;</span></span><br><span class="line">	Get = <span class="string">&quot;Api.Get&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Node *ServerNode</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> addr <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.StringVar(&amp;addr, <span class="string">&quot;addr&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>, <span class="string">&quot;addr &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	flag.Parse()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//////  临时配置</span></span><br><span class="line">	<span class="keyword">var</span> ClusterMember = []<span class="type">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;localhost:9090&quot;</span>,</span><br><span class="line">		<span class="string">&quot;localhost:9091&quot;</span>,</span><br><span class="line">		<span class="string">&quot;localhost:9092&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/////  初始化</span></span><br><span class="line">	Node = <span class="built_in">new</span>(ServerNode)</span><br><span class="line">	Node.ClusterMember = ClusterMember</span><br><span class="line">	Node.context, Node.cancel = context.WithCancel(context.TODO())</span><br><span class="line">	Node.Data = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]Obj, <span class="number">16</span>)</span><br><span class="line">	Node.Addr = addr</span><br><span class="line"></span><br><span class="line">	<span class="comment">/////  启动服务</span></span><br><span class="line">	Node.Start()</span><br><span class="line">	log.Println(<span class="string">&quot;启动服务&quot;</span>)</span><br><span class="line"></span><br><span class="line">	sig := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">	signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">	&lt;-sig</span><br><span class="line"></span><br><span class="line">	Node.Stop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Obj <span class="keyword">struct</span> &#123;</span><br><span class="line">	Key     <span class="type">string</span></span><br><span class="line">	Value   <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	Version <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Obj)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> o.Value.(<span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ServerNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	Addr          <span class="type">string</span></span><br><span class="line">	ClusterMember []<span class="type">string</span></span><br><span class="line"></span><br><span class="line">	Data <span class="keyword">map</span>[<span class="type">string</span>]Obj</span><br><span class="line"></span><br><span class="line">	Listener net.Listener</span><br><span class="line"></span><br><span class="line">	context context.Context</span><br><span class="line">	cancel  context.CancelFunc</span><br><span class="line"></span><br><span class="line">	sync.WaitGroup</span><br><span class="line">	sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Checksum</span><span class="params">(arr []<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	md5Ctx := md5.New()</span><br><span class="line">	sort.Strings(arr)</span><br><span class="line">	<span class="keyword">for</span> _, s := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		md5Ctx.Write([]<span class="type">byte</span>(s))</span><br><span class="line">	&#125;</span><br><span class="line">	cipherStr := md5Ctx.Sum(<span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">return</span> hex.EncodeToString(cipherStr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServerNode)</span></span> AntiEntropy() &#123;</span><br><span class="line"></span><br><span class="line">	arr := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(s.Data))</span><br><span class="line">	s.Lock()</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> s.Data &#123;</span><br><span class="line">		arr = <span class="built_in">append</span>(arr, k+v.String())</span><br><span class="line">	&#125;</span><br><span class="line">	s.Unlock()</span><br><span class="line">	checksum := Checksum(arr)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历自己要Rumor传播的节点（目前先源节点传播。传给所有节点）</span></span><br><span class="line">	<span class="keyword">for</span> _, addr := <span class="keyword">range</span> s.ClusterMember &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> addr == s.Addr &#123; <span class="comment">// 不用发给自己</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		client, err := rpc.Dial(<span class="string">&quot;tcp&quot;</span>, addr) <span class="comment">// todo timeout</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;                      <span class="comment">// 可能有宕机的</span></span><br><span class="line">			log.Printf(<span class="string">&quot;%s unreachable \n&quot;</span>, addr)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		req := RumorReq&#123;</span><br><span class="line">			<span class="comment">//Addr:    s.Addr,</span></span><br><span class="line">			Checksum: checksum,</span><br><span class="line">		&#125;</span><br><span class="line">		resp := RumorReply&#123;&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">			err = fmt.Errorf(<span class="string">&quot;timeout&quot;</span>)</span><br><span class="line">			client.Close()</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		<span class="keyword">case</span> call := &lt;-client.Go(Rumor1, req, &amp;resp, <span class="literal">nil</span>).Done:</span><br><span class="line">			err = call.Error</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			client.Close()</span><br><span class="line">			log.Println(err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> !resp.IsChanged &#123;</span><br><span class="line">			<span class="comment">//log.Println(&quot;反熵：无变化&quot;)</span></span><br><span class="line">			client.Close()</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 改变了，需要同步</span></span><br><span class="line">		req.Data = s.Data</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">			err = fmt.Errorf(<span class="string">&quot;timeout&quot;</span>)</span><br><span class="line">			client.Close()</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		<span class="keyword">case</span> call := &lt;-client.Go(Rumor2, req, &amp;resp, <span class="literal">nil</span>).Done:</span><br><span class="line">			err = call.Error</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			client.Close()</span><br><span class="line">			log.Println(err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		log.Printf(<span class="string">&quot;反熵 更新:%+v\n&quot;</span>, resp)</span><br><span class="line">		s.Data = resp.Data</span><br><span class="line">		client.Close()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServerNode)</span></span> Start() &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// rpc 接口</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;启动 rpc 服务&quot;</span>)</span><br><span class="line">		s.Add(<span class="number">1</span>)</span><br><span class="line">		s.Worker1()</span><br><span class="line">		s.Done()</span><br><span class="line">		log.Println(<span class="string">&quot;关闭 rpc 服务&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 定期反熵</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;启动 反熵 服务&quot;</span>)</span><br><span class="line">		s.Add(<span class="number">1</span>)</span><br><span class="line">		s.Worker2()</span><br><span class="line">		s.Done()</span><br><span class="line">		log.Println(<span class="string">&quot;关闭 反熵 服务&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServerNode)</span></span> Stop() &#123;</span><br><span class="line"></span><br><span class="line">	log.Println(<span class="string">&quot;退出&quot;</span>)</span><br><span class="line">	s.cancel()</span><br><span class="line"></span><br><span class="line">	s.Listener.Close()</span><br><span class="line"></span><br><span class="line">	s.Wait()</span><br><span class="line">	log.Println(<span class="string">&quot;安全退出&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServerNode)</span></span> Worker2() &#123;</span><br><span class="line"></span><br><span class="line">	ticker := time.NewTicker(<span class="number">3</span> * time.Second)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-s.context.Done():</span><br><span class="line">			<span class="comment">// 关闭下游</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">			<span class="comment">//log.Println(&quot;反熵开始&quot;)</span></span><br><span class="line">			fmt.Printf(<span class="string">&quot;debug %+v\n&quot;</span>, Node.Data)</span><br><span class="line">			<span class="comment">//s.AntiEntropy() // 测试quorumNWR,禁止反熵,节点之间不同步数据,观察GetquorumR情况</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServerNode)</span></span> Worker1() <span class="type">error</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/////  通信角色</span></span><br><span class="line">	c := <span class="built_in">new</span>(Api)</span><br><span class="line">	err := rpc.Register(c)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_, port, _ := net.SplitHostPort(s.Addr)</span><br><span class="line">	listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, fmt.Sprintf(<span class="string">&quot;:%s&quot;</span>, port))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;ListenTCP error:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	s.Listener = listener</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> tempDelay time.Duration</span><br><span class="line"></span><br><span class="line">	log.Println(<span class="string">&quot;启动 rpc服务 监听 端口 &quot;</span>, s.Addr)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn, err := s.Listener.Accept()</span><br><span class="line">		<span class="comment">// 直接仿照 net/http 包的异常处理</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-s.context.Done():</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> ne, ok := err.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class="line">				<span class="keyword">if</span> tempDelay == <span class="number">0</span> &#123;</span><br><span class="line">					tempDelay = <span class="number">5</span> * time.Millisecond</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					tempDelay *= <span class="number">2</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> max := <span class="number">1</span> * time.Second; tempDelay &gt; max &#123;</span><br><span class="line">					tempDelay = max</span><br><span class="line">				&#125;</span><br><span class="line">				time.Sleep(tempDelay)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">go</span> s.serve(conn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ServerNode)</span></span> serve(conn net.Conn) &#123;</span><br><span class="line">	s.Add(<span class="number">1</span>)</span><br><span class="line">	rpc.ServeConn(conn)</span><br><span class="line">	s.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Api <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RumorReq <span class="keyword">struct</span> &#123;</span><br><span class="line">	Checksum <span class="type">string</span></span><br><span class="line">	Data     <span class="keyword">map</span>[<span class="type">string</span>]Obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> RumorReply <span class="keyword">struct</span> &#123;</span><br><span class="line">	IsChanged <span class="type">bool</span></span><br><span class="line">	Data      <span class="keyword">map</span>[<span class="type">string</span>]Obj <span class="comment">// todo 改成需要处理的行为，减少通讯成本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Api)</span></span> Rumor1(req RumorReq, reply *RumorReply) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// 检查 校验和 (Checksum)等机制</span></span><br><span class="line">	checksumR := req.Checksum</span><br><span class="line"></span><br><span class="line">	arr2 := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(Node.Data))</span><br><span class="line">	Node.Lock()</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> Node.Data &#123;</span><br><span class="line">		arr2 = <span class="built_in">append</span>(arr2, k+v.String())</span><br><span class="line">	&#125;</span><br><span class="line">	Node.Unlock()</span><br><span class="line">	checksumN := Checksum(arr2)</span><br><span class="line">	<span class="keyword">if</span> checksumN != checksumR &#123;</span><br><span class="line">		reply.IsChanged = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Api)</span></span> Rumor2(req RumorReq, reply *RumorReply) <span class="type">error</span> &#123;</span><br><span class="line">	log.Println(<span class="string">&quot;Rumor2&quot;</span>)</span><br><span class="line">	Node.Lock()</span><br><span class="line">	<span class="keyword">defer</span> Node.Unlock()</span><br><span class="line">	<span class="comment">// 同步req中的数据和本服务中的数据</span></span><br><span class="line">	<span class="keyword">for</span> k, rv := <span class="keyword">range</span> req.Data &#123;</span><br><span class="line">		nv, ok := Node.Data[k]</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			Node.Data[k] = rv</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> rv.Version &gt; nv.Version &#123;</span><br><span class="line">			Node.Data[k] = rv</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			Node.Data[k] = nv</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	reply.Data = Node.Data</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步 set</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Api)</span></span> Set(req Obj, reply *Obj) <span class="type">error</span> &#123;</span><br><span class="line">	Node.Lock()</span><br><span class="line">	<span class="keyword">defer</span> Node.Unlock()</span><br><span class="line">	Node.Data[req.Key] = Obj&#123;Value: req.Value, Version: time.Now().UnixNano()&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Api)</span></span> Get(req Obj, reply *Obj) <span class="type">error</span> &#123;</span><br><span class="line">	Node.Lock()</span><br><span class="line">	<span class="keyword">defer</span> Node.Unlock()</span><br><span class="line">	obj, ok := Node.Data[req.Key]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	reply.Key = obj.Key</span><br><span class="line">	reply.Value = obj.Value</span><br><span class="line">	reply.Version = obj.Version</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	func (c *Api) Del() error &#123;</span></span><br><span class="line"><span class="comment">//		return nil</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Api)</span></span> NewMember() <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// todo</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> QuorumReply <span class="keyword">struct</span> &#123;</span><br><span class="line">	Obj</span><br><span class="line">	IsSuccess <span class="type">bool</span></span><br><span class="line">	Err       <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Api)</span></span> SetQuorumW(req Obj, reply *QuorumReply) <span class="type">error</span> &#123;</span><br><span class="line">	Node.Lock()</span><br><span class="line">	<span class="keyword">defer</span> Node.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// todo 校验</span></span><br><span class="line"></span><br><span class="line">	nodeNum := <span class="built_in">len</span>(Node.ClusterMember)</span><br><span class="line">	req.Version = time.Now().UnixNano()</span><br><span class="line">	successNum := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, addr := <span class="keyword">range</span> Node.ClusterMember &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> addr == Node.Addr &#123; <span class="comment">// 不用发给自己</span></span><br><span class="line">			successNum++</span><br><span class="line">			Node.Data[req.Key] = req</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		client, err := rpc.Dial(<span class="string">&quot;tcp&quot;</span>, addr) <span class="comment">// todo timeout</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;                      <span class="comment">// 可能有宕机的</span></span><br><span class="line">			log.Printf(<span class="string">&quot;%s unreachable \n&quot;</span>, addr)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		resp := Obj&#123;&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">			err = fmt.Errorf(<span class="string">&quot;timeout&quot;</span>)</span><br><span class="line">			client.Close()</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		<span class="keyword">case</span> call := &lt;-client.Go(<span class="string">&quot;Api.SetForQuorum&quot;</span>, req, &amp;resp, <span class="literal">nil</span>).Done:</span><br><span class="line">			err = call.Error</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			client.Close()</span><br><span class="line">			log.Println(err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		successNum++</span><br><span class="line">		<span class="keyword">if</span> successNum &gt; nodeNum/<span class="number">2</span> &#123;</span><br><span class="line">			log.Println(<span class="string">&quot;设置成功&quot;</span>, successNum)</span><br><span class="line">			client.Close()</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		client.Close()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> successNum &gt; nodeNum/<span class="number">2</span> &#123;</span><br><span class="line">		reply.IsSuccess = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Api)</span></span> GetQuorumR(req Obj, reply *QuorumReply) <span class="type">error</span> &#123;</span><br><span class="line">	Node.Lock()</span><br><span class="line">	<span class="keyword">defer</span> Node.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//todo 校验</span></span><br><span class="line"></span><br><span class="line">	nodeNum := <span class="built_in">len</span>(Node.ClusterMember)</span><br><span class="line">	req.Version = time.Now().UnixNano()</span><br><span class="line">	successObj := <span class="built_in">make</span>([]*Obj, <span class="number">0</span>, nodeNum)</span><br><span class="line">	successNum := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, addr := <span class="keyword">range</span> Node.ClusterMember &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> addr == Node.Addr &#123;</span><br><span class="line">			obj, _ := Node.Data[req.Key]</span><br><span class="line"></span><br><span class="line">			successNum++</span><br><span class="line">			successObj = <span class="built_in">append</span>(successObj, &amp;obj)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		client, err := rpc.Dial(<span class="string">&quot;tcp&quot;</span>, addr) <span class="comment">// todo timeout</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;                      <span class="comment">// 可能有宕机的</span></span><br><span class="line">			log.Printf(<span class="string">&quot;%s unreachable \n&quot;</span>, addr)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		resp := Obj&#123;&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">			err = fmt.Errorf(<span class="string">&quot;timeout&quot;</span>)</span><br><span class="line">			client.Close()</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		<span class="keyword">case</span> call := &lt;-client.Go(Get, req, &amp;resp, <span class="literal">nil</span>).Done:</span><br><span class="line">			err = call.Error</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			client.Close()</span><br><span class="line">			log.Println(err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		successNum++</span><br><span class="line">		successObj = <span class="built_in">append</span>(successObj, &amp;resp)</span><br><span class="line">		<span class="keyword">if</span> successNum &gt; nodeNum/<span class="number">2</span> &#123;</span><br><span class="line">			client.Close()</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		client.Close()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> successNum &gt; nodeNum/<span class="number">2</span> &#123;</span><br><span class="line">		reply.IsSuccess = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">		target := &amp;Obj&#123;&#125;</span><br><span class="line">		<span class="keyword">for</span> _, o := <span class="keyword">range</span> successObj &#123;</span><br><span class="line">			<span class="keyword">if</span> o == <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> o.Version &gt; target.Version &#123;</span><br><span class="line">				target = o</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		reply.Key = target.Key</span><br><span class="line">		reply.Value = target.Value</span><br><span class="line">		reply.Version = target.Version</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于测试quorum，使用quorum发来的版本号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Api)</span></span> SetForQuorum(req Obj, reply *Obj) <span class="type">error</span> &#123;</span><br><span class="line">	Node.Lock()</span><br><span class="line">	<span class="keyword">defer</span> Node.Unlock()</span><br><span class="line">	Node.Data[req.Key] = Obj&#123;Value: req.Value, Version: req.Version&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="一致性哈希算法（Consistent-Hashing）"><a href="#一致性哈希算法（Consistent-Hashing）" class="headerlink" title="一致性哈希算法（Consistent Hashing）"></a>一致性哈希算法（Consistent Hashing）</h1><h2 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h2><p>分片partition：</p>
<p>分片思想，例如访问一个map，对这个map读写每次都需要等待锁，而每个线程读写的key不一样，这样我们可以参考malloc内存分配的思想，将数据进行分片，这样可以保证在各个线程访问不同的key时，只要这个key不是落到同一个分片上，就可以和其他分片并发地处理内存数据，如图：</p>
<img src="/2022/11/27/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE/consistent-hash-partition.drawio.png" class="">

<p>相同的道理，在分布式集群中，我们可以对数据进行分片，每个服务节点代表一个分片。在访问时根据hash确定自己要访问的节点，这样集群服务能有更好的吞吐量。通过哈希算法，每个 key 都可以寻址到对应的服务器。但如果节点数量发生变化，基于新的服务器数量来执行哈希算法的时候，就会出现路由寻址失败的情况。</p>
<p>例如一个 key,hash后得到 891568578,如果现在是5个节点，891568578%5&#x3D;3，将这个key的数据存放到 第3个节点。第二次访问的时候，集群扩容为10个节点，891568578%10&#x3D;8，而原来的数据是存放在第3个节点上的。</p>
<p>扩容后需要做数据迁移，而直接%的这种方式，迁移成本很高。而一致性hash就是用来解决这个问题的。</p>
<p>节点在hash后，对应到 [0,2^32-1]，而key在hash后，就往后找第一个大于自己的节点。这个节点就是处理的节点。如图</p>
<img src="/2022/11/27/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE/consistent-hash.drawio.png" class="">









<h2 id="设计-3"><a href="#设计-3" class="headerlink" title="设计"></a>设计</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;hash/crc32&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">		Name <span class="type">string</span></span><br><span class="line">		Addr <span class="type">string</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> n1 = Node&#123;Name: <span class="string">&quot;n91&quot;</span>, Addr: <span class="string">&quot;192.168.2.1:9091&quot;</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> n2 = Node&#123;Name: <span class="string">&quot;n92&quot;</span>, Addr: <span class="string">&quot;192.168.2.1:9092&quot;</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> n3 = Node&#123;Name: <span class="string">&quot;n93&quot;</span>, Addr: <span class="string">&quot;192.168.2.1:9093&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> ch = NewConsistentHash()</span><br><span class="line">	ch.Add(n1.Name, n1, <span class="number">1</span>)</span><br><span class="line">	ch.Add(n2.Name, n2, <span class="number">1</span>)</span><br><span class="line">	ch.Add(n3.Name, n3, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> key1 = <span class="string">&quot;abc&quot;</span></span><br><span class="line">	<span class="keyword">var</span> key2 = <span class="string">&quot;def&quot;</span></span><br><span class="line">	<span class="keyword">var</span> key3 = <span class="string">&quot;ghi&quot;</span></span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;node1 hashcode:%d \n&quot;</span>, hashKey(n1.Name+<span class="string">&quot;0&quot;</span>))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;node2 hashcode:%d \n&quot;</span>, hashKey(n2.Name+<span class="string">&quot;0&quot;</span>))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;node3 hashcode:%d \n&quot;</span>, hashKey(n3.Name+<span class="string">&quot;0&quot;</span>))</span><br><span class="line"></span><br><span class="line">	ret1 := ch.Get(key1)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;get key1:%d, return node:%d \n&quot;</span>, hashKey(key1), hashKey(ret1.(Node).Name+<span class="string">&quot;0&quot;</span>))</span><br><span class="line">	ret2 := ch.Get(key2)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;get key2:%d, return node:%d \n&quot;</span>, hashKey(key2), hashKey(ret2.(Node).Name+<span class="string">&quot;0&quot;</span>))</span><br><span class="line">	ret3 := ch.Get(key3)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;get key3:%d, return node:%d \n&quot;</span>, hashKey(key3), hashKey(ret3.(Node).Name+<span class="string">&quot;0&quot;</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供功能：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">hash</span></span><br><span class="line"><span class="comment">添加节点</span></span><br><span class="line"><span class="comment">根据hash获得节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> ConsistentHash <span class="keyword">struct</span> &#123;</span><br><span class="line">	circle hashcode</span><br><span class="line">	nodes  <span class="keyword">map</span>[<span class="type">uint32</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	vnodes <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> <span class="comment">// 每个节点对应的虚拟节点数量</span></span><br><span class="line"></span><br><span class="line">	sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewConsistentHash</span><span class="params">()</span></span> (c *ConsistentHash) &#123;</span><br><span class="line">	c = <span class="built_in">new</span>(ConsistentHash)</span><br><span class="line">	c.circle = <span class="built_in">make</span>([]<span class="type">uint32</span>, <span class="number">0</span>, <span class="number">16</span>)</span><br><span class="line">	c.nodes = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">uint32</span>]<span class="keyword">interface</span>&#123;&#125;, <span class="number">16</span>)</span><br><span class="line">	c.vnodes = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">16</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加节点到 hash 环</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ConsistentHash)</span></span> Add(name <span class="type">string</span>, node <span class="keyword">interface</span>&#123;&#125;, virtualNum <span class="type">int</span>) &#123;</span><br><span class="line">	c.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> virtualNum == <span class="number">0</span> &#123; <span class="comment">// 每个节点在映射出多个虚拟节点，为了在哈希环上分布均匀，至少一个节点</span></span><br><span class="line">		virtualNum = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; virtualNum; i++ &#123;</span><br><span class="line">		h := hashKey(name + strconv.Itoa(i))</span><br><span class="line">		c.circle = <span class="built_in">append</span>(c.circle, h)</span><br><span class="line">		sort.Sort(c.circle)</span><br><span class="line">		c.nodes[h] = node</span><br><span class="line">	&#125;</span><br><span class="line">	c.vnodes[name] = virtualNum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ConsistentHash)</span></span> Remove(name <span class="type">string</span>) &#123;</span><br><span class="line">	c.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.Unlock()</span><br><span class="line"></span><br><span class="line">	virtualNum := c.vnodes[name]</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; virtualNum; i++ &#123;</span><br><span class="line">		h := hashKey(name + strconv.Itoa(i))</span><br><span class="line">		newCircle := <span class="built_in">make</span>([]<span class="type">uint32</span>, <span class="number">0</span>, <span class="built_in">len</span>(c.circle))</span><br><span class="line">		<span class="keyword">for</span> _, hashcode := <span class="keyword">range</span> c.circle &#123;</span><br><span class="line">			<span class="keyword">if</span> hashcode == h &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			newCircle = <span class="built_in">append</span>(newCircle, hashcode) <span class="comment">// 这里原本就有序，不需要重新排序</span></span><br><span class="line">		&#125;</span><br><span class="line">		c.circle = newCircle</span><br><span class="line">		<span class="built_in">delete</span>(c.nodes, h)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">delete</span>(c.vnodes, name)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//sort.Sort(c.circle)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ConsistentHash)</span></span> Get(key <span class="type">string</span>) (node <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	c.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.Unlock()</span><br><span class="line"></span><br><span class="line">	hc := hashKey(key)</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> ; i &lt; <span class="built_in">len</span>(c.circle); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> c.circle[i] &gt; hc &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> i == <span class="built_in">len</span>(c.circle) &#123;</span><br><span class="line">		i = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c.nodes[c.circle[i]]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现排序接口</span></span><br><span class="line"><span class="keyword">type</span> hashcode []<span class="type">uint32</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h hashcode)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h hashcode)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h hashcode)</span></span> Swap(i, j <span class="type">int</span>)      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashKey</span><span class="params">(key <span class="type">string</span>)</span></span> <span class="type">uint32</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(key) &lt; <span class="number">64</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> scratch [<span class="number">64</span>]<span class="type">byte</span></span><br><span class="line">		<span class="built_in">copy</span>(scratch[:], key)</span><br><span class="line">		<span class="keyword">return</span> crc32.ChecksumIEEE(scratch[:<span class="built_in">len</span>(key)])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> crc32.ChecksumIEEE([]<span class="type">byte</span>(key))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>













<h1 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h1><p><a href="https://developer.aliyun.com/article/680237">https://developer.aliyun.com/article/680237</a></p>
<p><a href="https://github.com/nusr/hacker-laws-zh">https://github.com/nusr/hacker-laws-zh</a></p>
<p><a href="https://www.stathat.com/c">https://www.stathat.com/c</a></p>
<p>分布式系统的本质其实就是这两个问题：<a href="https://mp.weixin.qq.com/s/DXmQb9t29VKUQYGUzL68iQ">https://mp.weixin.qq.com/s/DXmQb9t29VKUQYGUzL68iQ</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/380222738">https://zhuanlan.zhihu.com/p/380222738</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/145044486">https://zhuanlan.zhihu.com/p/145044486</a></p>
]]></content>
      <categories>
        <category>分布式</category>
        <category>共识协议</category>
        <category>一致性算法</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>分布式</tag>
        <tag>分布式共识</tag>
        <tag>分布式一致性</tag>
      </tags>
  </entry>
  <entry>
    <title>开发-组件-LRU</title>
    <url>/2022/10/10/%E5%BC%80%E5%8F%91-%E7%BB%84%E4%BB%B6-LRU/</url>
    <content><![CDATA[<h1 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h1><p>&#x2F;&#x2F; 说一下LRU算法是什么（本质）</p>
<h2 id="LRU本质"><a href="#LRU本质" class="headerlink" title="LRU本质"></a>LRU本质</h2><p>LRU是Least Recently Used的缩写，即最近最少使用。在一个指定大小的集合中，当添加新的元素并且这个指定大小的集合放不下时，需要淘汰一个元素腾出位置，而淘汰的策略就是看谁是最早被访问的。</p>
<p>LRU的本质是在 [ 集合 ] 中维护一个信息，这个信息就是”各个元素的访问顺序”。然后根据这个”访问顺序”来决定淘汰策略</p>
<h2 id="LRU的设计"><a href="#LRU的设计" class="headerlink" title="LRU的设计"></a>LRU的设计</h2><p>因为LRU的本质是维护一个  “访问顺序”，所以我们可以有多种方式去实现这个 “访问信息” </p>
<ol>
<li>使用线性结构来维护 这个 “访问顺序” ——这个线性结构的顺序就代表了”访问顺序”</li>
<li>使用数值来维护这个”访问顺序”——这个数值的大小就代表了”访问顺序”</li>
</ol>
<p>由上面的两种设计思路，我们可以得到以下两种设计</p>
<ol>
<li>链表+map</li>
<li>数组+一个能维护数值顺序的数据结构（可以是数组）</li>
</ol>
<p>解释下两种设计的</p>
<ol>
<li><p>链表+map，本身链表就保存了”访问顺序”和”元素空间”，map只是一个为了加快访问速度的辅佐的数据结构。相当于索引</p>
</li>
<li><p>数组+(维护数值顺序的数据结构)，数组本身不维护”访问顺序”信息，只是作为存放元素的”元素空间”。而维护”访问顺序”的信息交给第二个数据结构，这个数据结构可以是数组，可以是堆，只要这个数据结构能维护数值的顺序，提供最早访问的元素是哪个的信息。例如在”页面置换算法中的LRU”，考虑到内存紧张，所以不会使用链表+map，而是使用两个数组，一个作为存放页面的空间，一个作为统计页面使用数值。</p>
</li>
</ol>
<h2 id="LRU代码实现"><a href="#LRU代码实现" class="headerlink" title="LRU代码实现"></a>LRU代码实现</h2><p>这里我们用代码实现下业务上传统的LRU实现方式，实现LRU算法需要使用到两个数据结构，map+链表</p>
<p>1.首先，因为LRU需要有一个淘汰策略，这个淘汰策略是根据访问顺序来决定的，所以，我们需要保存和维护这个”访问顺序”的信息，所以我们使用 [ 链表 ] 或者 [ 数组 ] 这种 <code>线性结构</code>的数据结构来保存。</p>
<p>2.然后，因为这个”访问顺序”是经常变动的，所以在链表和数组中，我们选择使用链表。</p>
<p>3.再者，考虑到访问缓存的耗时，不可能直接去遍历链表。所以我们需要给链表加上一个索引，让我们快速定位到要访问那个节点上。所以，我们需要加上一个 [ map ] 的数据结构。用来快速定位。</p>
<p>4.最后，在添加元素，访问元素，和删除元素时，维护好map和链表即可。</p>
<img src="/2022/10/10/%E5%BC%80%E5%8F%91-%E7%BB%84%E4%BB%B6-LRU/LRU-design.drawio.png" class="">

<p>github代码：<a href="https://github.com/donscoco/goboot/blob/main/container/lrucache/lrucache.go">https://github.com/donscoco/goboot/blob/main/container/lrucache/lrucache.go</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> lrucache</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;container/list&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">	elementList *list.List</span><br><span class="line">	elementMap  <span class="keyword">map</span>[<span class="type">string</span>]*list.Element</span><br><span class="line">	size        <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Entry <span class="keyword">struct</span> &#123; <span class="comment">// 用于移除的时候快速找到key</span></span><br><span class="line">	key <span class="type">string</span></span><br><span class="line">	val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(size <span class="type">int</span>)</span></span> *LRUCache &#123;</span><br><span class="line">	<span class="keyword">if</span> size &lt; <span class="number">1</span> &#123;</span><br><span class="line">		err := fmt.Errorf(<span class="string">&quot;invalid lrucache size&quot;</span>)</span><br><span class="line">		<span class="comment">// todo</span></span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;LRUCache&#123;</span><br><span class="line">		elementList: list.New(),</span><br><span class="line">		elementMap:  <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*list.Element, size),</span><br><span class="line">		size:        size,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LRUCache)</span></span> Set(key <span class="type">string</span>, val <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	elem, ok := l.elementMap[key]</span><br><span class="line">	<span class="keyword">if</span> ok &#123; <span class="comment">// 存在,移动到头部</span></span><br><span class="line">		elem.Value.(*Entry).val = val</span><br><span class="line">		l.elementList.MoveToFront(elem)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">// 不存在,创建,加入,移除尾部</span></span><br><span class="line">		entry := &amp;Entry&#123;</span><br><span class="line">			key: key,</span><br><span class="line">			val: val,</span><br><span class="line">		&#125;</span><br><span class="line">		elem := l.elementList.PushFront(entry)</span><br><span class="line">		l.elementMap[key] = elem</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> l.size &lt; l.elementList.Len() &#123;</span><br><span class="line">			rmElem := l.elementList.Back()</span><br><span class="line">			<span class="built_in">delete</span>(l.elementMap, rmElem.Value.(*Entry).key)</span><br><span class="line">			l.elementList.Remove(rmElem)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LRUCache)</span></span> Get(key <span class="type">string</span>) (val <span class="keyword">interface</span>&#123;&#125;, ok <span class="type">bool</span>) &#123;</span><br><span class="line">	elem, ok := l.elementMap[key]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, ok</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 存在就是进行了一次访问，直接移动到队头</span></span><br><span class="line">	l.elementList.MoveToFront(elem)</span><br><span class="line">	kv := elem.Value.(*Entry)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> kv.val, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LRUCache)</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> l.elementList.Len()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试使用的。查看 list 的顺序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LRUCache)</span></span> ForTest() &#123;</span><br><span class="line"></span><br><span class="line">	tmp := list.New()</span><br><span class="line">	<span class="keyword">var</span> printCont []<span class="type">string</span></span><br><span class="line">	length := l.elementList.Len()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">		elem := l.elementList.Front()</span><br><span class="line">		tmp.PushBack(elem.Value.(*Entry))</span><br><span class="line">		printCont = <span class="built_in">append</span>(printCont, elem.Value.(*Entry).key)</span><br><span class="line">		l.elementList.Remove(elem)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 恢复</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">		elem := tmp.Front()</span><br><span class="line">		l.elementList.PushBack(elem.Value.(*Entry))</span><br><span class="line">		tmp.Remove(elem)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(printCont) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		log.Println(strings.Join(printCont, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="近似LRU"><a href="#近似LRU" class="headerlink" title="近似LRU"></a>近似LRU</h1><p>在一些对 [ 内存 ] 和 [ 处理耗时 ] 比较紧张的系统中。会使用一种叫近似LRU的算法。例如redis会使用近似LRU。</p>
<h2 id="什么是近似LRU"><a href="#什么是近似LRU" class="headerlink" title="什么是近似LRU"></a>什么是近似LRU</h2><p>近似LRU的本质依然是在集合中淘汰掉元素来为新元素腾出位置，但是这个淘汰的方式没有那么严格，并非一定要是最早那个元素，比较早的元素也可以，只要不是最近访问过的元素。</p>
<p>按照这个设计思路，可以随机取出元素去淘汰，只不过这个随机出来的元素要进行判断，不能把最近的给淘汰了。所以说，元素本身是需要维护一个可以区分最近元素还是最远元素的信息。例如可以加个最近被访问的字段等。</p>
<h2 id="近似LRU的流程"><a href="#近似LRU的流程" class="headerlink" title="近似LRU的流程"></a>近似LRU的流程</h2><p>我们以redis的近似LRU为例，说一下近似LRU的流程</p>
<p>Redis的key的底层结构是 redisObject，redisObject 中 lru:LRU_BITS 字段用于记录该key最近一次被访问时的Redis时钟 server.lruclock（Redis在处理数据时，都会调用lookupKey方法用于更新该key的时钟）。</p>
<p>Redis 给 每个key增加了一个额外的小字段，这个字段长度是24bit，也就是最后一次被访问的时间戳，当redis执行写操作时，发现内存超出maxmemory，就会执行换一次LRU淘汰算法。随机采样x个key，然后淘汰掉最旧的key，如果淘汰后内存还是超出maxmemory，那就继续随机采样淘汰，直到内存低于maxmemory。至于x取值是多少，看 maxmemory-policy的配置。</p>
<p>redis的对象数据结构：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/* The actual Redis Object */</span><br><span class="line"><span class="comment">#define LRU_BITS 24</span></span><br><span class="line"><span class="comment">#define LRU_CLOCK_MAX ((1&lt;&lt;LRU_BITS)-1) /* Max value of obj-&gt;lru */</span></span><br><span class="line"><span class="comment">#define LRU_CLOCK_RESOLUTION 1000 /* LRU clock resolution in ms */</span></span><br><span class="line">typedef struct redisObject &#123;</span><br><span class="line">    unsigned <span class="built_in">type</span>:4;</span><br><span class="line">    unsigned encoding:4;</span><br><span class="line">    unsigned lru:LRU_BITS; /* lru time (relative to server.lruclock) */</span><br><span class="line">    int refcount;</span><br><span class="line">    void *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>



<p>redis 清理内存代码见  <code>int freeMemoryIfNeeded(void)</code>  函数</p>
<h2 id="为什么使用近似LRU"><a href="#为什么使用近似LRU" class="headerlink" title="为什么使用近似LRU"></a>为什么使用近似LRU</h2><p>原生LRU算法需要 双向链表 来管理数据，需要额外内存；<br>数据访问时涉及数据移动，有性能损耗；</p>
<h1 id="年代LRU"><a href="#年代LRU" class="headerlink" title="年代LRU"></a>年代LRU</h1><p>一些系统在使用LRU的时候会预读一些数据进入集合，但是，如果这些预读页如果一直不会被访问到，就会出现一个很奇怪的问题，不会被访问的预读页却占用了 LRU 链表前排的位置，而末尾淘汰的页，可能是频繁访问的页，这样就大大降低了缓存命中率。</p>
<p>为了避免这样的问题，将 LRU 划分区域：</p>
<p>一个区域放的是预读进来的数据，一个区域放的是实际访问到的。如图：</p>
<img src="/2022/10/10/%E5%BC%80%E5%8F%91-%E7%BB%84%E4%BB%B6-LRU/mysql-%E7%BC%93%E5%86%B2%E9%A1%B5LRU%E9%93%BE%E8%A1%A8a.drawio.png" class="">





<h1 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h1><p>LFU（Least Frequently Used） ，又叫最近最少使用算法。</p>
<p>如果一个数据在最近一段时间很少被访问到，那么可以认为在将来它被访问的可能性也很小。因此，当空间满时，最小频率访问的数据最先被淘汰。</p>
<p>LFU的本质：集合需要淘汰一个元素来为新元素腾出位置，而淘汰哪个元素，需要集合本身维护一个”访问次数”的信息，然后还要维护这个”访问次数”的信息排序或者最小信息。</p>
<ul>
<li><p>需要维护”访问次数”的信息</p>
</li>
<li><p>维护”访问次数最小”的信息</p>
</li>
</ul>
<p>这个”访问次数”的信息最直接的就是可以使用一个数值来保存。然后对这个数值进行排序。所以我们继续使用一个 数组或者链表的数据结构来保存元素，然后再加上一个数据结构来保存这个排序信息。自然就可以得出多种设计思路：</p>
<ol>
<li>可以用两个数组，一个保存元素，一个保存每个元素对应的访问频次，需要替换的时候遍历访问找到频次最少的，时间复杂度：O(n)</li>
<li>可以使用一个链表，节点保存好访问频次，每次改动都将这个节点移动到对应的访问次数的位置上。时间复杂度：O(n)</li>
<li>使用一个链表，一个map，链表用来保存数据信息，map用来优化，快速定位。时间复杂度：O(1)</li>
</ol>
<p>设计</p>
<p>首先，我们需要”保存元素”信息，所以我们需要一个数据结构，这里我们先用数组。为了维护”访问频次”信息，所以我们可以在每个节点上加一个字段用来表示这个节点的访问频次。</p>
<p>然后，处于时间复杂度考虑，我们不能每次都去遍历整个集合找最小值，所以，我们需要给这个集合加上一个索引，所以我们需要加上一个map的数据结构，这个map的key保存的是频次，val是对应的节点，还有一个值用来保存最小频次，后续访问节点时维护这个min和map。</p>
<p>再者，加上 [ 频次的索引 ] 之后因为会出现频次相同的节点，所以每个节点需要单独成为一个集合，一个相同频次的集合，所以，我们可以把相同频次的节点集合挂在 [ 频次索引 ] 的map下。</p>
<p>最后，因为每个节点被访问后，频次改变，都会移动到对应频次下的集合，所以经常会改动，所以把数组的数据结构换成链表的数据结构。然后因为换成链表，相同频次下的节点去访问的时候还是会遍历这个相同频次的集合，所以，需要再加上一个索引，用来快速定位到每个节点。</p>
<p>整个思路过程如图：</p>
<img src="/2022/10/10/%E5%BC%80%E5%8F%91-%E7%BB%84%E4%BB%B6-LRU/LFU-design.drawio.png" class="">

<p>代码：<a href="https://github.com/donscoco/goboot/blob/main/container/lfucache/lfucache.go">https://github.com/donscoco/goboot/blob/main/container/lfucache/lfucache.go</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package lfucache</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">&quot;container/list&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> LFUCache struct &#123;</span><br><span class="line">	elementMap map[string]*list.Element //用来快速定位 key-value</span><br><span class="line">	//entryList *list.List</span><br><span class="line">	frequency map[int]*list.List // 将相同频次的entry放一起，用来快速定位各个频次的集合</span><br><span class="line"></span><br><span class="line">	capacity int</span><br><span class="line">	min      int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> Entry struct &#123;</span><br><span class="line">	key       string</span><br><span class="line">	val       interface&#123;&#125;</span><br><span class="line">	frequency int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func New(capacity int) (l *LFUCache) &#123;</span><br><span class="line">	<span class="keyword">if</span> capacity &lt; 1 &#123;</span><br><span class="line">		err := fmt.Errorf(<span class="string">&quot;invalid capacity&quot;</span>)</span><br><span class="line">		// todo</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	l = &amp;LFUCache&#123;</span><br><span class="line">		elementMap: make(map[string]*list.Element),</span><br><span class="line">		frequency:  make(map[int]*list.List),</span><br><span class="line">		capacity:   capacity,</span><br><span class="line">		min:        0,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> l</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (l *LFUCache) Get(key string) (val interface&#123;&#125;, ok bool) &#123;</span><br><span class="line">	// todo check</span><br><span class="line">	<span class="keyword">if</span> l.capacity == 0 &#123;</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	elem, ok := l.elementMap[key]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="built_in">return</span> nil, ok</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 移出旧的频次队列</span><br><span class="line">	entry := elem.Value.(*Entry)</span><br><span class="line">	oldList := l.frequency[entry.frequency] //elementMap中能拿到这里肯定能拿到。不用判空</span><br><span class="line">	oldList.Remove(elem)</span><br><span class="line"></span><br><span class="line">	entry.frequency = entry.frequency + 1</span><br><span class="line"></span><br><span class="line">	// 放到新的频次队列</span><br><span class="line">	_, ok = l.frequency[entry.frequency]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		l.frequency[entry.frequency] = list.New()</span><br><span class="line">	&#125;</span><br><span class="line">	newList := l.frequency[entry.frequency]</span><br><span class="line">	l.elementMap[entry.key] = newList.PushFront(entry)</span><br><span class="line"></span><br><span class="line">	// 更新最小频次</span><br><span class="line">	<span class="keyword">if</span> l.frequency[l.min].Len() == 0 &amp;&amp; l.min == entry.frequency-1 &#123;</span><br><span class="line">		l.min = entry.frequency</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> entry.val, <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">func (l *LFUCache) Set(key string, val interface&#123;&#125;) &#123;</span><br><span class="line">	// todo check</span><br><span class="line">	<span class="keyword">if</span> l.capacity == 0 &#123;</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	elem, ok := l.elementMap[key]</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line"></span><br><span class="line">		// 移出队列，频次+1，加入新队列</span><br><span class="line">		entry := elem.Value.(*Entry)</span><br><span class="line">		oldList := l.frequency[entry.frequency] // 能在 elementMap中找到，这里就一定能找到</span><br><span class="line">		//if oldList == nil &#123;</span><br><span class="line">		oldList.Remove(elem)</span><br><span class="line"></span><br><span class="line">		entry.val = val</span><br><span class="line">		entry.frequency = entry.frequency + 1</span><br><span class="line"></span><br><span class="line">		_, ok := l.frequency[entry.frequency] // 新的 频次不一定初始化了。要判断下</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			l.frequency[entry.frequency] = list.New()</span><br><span class="line">		&#125;</span><br><span class="line">		newList := l.frequency[entry.frequency]</span><br><span class="line">		//newList.PushFront(entry)</span><br><span class="line">		l.elementMap[entry.key] = newList.PushFront(entry)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> l.frequency[l.min].Len() == 0 &amp;&amp; l.min == entry.frequency-1 &#123;</span><br><span class="line">			l.min = entry.frequency</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> l.capacity == len(l.elementMap) &#123; // 满了就清除一个最小的频次</span><br><span class="line">			minList := l.frequency[l.min]</span><br><span class="line">			rmElem := minList.Back() // 我们插入是front，为了公平性，从back开始移出</span><br><span class="line">			minList.Remove(rmElem)</span><br><span class="line">			delete(l.elementMap, rmElem.Value.(*Entry).key)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		entry := &amp;Entry&#123;</span><br><span class="line">			key:       key,</span><br><span class="line">			val:       val,</span><br><span class="line">			frequency: 1,</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		_, ok := l.frequency[entry.frequency]</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			l.frequency[entry.frequency] = list.New()</span><br><span class="line">		&#125;</span><br><span class="line">		newList := l.frequency[entry.frequency]</span><br><span class="line">		//newList.PushFront(entry)</span><br><span class="line">		l.elementMap[entry.key] = newList.PushFront(entry)</span><br><span class="line"></span><br><span class="line">		l.min = 1 // 新节点加入频次肯定是1</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">func (l *LFUCache) Del(key string) &#123;</span><br><span class="line">	// todo check</span><br><span class="line">	<span class="keyword">if</span> l.capacity == 0 &#123;</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	elem, ok := l.elementMap[key]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	entry := elem.Value.(*Entry)</span><br><span class="line">	oldList := l.frequency[entry.frequency] // 能在 elementMap中找到，这里就一定能找到</span><br><span class="line">	//if oldList == nil &#123;</span><br><span class="line">	oldList.Remove(elem)</span><br><span class="line">	delete(l.elementMap, entry.key)</span><br><span class="line"></span><br><span class="line">	// 更新最小频次,最小的已经remove了。找到第二小的 O(n)</span><br><span class="line">	<span class="keyword">if</span> l.frequency[l.min].Len() == 0 &#123;</span><br><span class="line">		l.min = 0</span><br><span class="line">		<span class="keyword">for</span> _, e := range l.elementMap &#123;</span><br><span class="line">			entry := e.Value.(*Entry)</span><br><span class="line">			<span class="keyword">if</span> entry.frequency &lt; l.min || l.min == 0 &#123;</span><br><span class="line">				l.min = entry.frequency</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//func (l *LFUCache) <span class="function"><span class="title">ForTest</span></span>() &#123;</span><br><span class="line">//	<span class="keyword">for</span> _, elem := range l.elementMap &#123;</span><br><span class="line">//		entry := elem.Value.(*Entry)</span><br><span class="line">//		fmt.Printf(<span class="string">&quot;k:%s,v:%+v,f:%d\n&quot;</span>, entry.key, entry.val, entry.frequency)</span><br><span class="line">//	&#125;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>算法</category>
        <category>LRU</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>LRU</tag>
        <tag>LFU</tag>
      </tags>
  </entry>
  <entry>
    <title>开发-组件-实现trylock</title>
    <url>/2019/10/06/%E5%BC%80%E5%8F%91-%E7%BB%84%E4%BB%B6-%E5%AE%9E%E7%8E%B0trylock/</url>
    <content><![CDATA[<p>实现trylock</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;os/signal&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">	<span class="string">&quot;syscall&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	mutexLocked = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// mutex is locked</span></span><br><span class="line">	mutexWoken</span><br><span class="line">	mutexStarving</span><br><span class="line">	mutexWaiterShift = <span class="literal">iota</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PtrSize = <span class="number">4</span> &lt;&lt; (^<span class="type">uintptr</span>(<span class="number">0</span>) &gt;&gt; <span class="number">63</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 写一个 trylock</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wait1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	wait2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//函数用于lock住，看看main协程的trylock能不能获得</span></span><br><span class="line">		<span class="comment">//1.lock</span></span><br><span class="line">		<span class="comment">//defer mu.Unlock()</span></span><br><span class="line">		<span class="comment">//mu.Lock()</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//2.do nothing</span></span><br><span class="line"></span><br><span class="line">		wait1 &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//函数用于 看看main协程的trylock获得锁后，能不能正常像正常一样lock住</span></span><br><span class="line">		<span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">		&lt;-wait2</span><br><span class="line">		mu.Lock()</span><br><span class="line">		fmt.Println(<span class="string">&quot;如果这句话没两秒内打印出来，说明真的被lock住了,两秒后打印出来，说明main协程释放的锁真的有用&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	&lt;-wait1</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> trylock() &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;抢到锁&quot;</span>)</span><br><span class="line">		wait2 &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		<span class="comment">//mu.Unlock()</span></span><br><span class="line">		time.Sleep(<span class="number">2</span> * time.Second) <span class="comment">// 两秒后释放锁，看看上面被锁住的goroutine，能否打印出来</span></span><br><span class="line">		mu.Unlock()</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;没抢到&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sig := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">	signal.Notify(sig, syscall.SIGTERM, syscall.SIGURG)</span><br><span class="line">	&lt;-sig</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trylock</span><span class="params">()</span></span> (isLock <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="comment">//if atomic.CompareAndSwapInt32(muptr, 0, mutexLocked) &#123;</span></span><br><span class="line">	<span class="comment">//	if race.Enabled &#123;</span></span><br><span class="line">	<span class="comment">//		race.Acquire(unsafe.Pointer(&amp;mu))</span></span><br><span class="line">	<span class="comment">//	&#125;</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	muptr := (*<span class="type">int32</span>)(unsafe.Pointer(&amp;mu)) <span class="comment">// + PtrSize*4</span></span><br><span class="line">	<span class="keyword">return</span> atomic.CompareAndSwapInt32(muptr, <span class="number">0</span>, mutexLocked)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>锁</category>
        <category>trylock</category>
      </categories>
      <tags>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-模版思维</title>
    <url>/2022/11/03/%E7%AE%97%E6%B3%95-%E6%A8%A1%E7%89%88%E6%80%9D%E7%BB%B4/</url>
    <content><![CDATA[<p>记录一些常用到的模版，套路化，方便自己解决问题的时候更加专注于做事情</p>
<h1 id="递归模版"><a href="#递归模版" class="headerlink" title="递归模版"></a>递归模版</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">func</span></span>()&#123;</span><br><span class="line">	<span class="comment"># recursion terminator    1.递归终止条件</span></span><br><span class="line">	<span class="comment"># process logic in current level     2.在这一层处理的事情</span></span><br><span class="line">	<span class="comment"># drill down    3.到下一层</span></span><br><span class="line">	<span class="comment"># reverse the current level status if needed   4.还原本层状态 (联想n-皇后用递归实现的代码)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="遍历模版"><a href="#遍历模版" class="headerlink" title="遍历模版"></a>遍历模版</h1><h2 id="深度遍历"><a href="#深度遍历" class="headerlink" title="深度遍历"></a>深度遍历</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 用递归实现</span></span><br><span class="line"><span class="comment"># 如果是图的话，申请一个set（排重），树的DFS和图的DFS一样，只是图要加个排重set</span></span><br><span class="line">func DFS(node,<span class="built_in">set</span>)&#123;</span><br><span class="line">	<span class="comment"># 如果是图的话，加入set</span></span><br><span class="line">	process() <span class="comment">## process 的位置可以放在for后面，取决于想前序遍历还是后序遍历。中序遍历需要方在for里面中间（对于树而言）</span></span><br><span class="line">	<span class="keyword">for</span> next_node := range node.Child &#123; <span class="comment"># 获取node关联节点 nodes</span></span><br><span class="line">  	<span class="comment"># 如果是图的话还需要判断是否set中有的。</span></span><br><span class="line">  	DFS(node.next,<span class="built_in">set</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">### 用栈去实现（递归其实也是这种，只不过系统用的系统栈）</span></span><br><span class="line">func <span class="function"><span class="title">DFS</span></span>()&#123;</span><br><span class="line"><span class="comment"># 栈</span></span><br><span class="line"><span class="comment"># 根节点入栈，包括根节点关联的节点 （入栈顺序决定遍历顺序   rc,lc,p 是前序遍历;rc,p,lc 是中序遍历;p,rc,lc 是后序遍历）</span></span><br><span class="line">  <span class="keyword">for</span> (栈不为空)&#123;</span><br><span class="line">  	<span class="comment"># 出栈</span></span><br><span class="line">  	process()</span><br><span class="line">  	<span class="keyword">for</span> next_node := range node.Child &#123; <span class="comment"># 获取node关联节点 nodes</span></span><br><span class="line">  		<span class="comment"># 如果是图的话还要判断set是否有再入栈</span></span><br><span class="line">  		<span class="comment"># 推入栈 （入栈顺序决定遍历顺序   这个是前序遍历，考虑怎么实现中序遍历和后序遍历——染色）</span></span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">process</span></span>()&#123;&#125;</span><br></pre></td></tr></table></figure>



<h2 id="广度遍历"><a href="#广度遍历" class="headerlink" title="广度遍历"></a>广度遍历</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">BFS</span></span>()&#123;</span><br><span class="line"><span class="comment"># 队列</span></span><br><span class="line"><span class="comment"># 加入root节点，如果是图的话需要再加入 map（做访问标记，排重）</span></span><br><span class="line">	<span class="keyword">for</span> (队列不空) &#123;</span><br><span class="line">		<span class="comment"># 出队 node</span></span><br><span class="line">		process()</span><br><span class="line">		<span class="keyword">for</span> next_node := range node.Child &#123;<span class="comment"># 获取node关联节点 nodes</span></span><br><span class="line">			<span class="comment"># 如果是图的话还需要判断是否map中有的（做访问过的标记）再加入队列</span></span><br><span class="line">			<span class="comment"># nodes加入队列</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">process</span></span>()&#123;&#125;</span><br></pre></td></tr></table></figure>



<h2 id="M的N次方"><a href="#M的N次方" class="headerlink" title="M的N次方"></a>M的N次方</h2><p>想象一棵树，树枝就是各种可能的情况，遍历所有情况：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 树的遍历 m的n次方，m相当于一层m个节点，n相当于这棵树有n层</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">power</span><span class="params">(m, n, i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">/*判断是否最后一层的叶子节点。关键点就是</span></span><br><span class="line"><span class="comment">  靠每层调用下一层的时候传递的 标志 i代表接下来是第几层*/</span></span><br><span class="line">	<span class="keyword">if</span> i &gt;= n &#123;</span><br><span class="line">    process()<span class="comment">// 叶子节点的处理</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// process() //中间节点的处理（如果需要）</span></span><br><span class="line">  <span class="comment">// 可以想象这里就是一个节点的多个孩子节点分出去。</span></span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; m; j++ &#123;</span><br><span class="line">		power(m, n, i+<span class="number">1</span>)       </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用例子：</p>
<p>例如N皇后问题的蛮力法求解，这里m和n相等，但是为区分横和竖还是写作m和n，m代表皇后在一行可以选择落子的种类数，n代表有多少个皇后，每个皇后在所在的那一行选择m种情况落下，这样在不考虑是否冲突的情况下就有 <code>m*m*m*m...*m</code> n个m相乘种情况。然后想象这是一棵树。一棵每个节点有m个孩子节点，然后有n层的树，对应的情况就是每个皇后的m种选择，后面的皇后每人又有m种选择，一直到叶子节点，所有叶子节点就是所有情况。然后我们再在每个叶子节点处进行判断皇后是否冲突，然后塞选（因为这里用的蛮力法，先展示处理啊，而分支限界法就是在蛮力法这棵树的基础上，在一些中间节点就判断冲突，从而进行剪枝。所以最好把蛮力法这种最原始的版本记住，后面剪枝只需要在中间节点进行处理）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Q</span><span class="params">(m, n, i <span class="type">int</span>，position []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">/*判断是否最后一层的叶子节点。关键点就是</span></span><br><span class="line"><span class="comment">  靠每层调用下一层的时候传递的 标志 i代表接下来是第几层*/</span></span><br><span class="line">	<span class="keyword">if</span> i &gt;= n &#123;  </span><br><span class="line">    checkVaild()<span class="comment">// 叶子节点的处理</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// process() 中间节点的处理（如果需要）</span></span><br><span class="line">  <span class="comment">// 可以想象这里就是一个节点的多个孩子节点分出去。</span></span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; m; j++ &#123;</span><br><span class="line">    position[i]=j <span class="comment">//  代表第i层的皇后落在第j格</span></span><br><span class="line">		Q(m, n, i+<span class="number">1</span>) </span><br><span class="line">    position[i]=<span class="number">0</span> <span class="comment">//  把刚才下的情况拿掉，换下一种</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加上分支限界法的剪枝处理就是</span></span><br><span class="line"><span class="comment">// 这里冲突的情况可以剪枝有 列冲突，撇冲突，捺冲突。</span></span><br><span class="line"><span class="comment">// 对应 cols=&gt;j pie=&gt;i+j na=&gt;i-j</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DFS</span><span class="params">(m, n, i <span class="type">int</span>，position []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">/*判断是否最后一层的叶子节点。关键点就是</span></span><br><span class="line"><span class="comment">  靠每层调用下一层的时候传递的 标志 i代表接下来是第几层*/</span></span><br><span class="line">	<span class="keyword">if</span> i &gt;= n &#123;</span><br><span class="line">    <span class="comment">// 叶子节点的处理,添加到结果集,能走到这里说明没有冲突</span></span><br><span class="line">    result = <span class="built_in">append</span>(result,position)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// process() 中间节点的处理（如果需要）</span></span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; m; j++ &#123; </span><br><span class="line">    <span class="keyword">if</span> cols.HasNum(j) || pie.HasNum(i+j) || na.HasNum(i-j) &#123;</span><br><span class="line">      <span class="keyword">continue</span>; <span class="comment">// 在选择这条分支的前提就已经发现这里会冲突，所以就跳过</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    position[i]=j <span class="comment">//  代表第i层的皇后落在第j格</span></span><br><span class="line">    </span><br><span class="line">    cols.Add(j) <span class="comment">// 这里是选择落这个格子后，需要加上冲突提供给下一层的人判断。</span></span><br><span class="line">    pie.Add(i+j)</span><br><span class="line">    na.Add(i-j)</span><br><span class="line">    </span><br><span class="line">		DFS(m, n, i+<span class="number">1</span>)  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* // 接下来要到兄弟节点上。也就是这个皇后可能选择落点的另一种情况上。</span></span><br><span class="line"><span class="comment">    所以这次的落子情况造成的影响移除*/</span></span><br><span class="line">    cols.Remove(j)</span><br><span class="line">    pie.Remove(i+j)</span><br><span class="line">    na.Remove(i-j)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="查找模版"><a href="#查找模版" class="headerlink" title="查找模版"></a>查找模版</h1><h2 id="二分模版"><a href="#二分模版" class="headerlink" title="二分模版"></a>二分模版</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">left,right = 0, len(array) - 1</span><br><span class="line"><span class="keyword">while</span> left &lt;= right:</span><br><span class="line">	mid = left + (right - left)/2</span><br><span class="line">	<span class="keyword">if</span> array[mid] == target:</span><br><span class="line">		<span class="built_in">break</span> or <span class="built_in">return</span> result</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> array[mid] &lt; target :</span><br><span class="line">		left = mid + 1</span><br><span class="line">	<span class="keyword">else</span> right = mid -1</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"><span class="comment"># 递归形式</span></span><br><span class="line">func DAC(left,right,target,arr[]) int &#123;</span><br><span class="line">		<span class="keyword">if</span> (left &gt; right)&#123;</span><br><span class="line">			<span class="built_in">return</span> -1</span><br><span class="line">		&#125;</span><br><span class="line">		var mid = left + (right-left)/2</span><br><span class="line">		<span class="keyword">if</span> arr[mid] == target &#123;</span><br><span class="line">			<span class="built_in">return</span> mid</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (target &gt; arr[mid])&#123;</span><br><span class="line">			<span class="built_in">return</span> right = DAC(mid+1,right,target,arr)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (target &lt; arr[mid])&#123;</span><br><span class="line">			<span class="built_in">return</span> left = DAC(left,mid-1,target,arr)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">return</span> -1 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环形式</span></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>思维套路</category>
        <category>遍历</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模版</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-动态规划思路</title>
    <url>/2022/10/18/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>思维套路</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>https</title>
    <url>/2022/10/14/https%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<h1 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h1><h1 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h1><h2 id="公钥加密"><a href="#公钥加密" class="headerlink" title="公钥加密"></a>公钥加密</h2><h2 id="私钥加密（签名）"><a href="#私钥加密（签名）" class="headerlink" title="私钥加密（签名）"></a>私钥加密（签名）</h2><h1 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h1><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>抓包例子</p>
]]></content>
  </entry>
  <entry>
    <title>安全退出</title>
    <url>/2019/10/03/go-%E5%AE%89%E5%85%A8%E9%80%80%E5%87%BA/</url>
    <content><![CDATA[<p>从上游往下close</p>
<h4 id="通道关闭原则"><a href="#通道关闭原则" class="headerlink" title="通道关闭原则"></a>通道关闭原则</h4><p>一般原则上使用通道是不允许接收方关闭通道和 <strong>不能关闭一个有多个并发发送者的通道</strong>。 换而言之， 只能在发送方的 goroutine 中关闭只有该发送方的通道。</p>
<p>自己的想法</p>
<p>可以添加一个 waitGroup ，然后在生产者每次发送前都 wg.add 一下，然后选择一个地方进行done，</p>
<p>可以是生产者发完之后，1:N；但是这样就不保证下游一定被消费，例如发布订阅的情况，发布可以wait，但是我们不知道订阅者数量。</p>
<p>也可以是消费者消费之后，这种1:1</p>
<h4 id="优雅退出程序"><a href="#优雅退出程序" class="headerlink" title="优雅退出程序"></a>优雅退出程序</h4><p>先注册一个个退出函数保存起来，然后开始阻塞在signal上，等收到退出的signal后，处理完之前一个个注册的退出函数，然后退出。关于业务逻辑怎么退出，就交给这些退出函数去处理</p>
<h4 id="安全退出channel"><a href="#安全退出channel" class="headerlink" title="安全退出channel"></a>安全退出channel</h4><p>核心思想，通知上游发起关闭，每个级的channel 消费到最后，由 v,ok:&#x3D; &lt;&#x3D;channel 的 ok 判断channel是否关闭，如果下游还有channel，则这一级需要负责关闭下一级的channel</p>
<p>一个带有缓存的 pub&#x2F;sub 的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;os/signal&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;syscall&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PS <span class="keyword">struct</span> &#123;</span><br><span class="line">	topics <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	pubs   <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">map</span>[<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	subs   <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">map</span>[<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	buff   <span class="type">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 优雅退出</span></span><br><span class="line">	Exit        <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">//退出标志，go提倡不要用内存做通信，所以这里不是用atomic而是用channel去做</span></span><br><span class="line">	Publishing  sync.WaitGroup</span><br><span class="line">	Subscribing sync.WaitGroup <span class="comment">// 多对1，不是像上面exit那样由1个close的的goroutine去通知的。是等待多个goroutine，这里设置成wg比较符合语义</span></span><br><span class="line"></span><br><span class="line">	mu sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> PubSub *PS</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPubSub</span><span class="params">(b <span class="type">int</span>)</span></span> (ps *PS) &#123;</span><br><span class="line">	ps = <span class="built_in">new</span>(PS)</span><br><span class="line">	ps.topics = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, <span class="number">16</span>)</span><br><span class="line">	ps.subs = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">map</span>[<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;]<span class="keyword">struct</span>&#123;&#125;, <span class="number">16</span>)</span><br><span class="line">	ps.buff = b</span><br><span class="line">	ps.Exit = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">return</span> ps</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *PS)</span></span> Run(topic <span class="type">string</span>) (e <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> ps == <span class="literal">nil</span> &#123;</span><br><span class="line">		e = errors.New(<span class="string">&quot;empty ps&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ps.topics[topic] == <span class="literal">nil</span> &#123;</span><br><span class="line">		ps.topics[topic] = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, ps.buff)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ps.subs[topic] == <span class="literal">nil</span> &#123;</span><br><span class="line">		ps.subs[topic] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;]<span class="keyword">struct</span>&#123;&#125;, <span class="number">16</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			v, ok := &lt;-ps.topics[topic]</span><br><span class="line">			<span class="keyword">if</span> !ok &#123; <span class="comment">//这里表示channel已经关闭了，而且已经消费完上游了。可以准备退出了。如果这个channel的下游还是channel，那要负责关闭下游的channel</span></span><br><span class="line">				<span class="keyword">for</span> subc := <span class="keyword">range</span> ps.subs[topic] &#123;</span><br><span class="line">					<span class="built_in">close</span>(subc)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> subc := <span class="keyword">range</span> ps.subs[topic] &#123;</span><br><span class="line">				subc &lt;- v</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Publish</span><span class="params">(ps *PS, topic <span class="type">string</span>, v <span class="keyword">interface</span>&#123;&#125;)</span></span> (e <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> ps == <span class="literal">nil</span> &#123;</span><br><span class="line">		e = errors.New(<span class="string">&quot;empty ps&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ps.topics[topic] == <span class="literal">nil</span> || ps.subs[topic] == <span class="literal">nil</span> &#123;</span><br><span class="line">		e = errors.New(<span class="string">&quot;empty topic&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	ps.topics[topic] &lt;- v</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Subscribe</span><span class="params">(ps *PS, topic <span class="type">string</span>, c <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> (e <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> ps == <span class="literal">nil</span> &#123;</span><br><span class="line">		e = errors.New(<span class="string">&quot;empty ps&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	ps.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> ps.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> ps == <span class="literal">nil</span> &#123;</span><br><span class="line">		e = errors.New(<span class="string">&quot;empty ps&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ps.topics[topic] == <span class="literal">nil</span> || ps.subs[topic] == <span class="literal">nil</span> &#123;</span><br><span class="line">		e = errors.New(<span class="string">&quot;empty topic&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	ps.subs[topic][c] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// concurrent map writes</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// todo</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UnSub</span><span class="params">(ps *PS, topic <span class="type">string</span>, c <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> (e <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> ps == <span class="literal">nil</span> &#123;</span><br><span class="line">		e = errors.New(<span class="string">&quot;empty ps&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	subcs := ps.subs[topic]</span><br><span class="line">	<span class="built_in">delete</span>(subcs, c) <span class="comment">//即时是空的也没关系</span></span><br><span class="line">	<span class="built_in">close</span>(c)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// todo</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Evict</span><span class="params">(ps *PS, topic <span class="type">string</span>)</span></span> (e <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> ps == <span class="literal">nil</span> &#123;</span><br><span class="line">		e = errors.New(<span class="string">&quot;empty ps&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	tc := ps.topics[topic]</span><br><span class="line">	<span class="built_in">close</span>(tc) <span class="comment">// 让run里面可能还没来得及消费的channel消费完</span></span><br><span class="line">	<span class="built_in">delete</span>(ps.topics, topic)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Close</span><span class="params">(ps *PS)</span></span> (e <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> ps == <span class="literal">nil</span> &#123;</span><br><span class="line">		e = errors.New(<span class="string">&quot;empty ps&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	ps.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> ps.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> ps == <span class="literal">nil</span> &#123;</span><br><span class="line">		e = errors.New(<span class="string">&quot;empty ps&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">close</span>(ps.Exit)</span><br><span class="line">	<span class="comment">//ps.Publishing.Wait() // 等待所有生产者都搞定。安全退出</span></span><br><span class="line"></span><br><span class="line">	ps.Subscribing.Wait() <span class="comment">// 等待所有消费者都搞定。安全退出</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;安全退出&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	ps := NewPubSub(<span class="number">10</span>)</span><br><span class="line">	ps.Run(<span class="string">&quot;topic1&quot;</span>)</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(initf <span class="keyword">func</span>()</span></span>) &#123;</span><br><span class="line">		ps.Subscribing.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">defer</span> ps.Subscribing.Done()</span><br><span class="line"></span><br><span class="line">		initf()</span><br><span class="line"></span><br><span class="line">		c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">		Subscribe(ps, <span class="string">&quot;topic1&quot;</span>, c)</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			v, ok := &lt;-c</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				fmt.Println(<span class="string">&quot;channel 已经关闭&quot;</span>) <span class="comment">// 上游已经关闭，关闭下游，如果没有下游，那就可以退出了。</span></span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Println(<span class="string">&quot;sub1 get :&quot;</span>, v)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; wg.Done() &#125;) <span class="comment">// 这里 成自定义一个初始化函数，为了让消费者先启动，生产环境可以不要</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(initf <span class="keyword">func</span>()</span></span>, exitf <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;</span><br><span class="line">		ps.Subscribing.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">defer</span> ps.Subscribing.Done()</span><br><span class="line"></span><br><span class="line">		initf()</span><br><span class="line"></span><br><span class="line">		c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">		Subscribe(ps, <span class="string">&quot;topic1&quot;</span>, c)</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			v, ok := &lt;-c</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				fmt.Println(<span class="string">&quot;channel 已经关闭&quot;</span>) <span class="comment">//这里表示channel已经关闭了，而且已经消费完上游了。可以准备退出了。如果这个channel的下游还是channel，那要负责关闭下游的channel</span></span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Println(<span class="string">&quot;sub2 get :&quot;</span>, v)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">//退出函数，退出前的处理，没有事情做那就直接退出了。</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">//ps.Publishing.Add(1)</span></span><br><span class="line">		<span class="comment">//defer ps.Publishing.Done()</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-ps.Exit:</span><br><span class="line">				<span class="comment">// 收到退出通知，做退出相关处理。例如判断n还没有处理完就continue继续处理；</span></span><br><span class="line">				fmt.Println(<span class="string">&quot;收到通知，生产者退出，已经处理到：&quot;</span>, i<span class="number">-1</span>)</span><br><span class="line">				<span class="comment">// 当确定要退出的时候，如果下游是channel需要负责关闭下游的channel</span></span><br><span class="line">				<span class="keyword">for</span> _, tc := <span class="keyword">range</span> ps.topics &#123;</span><br><span class="line">					<span class="built_in">close</span>(tc)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				Publish(ps, <span class="string">&quot;topic1&quot;</span>, i)</span><br><span class="line">				<span class="comment">//time.Sleep(1 * time.Second)</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	Close(ps)</span><br><span class="line"></span><br><span class="line">	sig := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">	signal.Notify(sig, syscall.SIGTERM, syscall.SIGINT)</span><br><span class="line">	&lt;-sig</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>小技巧</category>
        <category>关闭</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>编程思维模版</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务</title>
    <url>/2022/10/02/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<p>事务：当多个线程对数据库中的同一个信息进行修改的时候，为保证数据的原子性、一致性、隔离性、持久性，需要进行本地事务性操作。而在分布式的网络环境下，也会面临多个客户端的数据请求服务。在处理数据变更的时候，需要保证在分布式环境下的数据的正确完整，因此在分布式环境下也引入了分布式事务。</p>
<p>分布式事务：分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。</p>
<h1 id="二阶段提交"><a href="#二阶段提交" class="headerlink" title="二阶段提交"></a>二阶段提交</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>二阶段提交（Two-phase Commit）简称 2PC，是解决分布式事务的方式。要么所有参与进程都提交事务，要么都取消事务，即实现ACID中的原子性（A）的常用手段。</p>
<p>分布式事务：事务提供一种操作本地数据库的不可分割的一系列操作。要么什么都不做，要么做全套（All or Nothing）。</p>
<h2 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h2><p>二阶段执行成功</p>
<img src="/2022/10/02/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/2pc-1.drawio.png" class="">



<p>二阶段执行失败</p>
<img src="/2022/10/02/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/2pc-2.drawio.png" class="">



<p>缺点</p>
<ul>
<li><p>同步阻塞性能问题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在二阶段提交的执行的过程中，所有参与该事务操作的逻辑都处于堵塞状态。当参与者占用公共资源时，其他参与者一直处于锁定事务资源的状态中，而无法完成事务操作。不适合于高并发场景</span><br></pre></td></tr></table></figure>
</li>
<li><p>可靠性问题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">一旦事务管理器出现故障，整个系统不可用</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据不一致</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在阶段二，如果事务管理器只发送了部分 commit 消息，此时网络发生异常，那么只有部分参与者接收到 commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。</span><br></pre></td></tr></table></figure>
</li>
<li><p>不确定性</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">当协调者事务管理器发送 commit 之后，并且此时只有一个参与者收到了 commit，那么当该参与者与事务管理器同时宕机之后，重新选举的事务管理器无法确定该条消息是否提交成功。</span><br></pre></td></tr></table></figure></li>
</ul>
<p>解决思路：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">是否可以在协调者这里做一个redolog，每次发起事务后写入到redolog中，收到全员commit 成功后再移除，这样宕机后，重启或者选举新leader来，可以根据redolog检查各个参与者的commit情况，如果都没有commit成功，那就无事发生，清除redolog，如果有部分参与者commit成功，那就补充其他参与者的commit。如果都commit成功，那也无事发生，直接清除redolog。（参考mysql-innodb）</span><br></pre></td></tr></table></figure>





<h1 id="三阶段提交"><a href="#三阶段提交" class="headerlink" title="三阶段提交"></a>三阶段提交</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>3PC，全称为“Three phase commit”，是2PC的改进版，将2PC的“事务提交过程”一分为二，并形成了canCommit、preCommit和doCommit三个阶段组成的事务处理协议。</p>
<p>特点：</p>
<ul>
<li>三阶段提交协议引入了超时机制</li>
<li>相对于2PC而言，多加了一个canCommit缓冲阶段，保证了<strong>开始执行分布式事务之前各个参与的节点的状态一致</strong>。（分布式实现一致性是最终一致性，也就是存在某些时刻，各个节点处于过渡状态，不一定一致。canCommit保证这些过度已经结束，某个要处理的值在各个节点中是一致的，就会响应成功。）</li>
</ul>
<h2 id="运行过程-1"><a href="#运行过程-1" class="headerlink" title="运行过程"></a>运行过程</h2><p>三阶段执行成功</p>
<img src="/2022/10/02/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/3pc-1.drawio.png" class="">





<p>缺点：</p>
<p><strong>3PC没有完全解决数据一致性的问题。</strong></p>
<p>问题：在最后提交的阶段中，万一协调者故障，部分参与者已经commit，而部分参与者没有commit，会出现参与者数据不一致情况。这个问题本质就是协调者是单节点。存在单阶段故障问题，所以还要再改进，将协调者做成具备分布式共识的组件。然后在这个分布式组件中添加redolog机制</p>
<h1 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h1><p>TCC(Try Confirm Cancel) 又称为 补偿事务，又叫应用层的两阶段提交。</p>
<p>TCC事务的处理流程与2PC两阶段提交类似，不过2PC通常都是在处理<strong>DB层面</strong>的事务，而TCC本质上就是一个<strong>应用层面</strong>的2PC，需要通过业务逻辑来实现。</p>
<p>TCC模型仅提供两阶段原子提交协议，保证分布式事务的原子性。事务的隔离交给业务逻辑来实现。TCC 模型的隔离性思想是，通过对业务的改造将对数据库资源层面加锁上移至对业务层面加锁，从而释放底层数据库锁资源，拓宽分布式事务锁协议，提高系统的并发性。</p>
<p>本质：对于所有会改动数据状态的操作，都要有一套操作——确认修改和补偿修改。</p>
<p>注意 confirm和cancel 需要实现幂等</p>
<p>以A账户向B账户汇款100元为例，图中展示了TCC的流程。汇款服务和收款服务需要分别实现Try、Confirm、Cancel这三个接口，并在业务初始化阶段将这三个接口的实现注入TCC事务管理器。</p>
<img src="/2022/10/02/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/tcc-1.drawio.png" class="">





<p>Try 阶段：这个阶段其实就是检查资源和锁定资源的操作。或者说进行一个预留（或者先扣减，如果失败再补偿。）</p>
<p>Confirm 阶段：确认执行真正执行业务，不作任何业务检查，只使用 Try 阶段预留的业务资源，Confirm 操作满足幂等性。要求具备幂等设计，Confirm 失败后需要进行重试。</p>
<p>Cancel 阶段：释放 Try 阶段预留的业务资源 Cancel 操作满足幂等性 Cancel 阶段的异常和 Confirm 阶段异常处理方案基本上一致。</p>
<p>优点：可以让<strong>应用自己定义数据库操作的粒度，使得降低锁冲突、提高吞吐量</strong></p>
<p>注意：confirm和cancel接口还必须实现幂等。</p>
<p>有了补偿机制之后，由业务活动管理器控制一致性</p>
<h1 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h1><p> 将事务状态写入到新的表。相当于做了一个redolog，用来检查事务执行状态</p>
<p>正常处理：</p>
<img src="/2022/10/02/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/local-msg-table.drawio.png" class="">



<p>出现错误情况处理：</p>
<img src="/2022/10/02/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/local-msg-table-2.drawio.png" class="">



<p>&#x2F;&#x2F; todo</p>
<h1 id="MQ事务"><a href="#MQ事务" class="headerlink" title="MQ事务"></a>MQ事务</h1><p>一致性方案是通过消息中间件保证上下游应用数据操作一致性的。基本思路是，将本地操作和发送消息放在同一个本地事务中，下游应用从消息系统订阅该消息，收到消息后执行相应的操作，本质上是依靠消息的重试机制达到最终一致性的。</p>
<img src="/2022/10/02/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/mq-transaction.drawio.png" class="">



<p>缺点是，耦合度高，需要在业务系统中引入消息中间件，将导致系统复杂度增加。</p>
<p>&#x2F;&#x2F; todo</p>
<p>2PC&#x2F;3PC：依赖于数据库，能够很好的提供强一致性和强事务性，但延迟比较高，比较适合传统的单体应用，在同一个方法中存在跨库操作的情况，不适合高并发和高性能要求的场景。<br>TCC：适用于执行时间确定且较短，实时性要求高，对数据一致性要求高，比如互联网金融企业最核心的三个服务：交易、支付、账务。<br>本地消息表&#x2F;MQ 事务：适用于事务中参与方支持操作幂等，对一致性要求不高，业务上能容忍数据不一致到一个人工检查周期，事务涉及的参与方、参与环节较少，业务上有对账&#x2F;校验系统兜底。<br>Saga 事务：由于 Saga 事务不能保证隔离性，需要在业务层控制并发，适合于业务场景事务并发操作同一资源较少的情况。Saga 由于缺少预提交动作，导致补偿动作的实现比较麻烦，例如业务是发送短信，补偿动作则得再发送一次短信说明撤销，用户体验比较差。所以，Saga 事务较适用于补偿动作容易处理的场景</p>
<p>参考：</p>
<p><a href="https://docs.qq.com/doc/DY0VxSkVGWHFYSlZJ">https://docs.qq.com/doc/DY0VxSkVGWHFYSlZJ</a></p>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/ZooKeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98-%E5%AE%8C/28%20%E5%BD%BB%E5%BA%95%E6%8E%8C%E6%8F%A1%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86.md">https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/ZooKeeper%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98-%E5%AE%8C/28%20%E5%BD%BB%E5%BA%95%E6%8E%8C%E6%8F%A1%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86.md</a></p>
<p><a href="https://terwergreen.com/post/two-phase-commit-protocol-of-distributed-consistency-protocol.html">https://terwergreen.com/post/two-phase-commit-protocol-of-distributed-consistency-protocol.html</a></p>
<p><a href="https://blog.csdn.net/qq_34162294/article/details/120984951">https://blog.csdn.net/qq_34162294/article/details/120984951</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/142136446">https://zhuanlan.zhihu.com/p/142136446</a></p>
<p><a href="https://xiaomi-info.github.io/2020/01/02/distributed-transaction/">https://xiaomi-info.github.io/2020/01/02/distributed-transaction/</a></p>
]]></content>
      <categories>
        <category>分布式</category>
        <category>事务</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>分布式事务</tag>
      </tags>
  </entry>
  <entry>
    <title>系统设计-缓存问题</title>
    <url>/2019/12/07/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h1><p>设计一个缓存系统，不得不要考虑的问题就是：缓存穿透、缓存击穿与失效时的雪崩效应。</p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效（例如如果是redis服务器做缓存，服务器挂机了），请求全部转发到DB，DB瞬时压力过重雪崩。</p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>缓存失效时的雪崩效应对底层系统的冲击非常可怕。大多数系统设计者考虑用加锁或者队列的方式保证缓存的单线 程（进程）写，从而避免失效时大量的并发请求落到底层存储系统上。这里分享一个简单方案就时讲缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。</p>
<p>缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p>
<h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="使用互斥锁"><a href="#使用互斥锁" class="headerlink" title="使用互斥锁"></a>使用互斥锁</h4><p>在所有线程访问资源（如数据库）之间加一个中间件，当有只让一个线程去访问，将访问的结果赋值到特定位置，其他线程只需要拿第一个线程访问的结果。</p>
<p>参考singleFlight  <a href="https://segmentfault.com/a/1190000018464029">https://segmentfault.com/a/1190000018464029</a></p>
<h4 id="“提前”使用互斥锁-mutex-key"><a href="#“提前”使用互斥锁-mutex-key" class="headerlink" title="“提前”使用互斥锁(mutex key)"></a>“提前”使用互斥锁(mutex key)</h4><p>和 互斥锁一样，使用悲观锁</p>
<h4 id="永远不过期"><a href="#永远不过期" class="headerlink" title="永远不过期"></a>永远不过期</h4><p>1.不保证一致性。适合不会变动的数据。2.占用内存</p>
<h4 id="hystrix"><a href="#hystrix" class="headerlink" title="hystrix"></a>hystrix</h4><p>不懂，不了解，todo</p>
<h2 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p>缓存预热就是系统上线后，将相关的缓存数据在被访问前先加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。</p>
<h2 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h2><h2 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://cloud.tencent.com/developer/article/1636977">https://cloud.tencent.com/developer/article/1636977</a></p>
]]></content>
      <categories>
        <category>系统设计</category>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>系统设计</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式协调-分布式锁</title>
    <url>/2022/12/03/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>本质：占一个坑，这个坑可以是任何事物。例如我用一个本地文件作为占一个坑的标志，用一个内存地址作为占一坑的标志</p>
<h1 id="锁的演进"><a href="#锁的演进" class="headerlink" title="锁的演进"></a>锁的演进</h1><p>V1. 最简易的：内存地址（变量）</p>
<p>V2. 磁盘文件：判断一个文件是否存在</p>
<p>V3. 判断锁都是由使用者去检查，使用者去解锁，万一使用者异常退出没有解锁怎么办？优化下，给这个锁角色设置成协调者，由锁来通知使用者锁的使用情况。这样可以避免，占有锁的人宕机导致没有解锁的情况，锁的占有情况由协调者检查连接情况来判断。</p>
<p>V4. 之前的版本都是在单机下，为了在集群中共享这个锁，将这个”锁的机制”独立出来，让不同机器上的进程都能通过这个”锁”来协调。</p>
<p>v5. v4存在单节点问题。所以我们可以加上一些一致性共识，把这个协调者给做成分布式：为了方便。我们这里直接就使用zookeeper。</p>
<p>分布式锁其实就是，控制分布式系统不同进程共同访问共享资源的一种锁的实现。如果不同的系统或同一个系统的不同主机之间共享了某个临界资源，往往需要互斥来防止彼此干扰，以保证一致性。</p>
<h1 id="各种锁的原理（简易版）"><a href="#各种锁的原理（简易版）" class="headerlink" title="各种锁的原理（简易版）"></a>各种锁的原理（简易版）</h1><p>ps：这里做的只是一个小demo，帮助理解上面说锁的概念的本质，并非实际可以使用的锁！</p>
<h2 id="以内存作为锁（v1）"><a href="#以内存作为锁（v1）" class="headerlink" title="以内存作为锁（v1）"></a>以内存作为锁（v1）</h2><p>以某内存作为锁，那简单做就是使用某个变量的值作为锁。注意保证原子性。如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">学习笔记：</span></span><br><span class="line"><span class="comment">探究锁的本质，v1，使用一块内存来作为&quot;占坑标志&quot;</span></span><br><span class="line"><span class="comment">模拟抢占内存标志</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lock <span class="type">int32</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> count1 <span class="type">int</span></span><br><span class="line">	<span class="keyword">var</span> count2 <span class="type">int</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++ &#123;</span><br><span class="line">				count1++</span><br><span class="line">			&#125;</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line"></span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++ &#123;</span><br><span class="line">				myLock()</span><br><span class="line">				count2++</span><br><span class="line">				myUnlock()</span><br><span class="line">			&#125;</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;count without lock %d\ncount with lock %d\n&quot;</span>, count1, count2)</span><br><span class="line">	<span class="comment">//myLock()</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;lock, <span class="number">0</span>, <span class="number">1</span>) &#123; <span class="comment">// 抢占成功</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 自旋/阻塞等待唤醒，这里模拟一下就直接使用sleep</span></span><br><span class="line">		time.Sleep(<span class="number">10</span> * time.Millisecond)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myUnlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;lock, <span class="number">1</span>, <span class="number">0</span>) &#123; <span class="comment">//</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">&quot;err&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="以磁盘块作为锁（v2）"><a href="#以磁盘块作为锁（v2）" class="headerlink" title="以磁盘块作为锁（v2）"></a>以磁盘块作为锁（v2）</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">学习笔记：</span></span><br><span class="line"><span class="comment">探究锁的本质，v2，使用一个磁盘块来作为&quot;占坑标志&quot;</span></span><br><span class="line"><span class="comment">模拟抢占持久化介质标志</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lock <span class="type">string</span> = <span class="string">&quot;/tmp/lock&quot;</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> count1 <span class="type">int</span></span><br><span class="line">	<span class="keyword">var</span> count2 <span class="type">int</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++ &#123;</span><br><span class="line">				count1++</span><br><span class="line">			&#125;</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			myLock()</span><br><span class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++ &#123;</span><br><span class="line">				count2++</span><br><span class="line">			&#125;</span><br><span class="line">			myUnlock()</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;count without lock %d\ncount with lock %d&quot;</span>, count1, count2)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际不可能使用一个文件来作为锁，这里只是模拟一个锁持久化，模拟抢占磁盘块，因为linux是通过文件系统来管理磁盘块的。所以我们这里直接操作文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		_, err := os.OpenFile(lock, os.O_RDWR|os.O_CREATE|os.O_EXCL|os.O_APPEND, <span class="number">0666</span>)</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 模拟自旋和阻塞</span></span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myUnlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	os.Remove(lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="以协调者进程作为锁（v3）"><a href="#以协调者进程作为锁（v3）" class="headerlink" title="以协调者进程作为锁（v3）"></a>以协调者进程作为锁（v3）</h2><p>进程和进程之间通信的方式有很多种</p>
<ul>
<li>管道</li>
<li>消息队列</li>
<li>信号</li>
<li>共享内存</li>
<li>套接字</li>
</ul>
<p>这里我们使用套接字</p>
<p>ps : 这个只是一个demo ，实际还可以做成由协调者通知其他需要获取锁的进程，但是要注意避免羊群效应。</p>
<p>协调者服务器</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;os/signal&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;syscall&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	LockPath <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// 表示占用的锁，连接断开就删除</span></span><br><span class="line"></span><br><span class="line">	Addr     <span class="type">string</span></span><br><span class="line">	listener net.Listener</span><br><span class="line"></span><br><span class="line">	context context.Context</span><br><span class="line">	cancel  context.CancelFunc</span><br><span class="line"></span><br><span class="line">	mu sync.Mutex</span><br><span class="line">	wg sync.WaitGroup</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> Start() &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		s.wg.Add(<span class="number">1</span>)</span><br><span class="line">		s.LockServe()</span><br><span class="line">		s.wg.Done()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// debug 查看</span></span><br><span class="line">	<span class="comment">//go func() &#123;</span></span><br><span class="line">	<span class="comment">//	for &#123;</span></span><br><span class="line">	<span class="comment">//		s.mu.Lock()</span></span><br><span class="line">	<span class="comment">//		_, exit := s.LockPath[&quot;/lock&quot;]</span></span><br><span class="line">	<span class="comment">//		fmt.Println(exit)</span></span><br><span class="line">	<span class="comment">//		s.mu.Unlock()</span></span><br><span class="line">	<span class="comment">//		time.Sleep(500 * time.Millisecond)</span></span><br><span class="line">	<span class="comment">//	&#125;</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//&#125;()</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> Stop() &#123;</span><br><span class="line">	s.cancel()</span><br><span class="line">	s.listener.Close()</span><br><span class="line">	s.wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> LockServe() <span class="type">error</span> &#123;</span><br><span class="line">	s.LockPath = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:8080&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s.listener = listener</span><br><span class="line">	<span class="keyword">var</span> tempDelay time.Duration</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn, err := listener.Accept()</span><br><span class="line">		<span class="comment">// 直接仿照 net/http 包的异常处理</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-s.context.Done():</span><br><span class="line">				log.Println(err)</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> ne, ok := err.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class="line">				<span class="keyword">if</span> tempDelay == <span class="number">0</span> &#123;</span><br><span class="line">					tempDelay = <span class="number">5</span> * time.Millisecond</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					tempDelay *= <span class="number">2</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> max := <span class="number">1</span> * time.Second; tempDelay &gt; max &#123;</span><br><span class="line">					tempDelay = max</span><br><span class="line">				&#125;</span><br><span class="line">				time.Sleep(tempDelay)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">go</span> s.serve(conn)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	srv := Server&#123;&#125;</span><br><span class="line">	srv.context, srv.cancel = context.WithCancel(context.TODO())</span><br><span class="line"></span><br><span class="line">	srv.Start()</span><br><span class="line">	sig := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">	signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">	&lt;-sig</span><br><span class="line">	srv.Stop()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> serve(conn net.Conn) &#123;</span><br><span class="line">	s.wg.Add(<span class="number">1</span>)</span><br><span class="line">	s.a(conn)</span><br><span class="line">	s.wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> a(conn net.Conn) &#123;</span><br><span class="line"></span><br><span class="line">	log.Println(<span class="string">&quot;new connection&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 针对当前连接做发送和接受操作</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">16</span>, <span class="number">16</span>)</span><br><span class="line">		n, err := conn.Read(buf[:])</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;read from conn failed, err:%v\n&quot;</span>, err)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		recv := <span class="type">string</span>(buf[:n])</span><br><span class="line">		fmt.Printf(<span class="string">&quot;收到的数据：%v\n&quot;</span>, recv)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> resp []<span class="type">byte</span></span><br><span class="line"></span><br><span class="line">		s.mu.Lock()</span><br><span class="line">		_, ok := s.LockPath[recv]</span><br><span class="line">		<span class="keyword">if</span> ok &#123;</span><br><span class="line">			resp = []<span class="type">byte</span>(<span class="string">&quot;f&quot;</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			resp = []<span class="type">byte</span>(<span class="string">&quot;s&quot;</span>)</span><br><span class="line">			s.LockPath[recv] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">			<span class="keyword">defer</span> s.clean(recv)</span><br><span class="line">		&#125;</span><br><span class="line">		s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">		time.Sleep(<span class="number">2</span> * time.Second) <span class="comment">// 为了方便观察</span></span><br><span class="line"></span><br><span class="line">		log.Println(<span class="string">&quot;回复的数据：&quot;</span>, <span class="type">string</span>(resp))</span><br><span class="line">		_, err = conn.Write(resp)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;write from conn failed, err:%v\n&quot;</span>, err)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> clean(p <span class="type">string</span>) &#123;</span><br><span class="line">	s.mu.Lock()</span><br><span class="line">	<span class="built_in">delete</span>(s.LockPath, p)</span><br><span class="line">	s.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>客户端</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;os/signal&quot;</span></span><br><span class="line">	<span class="string">&quot;syscall&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">学习笔记：</span></span><br><span class="line"><span class="comment">探究锁的本质，v3，使用socket连接情况来作为判断使用锁的进程存活标志，这里直接使用内存（map+mutext）做为占坑标志</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">实验例子中可以调大sleep的时间间隔，可以看到，协程都是同时启动的，但是每次获得锁只有一个。</span></span><br><span class="line"><span class="comment">分成多个进程去启动使用，结果也是一样的，只有一个进程能获得锁</span></span><br><span class="line"><span class="comment">可以观察到</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(num <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;goroutine %d start\n&quot;</span>, num)</span><br><span class="line">			conn, err := myLock(<span class="string">&quot;/lock&quot;</span>)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				fmt.Print(err)</span><br><span class="line">			&#125;</span><br><span class="line">			log.Printf(<span class="string">&quot;goroutine %d hold lock\n&quot;</span>, num)</span><br><span class="line">			time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">			log.Printf(<span class="string">&quot;goroutine %d release lock\n&quot;</span>, num)</span><br><span class="line">			myUnlock(conn)</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sig := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">	signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">	&lt;-sig</span><br><span class="line"></span><br><span class="line">	<span class="comment">//conn, err := myLock(&quot;/lock&quot;)</span></span><br><span class="line">	<span class="comment">//if err != nil &#123;</span></span><br><span class="line">	<span class="comment">//	fmt.Print(err)</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="comment">//log.Println(conn)</span></span><br><span class="line">	<span class="comment">//myUnlock(conn)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myLock</span><span class="params">(path <span class="type">string</span>)</span></span> (conn net.Conn, err <span class="type">error</span>) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> recv <span class="type">string</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">//log.Println(&quot;debug client dial&quot;)</span></span><br><span class="line">		conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:8080&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//log.Println(&quot;debug client write&quot;)</span></span><br><span class="line">		nn, err := conn.Write([]<span class="type">byte</span>(path))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> nn &lt;= <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//log.Println(&quot;debug client write char num&quot;, nn)</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> buf = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">16</span>, <span class="number">16</span>)</span><br><span class="line">		err = conn.SetDeadline(time.Now().Add(<span class="number">10</span> * time.Second))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Println(<span class="string">&quot;setdedline&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//log.Println(&quot;debug client read&quot;)</span></span><br><span class="line">		n, err := conn.Read(buf)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Println(err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">			recv = <span class="type">string</span>(buf[:n])</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//log.Println(&quot;debug client read &quot;, recv)</span></span><br><span class="line">		<span class="keyword">if</span> recv == <span class="string">&quot;s&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> conn, <span class="literal">nil</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			conn.Close()</span><br><span class="line">			time.Sleep(<span class="number">1000</span> * time.Millisecond)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myUnlock</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">	conn.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="以协调者服务器作为锁（v4）"><a href="#以协调者服务器作为锁（v4）" class="headerlink" title="以协调者服务器作为锁（v4）"></a>以协调者服务器作为锁（v4）</h2><p>和v3 一样，只是把锁这个协调者和使用锁的进程分开部署</p>
<h2 id="以协调者的集群作为锁（v5）"><a href="#以协调者的集群作为锁（v5）" class="headerlink" title="以协调者的集群作为锁（v5）"></a>以协调者的集群作为锁（v5）</h2><p>加上协调者，其实就是把协调者服务进程改成集群，至于集群的设计方式，有多种，只要满足分布式共识即可。例如可以使用raft 去实现。</p>
<h1 id="各种分布式锁的实现"><a href="#各种分布式锁的实现" class="headerlink" title="各种分布式锁的实现"></a>各种分布式锁的实现</h1><p>实现分布式锁有多种风格</p>
<ul>
<li>一种是通过原子性，来保证只有一个人抢占到锁。例如 redis分布式锁</li>
<li>一种是通过串行化，来保证操作的顺序性。例如 zookeeper分布式锁</li>
</ul>
<h1 id="redis分布式锁"><a href="#redis分布式锁" class="headerlink" title="redis分布式锁"></a>redis分布式锁</h1><p>代码：<a href="https://github.com/donscoco/goboot/blob/main/util/lock/redis/lock.go">https://github.com/donscoco/goboot/blob/main/util/lock/redis/lock.go</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> redis</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/go-redis/redis&quot;</span></span><br><span class="line">	<span class="string">&quot;goboot/config&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化创建redis</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> DefaultRedisLocker *RedisLocker</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RedisLocker <span class="keyword">struct</span> &#123;</span><br><span class="line">	Username <span class="type">string</span></span><br><span class="line">	Password <span class="type">string</span></span><br><span class="line">	Addrs    []<span class="type">string</span></span><br><span class="line">	Database <span class="type">int</span></span><br><span class="line"></span><br><span class="line">	isCluster <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// todo 根据 redis.ClusterOptions 的配置项添加</span></span><br><span class="line">	DialTimeout        <span class="type">int</span></span><br><span class="line">	ReadTimeout        <span class="type">int</span></span><br><span class="line">	WriteTimeout       <span class="type">int</span></span><br><span class="line">	MaxRetries         <span class="type">int</span></span><br><span class="line">	PoolSize           <span class="type">int</span></span><br><span class="line">	IdleTimeout        <span class="type">int</span></span><br><span class="line">	IdleCheckFrequency <span class="type">int</span></span><br><span class="line"></span><br><span class="line">	clusterClient *redis.ClusterClient</span><br><span class="line">	sigleClient   *redis.Client</span><br><span class="line"></span><br><span class="line">	Expire   <span class="type">int</span></span><br><span class="line">	LockName <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">(conf *config.Config, path <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">	DefaultRedisLocker, err = CreateRedisLocker(conf, path, <span class="string">&quot;defaultlock&quot;</span>, <span class="number">160</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateRedisLocker</span><span class="params">(config *config.Config, path <span class="type">string</span>, LockName <span class="type">string</span>, Expire <span class="type">int</span>)</span></span> (l *RedisLocker, err <span class="type">error</span>) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读取配置</span></span><br><span class="line">	l = <span class="built_in">new</span>(RedisLocker)</span><br><span class="line">	err = config.GetByScan(path, l)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(l.Addrs) &gt; <span class="number">1</span> &#123;</span><br><span class="line">		l.isCluster = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建client</span></span><br><span class="line">		opt := &amp;redis.ClusterOptions&#123;</span><br><span class="line">			Addrs:        l.Addrs,</span><br><span class="line">			Password:     l.Password,</span><br><span class="line">			DialTimeout:  time.Second * time.Duration(l.DialTimeout),</span><br><span class="line">			ReadTimeout:  time.Second * time.Duration(l.ReadTimeout),</span><br><span class="line">			WriteTimeout: time.Second * time.Duration(l.WriteTimeout),</span><br><span class="line">			MaxRetries:   l.MaxRetries,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(l.Password) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			opt.Password = l.Password</span><br><span class="line">		&#125;</span><br><span class="line">		l.clusterClient = redis.NewClusterClient(opt)</span><br><span class="line">		cmd := l.clusterClient.Ping()</span><br><span class="line">		<span class="keyword">if</span> cmd.Val() != <span class="string">&quot;PONG&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, cmd.Err()</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(l.Addrs) == <span class="number">1</span> &#123; <span class="comment">// 单节点</span></span><br><span class="line">		l.isCluster = <span class="literal">false</span></span><br><span class="line">		opt := &amp;redis.Options&#123;</span><br><span class="line">			Addr: l.Addrs[<span class="number">0</span>],</span><br><span class="line">			<span class="comment">//Password:     p.Password,</span></span><br><span class="line">			DB:           l.Database,</span><br><span class="line">			DialTimeout:  time.Second * time.Duration(l.DialTimeout),</span><br><span class="line">			ReadTimeout:  time.Second * time.Duration(l.ReadTimeout),</span><br><span class="line">			WriteTimeout: time.Second * time.Duration(l.WriteTimeout),</span><br><span class="line">			MaxRetries:   l.MaxRetries,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(l.Password) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			opt.Password = l.Password</span><br><span class="line">		&#125;</span><br><span class="line">		l.sigleClient = redis.NewClient(opt)</span><br><span class="line"></span><br><span class="line">		cmd := l.sigleClient.Ping()</span><br><span class="line">		<span class="keyword">if</span> cmd.Val() != <span class="string">&quot;PONG&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, cmd.Err()</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// empty addr</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	l.Expire = Expire</span><br><span class="line">	l.LockName = LockName</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// trylock</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *RedisLocker)</span></span> TryLock() (isLocked <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	currentTime := time.Now().Unix()</span><br><span class="line">	<span class="keyword">var</span> bcmd *redis.BoolCmd</span><br><span class="line">	<span class="keyword">if</span> l.isCluster &#123;</span><br><span class="line">		bcmd = l.clusterClient.SetNX(l.LockName, currentTime, time.Duration(l.Expire)*time.Second)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		bcmd = l.sigleClient.SetNX(l.LockName, currentTime, time.Duration(l.Expire)*time.Second)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bcmd.Val(), bcmd.Err()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// unlock</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *RedisLocker)</span></span> UnLock() (err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> l.isCluster &#123;</span><br><span class="line">		<span class="keyword">return</span> l.clusterClient.Del(l.LockName).Err()</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> l.sigleClient.Del(l.LockName).Err()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>











<h1 id="zookeeper分布式锁"><a href="#zookeeper分布式锁" class="headerlink" title="zookeeper分布式锁"></a>zookeeper分布式锁</h1><ul>
<li>zk本身是强一致性，非常试合作为分布式锁</li>
<li>实现简单，且有现成的监听通知机制，就避免不断轮询锁的状态</li>
<li>临时节点的特性「会话中断，节点删除」，使得锁的释放更简单</li>
<li>使用watcher能很好地避免羊群效应</li>
</ul>
<img src="/2022/12/03/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/zk-distribute-lock.drawio.png" class="">



<p>流程如下：</p>
<p>加锁：</p>
<ul>
<li>创建临时有序节点 a</li>
<li>取出所有子节点<ul>
<li>找到最小 b</li>
<li>找到比当前的临时有序节点小的最大值 c</li>
</ul>
</li>
<li>如果a是最小的节点，则表示获取到锁</li>
<li>如果a不是最小的节点，则watch，为了避免羊群效应，watch b节点<br>  &#x2F;&#x2F; 此处如果有延时，上一个节点 在此刻被删除，自己最小却无法实现监听</li>
<li>&#x2F;&#x2F; 需要再次判断下上一个节点还存不存在<ul>
<li>存在，没有获得锁，等待获得锁通知</li>
<li>不存在，说明上一个已经退出了。那么我就是最小的了。直接获得锁，返回，ps：这里有可能最小的没有退出，但是我的上一个节点已经宕机退出了。所以这里最好还是再次获得所有节点，确认下自己是不是最小的。</li>
</ul>
</li>
</ul>
<p>解锁：</p>
<ul>
<li>直接delete 节点</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/samuel/go-zookeeper/zk&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;os/signal&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">	<span class="string">&quot;syscall&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	c, _, err := zk.Connect([]<span class="type">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;192.168.2.128:2181&quot;</span>,</span><br><span class="line">		<span class="string">&quot;192.168.2.128:2182&quot;</span>,</span><br><span class="line">		<span class="string">&quot;192.168.2.128:2183&quot;</span>&#125;, time.Second) <span class="comment">//*10)</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	locker, err := NewLocker(c, <span class="string">&quot;/lock&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 模拟10个协程/进程/服务器 请求分布式锁</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				locker.Lock()</span><br><span class="line">				log.Printf(<span class="string">&quot;进程%d 执行业务逻辑&quot;</span>, n)</span><br><span class="line">				time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">				locker.Unlock()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sig := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">	signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">	&lt;-sig</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Locker <span class="keyword">struct</span> &#123;</span><br><span class="line">	Conn   *zk.Conn</span><br><span class="line">	path   <span class="type">string</span></span><br><span class="line">	prefix <span class="type">string</span></span><br><span class="line"></span><br><span class="line">	lockPath <span class="type">string</span></span><br><span class="line">	seq      <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLocker</span><span class="params">(c *zk.Conn, rootpath <span class="type">string</span>)</span></span> (locker *Locker, err <span class="type">error</span>) &#123;</span><br><span class="line">	locker = <span class="built_in">new</span>(Locker)</span><br><span class="line">	locker.Conn = c</span><br><span class="line">	locker.path = rootpath</span><br><span class="line">	locker.prefix = fmt.Sprintf(<span class="string">&quot;%s/lock-&quot;</span>, locker.path)</span><br><span class="line"></span><br><span class="line">	isExists, _, err := locker.Conn.Exists(locker.path)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> isExists &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">// 创建父节点</span></span><br><span class="line">		_, err := locker.Conn.Create(locker.path, <span class="literal">nil</span>, <span class="number">0</span>, zk.WorldACL(zk.PermAll))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Locker)</span></span> Lock() (err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 创建临时有序节点</span></span><br><span class="line">	<span class="comment">// 取出所有子节点</span></span><br><span class="line">	<span class="comment">// 判断最小的， //如果是最小的节点，则表示获取到锁</span></span><br><span class="line">	<span class="comment">// 最小表示获得锁，返回</span></span><br><span class="line">	<span class="comment">// 不是最小的，注册监听</span></span><br><span class="line">	<span class="comment">//此处如果有延时，上一个节点 在此刻被删除，自己最小却无法实现监听</span></span><br><span class="line">	<span class="comment">// 需要再次判断下上一个节点还存不存在</span></span><br><span class="line">	<span class="comment">// 存在，没有获得锁，等待获得锁通知</span></span><br><span class="line">	<span class="comment">// 不存在，说明上一个已经退出了。那么我就是最小的了。直接获得锁，返回，ps：这里有可能最小的没有退出，但是我的上一个节点已经退出了。所以这里最好还是再次获得所有节点，确认下自己是不是最小的。</span></span><br><span class="line"></span><br><span class="line">	path, err := l.Conn.CreateProtectedEphemeralSequential(l.prefix, <span class="literal">nil</span>, zk.WorldACL(zk.PermAll))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	seq, err := parseSeq(path)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		children, _, err := l.Conn.Children(l.path)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		lowestSeq := seq</span><br><span class="line">		prevSeq := <span class="number">-1</span></span><br><span class="line">		prevSeqPath := <span class="string">&quot;&quot;</span></span><br><span class="line">		<span class="keyword">for</span> _, p := <span class="keyword">range</span> children &#123; <span class="comment">// 遍历目标：1。找到最小的，2。找到比自己的集合中最大的那个</span></span><br><span class="line">			s, err := parseSeq(p)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> s &lt; lowestSeq &#123;</span><br><span class="line">				lowestSeq = s</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> s &lt; seq &amp;&amp; s &gt; prevSeq &#123;</span><br><span class="line">				prevSeq = s</span><br><span class="line">				prevSeqPath = p</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> seq == lowestSeq &#123; <span class="comment">// 没有找到比自己还小的，说明自己是队首，直接获得锁</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 没有获得锁，watch等待通知获得锁，为了避免羊群效应，watch自己前面的那个人</span></span><br><span class="line">		_, _, ch, err := l.Conn.GetW(l.path + <span class="string">&quot;/&quot;</span> + prevSeqPath)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err != zk.ErrNoNode &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err == zk.ErrNoNode &#123; <span class="comment">// 这里可能出现要watch那个节点退出了。所以要再次看下所有孩子节点的最小</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ev := &lt;-ch</span><br><span class="line">		<span class="keyword">if</span> ev.Err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> ev.Err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	l.seq = seq</span><br><span class="line">	l.lockPath = path</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Locker)</span></span> Unlock() (err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> l.lockPath == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> zk.ErrNotLocked</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := l.Conn.Delete(l.lockPath, <span class="number">-1</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	l.lockPath = <span class="string">&quot;&quot;</span></span><br><span class="line">	l.seq = <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseSeq</span><span class="params">(path <span class="type">string</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	parts := strings.Split(path, <span class="string">&quot;-&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> strconv.Atoi(parts[<span class="built_in">len</span>(parts)<span class="number">-1</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>分布式</category>
        <category>协调</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>分布式</tag>
        <tag>分布式协调</tag>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title>服务发现</title>
    <url>/2022/10/07/%E5%88%86%E5%B8%83%E5%BC%8F%E8%B0%83%E7%94%A8-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>什么是服务发现：在传统的服务调用中，需要知道目标服务的地址，也就是ip和端口。服务发现就是为了让调用方只通过服务的名字就能够获得服务。</p>
<p>为什么需要服务发现：在虚拟化或容器化的环境中，服务实例的启动和销毁是很频繁的，服务地址在动态的变化。服务发现提供了一种服务发布与查找的协调机制。</p>
<p>注册中心：因为服务进程的地址动态变化，所以需要避免服务调用方直接和服务提供方的接触，相当于在两者之间加了一个中间件；调用方不直接与服务提供方接触，而是大家共同约定一个地方去沟通。服务提供方把自己的信息交给这个进程或者系统，服务调用方通过这个进程或者系统询问服务的地址，然后调用，这个进程或系统就是注册中心。</p>
<p>服务发现本质：服务发现的本质就是让提供服务的进程把自己的地址端口信息写入到一个调用方会去询问的内存，而服务调用方直接访问这部分内存获取服务提供方的地址并调用。（也可以是代理转发等）</p>
<p>分布式协调服务：一个实现分区容错性，可用性，一致性，和分布式共识的系统。如zookeeper，etcd。（根据BASE理论，这里的一致性是指最终一致性，而且这个服务必然是多个节点。）；说得笼统一点就是有这么一个系统，这个系统有多个节点用来保证可用性和分区容错性，各个节点之间通过数据顺序性协商算法或协议相互沟通，达到最终一致性。</p>
<p>服务发现的一般结构：</p>
<img src="/2022/10/07/%E5%88%86%E5%B8%83%E5%BC%8F%E8%B0%83%E7%94%A8-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/service-discovery.drawio.png" class="">







<h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><p>首先需要设计一个用于协调server和client的协调服务，这里不单独开发，直接使用zookeeper。</p>
<p>然后我们client调用服务，就需要知道目标服务器的地址，所以，server提供的”服务信息”需要同步到协调者。</p>
<p>client需要保存好”服务信息”，所以client需要维护一个集合，来和协调者上的”服务信息”同步，所以client的需要watch协调者上的节点。来维护同步自己的”服务者集合”。</p>
<p>后续client每次调用服务，只需要在这个集合中取出一个服务者信息调用即可。</p>
<p>先设计用于和zookeeper交互的接口</p>
<p>代码详见：</p>
<p><a href="https://github.com/donscoco/goboot/tree/main/coordinator">https://github.com/donscoco/goboot/tree/main/coordinator</a></p>
<p><a href="https://github.com/donscoco/goboot/tree/main/rpc">https://github.com/donscoco/goboot/tree/main/rpc</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-coodinator</span><br><span class="line">	|-mzk  <span class="comment">## 该包下的代码用于和zookeeper交互，实现watch等接口</span></span><br><span class="line">		|-coodinator.go</span><br><span class="line">		|-node.go</span><br><span class="line">-rpc</span><br><span class="line">	|-mclient</span><br><span class="line">		|-client.go</span><br><span class="line">		|-pool.go</span><br><span class="line">	|-mserver</span><br><span class="line">		|-server.go</span><br></pre></td></tr></table></figure>



<p>coodinator.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mzk</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/samuel/go-zookeeper/zk&quot;</span></span><br><span class="line">	<span class="string">&quot;goboot/config&quot;</span></span><br><span class="line">	<span class="string">&quot;goboot/log/mlog&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	https://pkg.go.dev/github.com/samuel/go-zookeeper/zk</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logger = mlog.NewLogger(<span class="string">&quot;coordinator-zk&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ZookeeperCoordinator <span class="keyword">struct</span> &#123;</span><br><span class="line">	config <span class="keyword">struct</span> &#123;</span><br><span class="line">		Addrs   []<span class="type">string</span></span><br><span class="line">		Timeout <span class="type">int</span></span><br><span class="line">		Path    <span class="type">string</span></span><br><span class="line">	&#125;</span><br><span class="line">	conn   *zk.Conn</span><br><span class="line">	events &lt;-<span class="keyword">chan</span> zk.Event</span><br><span class="line"></span><br><span class="line">	<span class="comment">//closeAction chan struct&#123;&#125;</span></span><br><span class="line">	<span class="comment">//closeChild map[string]*Node</span></span><br><span class="line">	context context.Context</span><br><span class="line">	cancel  context.CancelFunc</span><br><span class="line"></span><br><span class="line">	sync.WaitGroup</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateCoordinator</span><span class="params">(config *config.Config, path <span class="type">string</span>)</span></span> (zkc *ZookeeperCoordinator, err <span class="type">error</span>) &#123;</span><br><span class="line">	zkc = <span class="built_in">new</span>(ZookeeperCoordinator)</span><br><span class="line">	err = config.GetByScan(path, &amp;zkc.config)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	zkc.conn, zkc.events, err = zk.Connect(zkc.config.Addrs, time.Duration(zkc.config.Timeout)*time.Second)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// todo</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化</span></span><br><span class="line">	<span class="comment">//zkc.closeAction = make(chan struct&#123;&#125;, 1)</span></span><br><span class="line">	zkc.context, zkc.cancel = context.WithCancel(context.TODO())</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> zkc, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(zkc *ZookeeperCoordinator)</span></span> Start() (err <span class="type">error</span>) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//检查</span></span><br><span class="line">	isexist, _, err := zkc.conn.Exists(zkc.config.Path)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> isexist &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;path[%s]  exist&quot;</span>, zkc.config.Path)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> flags <span class="type">int32</span> = <span class="number">0</span></span><br><span class="line">	<span class="comment">//flags = zk.FlagEphemeral</span></span><br><span class="line">	<span class="comment">//创建对应的 node</span></span><br><span class="line">	path, err := zkc.conn.Create(zkc.config.Path, <span class="literal">nil</span>, flags, zk.WorldACL(zk.PermAll))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> path != zkc.config.Path &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;path error &quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		zkc.Add(<span class="number">1</span>)</span><br><span class="line">		zkc.Worker()</span><br><span class="line">		zkc.Done()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(zkc *ZookeeperCoordinator)</span></span> Stop() &#123;</span><br><span class="line">	zkc.cancel()</span><br><span class="line"></span><br><span class="line">	zkc.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(zkc *ZookeeperCoordinator)</span></span> Worker() &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> event, ok := &lt;-zkc.events:</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				<span class="comment">//todo</span></span><br><span class="line">			&#125;</span><br><span class="line">			logger.Debugf(<span class="string">&quot;recv :%+v&quot;</span>, event)</span><br><span class="line">			<span class="comment">// todo 收到 对应node的 事件，做相应处理</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-zkc.context.Done():</span><br><span class="line">			<span class="comment">// 收到关闭通知，关闭下游</span></span><br><span class="line">			zkc.conn.Close()</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(zkc *ZookeeperCoordinator)</span></span> CreateNode(path <span class="type">string</span>, data []<span class="type">byte</span>, isPersisted <span class="type">bool</span>) (n *Node, err <span class="type">error</span>) &#123;</span><br><span class="line"></span><br><span class="line">	n = <span class="built_in">new</span>(Node)</span><br><span class="line">	n.path = path</span><br><span class="line">	n.absPath = zkc.config.Path + n.path</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 默认是临时节点</span></span><br><span class="line">	<span class="keyword">var</span> flags <span class="type">int32</span></span><br><span class="line">	flags = zk.FlagEphemeral</span><br><span class="line">	<span class="comment">// 持久化节点</span></span><br><span class="line">	<span class="keyword">if</span> isPersisted &#123;</span><br><span class="line">		flags = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	_, err = zkc.conn.Create(n.absPath, data, flags, zk.WorldACL(zk.PermAll))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	isExist, stat, err := zkc.conn.Exists(n.absPath)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !isExist &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;path[%s] not exist&quot;</span>, path)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	n.stat = stat</span><br><span class="line">	n.zk = zkc</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(zkc *ZookeeperCoordinator)</span></span> GetNode(path <span class="type">string</span>) (n *Node, err <span class="type">error</span>) &#123;</span><br><span class="line">	n = <span class="built_in">new</span>(Node)</span><br><span class="line">	n.path = path</span><br><span class="line">	n.absPath = zkc.config.Path + n.path</span><br><span class="line"></span><br><span class="line">	isExist, stat, err := zkc.conn.Exists(n.absPath)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !isExist &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;path[%s] not exist&quot;</span>, path)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	n.stat = stat</span><br><span class="line">	n.zk = zkc</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(zkc *ZookeeperCoordinator)</span></span> CreateNodeIfNotExist(path <span class="type">string</span>, data []<span class="type">byte</span>, isPersisted <span class="type">bool</span>) (n *Node, err <span class="type">error</span>) &#123;</span><br><span class="line">	isExist, stat, err := zkc.conn.Exists(zkc.config.Path + path)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> isExist &#123;</span><br><span class="line">		n = <span class="built_in">new</span>(Node)</span><br><span class="line">		n.path = path</span><br><span class="line">		n.absPath = zkc.config.Path + path</span><br><span class="line">		n.stat = stat</span><br><span class="line">		n.zk = zkc</span><br><span class="line">		<span class="comment">//n, err = zkc.GetNode(zkc.config.Path + n.path)</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		n, err = zkc.CreateNode(path, data, isPersisted)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(zkc *ZookeeperCoordinator)</span></span> Exist(path <span class="type">string</span>) (<span class="type">bool</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	isExist, _, err := zkc.conn.Exists(zkc.config.Path + path)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> isExist, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(zkc *ZookeeperCoordinator)</span></span> Lookup(path <span class="type">string</span>) (n *Node) &#123;</span><br><span class="line">	n = <span class="built_in">new</span>(Node)</span><br><span class="line">	n.path = path</span><br><span class="line">	n.absPath = zkc.config.Path + n.path</span><br><span class="line">	n.zk = zkc</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(zkc *ZookeeperCoordinator)</span></span> GetContext() context.Context &#123;</span><br><span class="line">	<span class="keyword">return</span> zkc.context</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(zkc *ZookeeperCoordinator)</span></span> GetConn() *zk.Conn &#123;</span><br><span class="line">	<span class="keyword">return</span> zkc.conn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// todo 递归创建节点</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>node.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mzk</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/samuel/go-zookeeper/zk&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">	path    <span class="type">string</span></span><br><span class="line">	absPath <span class="type">string</span></span><br><span class="line">	stat    *zk.Stat</span><br><span class="line"></span><br><span class="line">	zk *ZookeeperCoordinator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span></span> Create(path <span class="type">string</span>, data []<span class="type">byte</span>, isPersisted <span class="type">bool</span>) (*Node, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> n.zk.CreateNode(n.path+path, data, isPersisted)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span></span> CreateIfNotExist(path <span class="type">string</span>, data []<span class="type">byte</span>, isPersisted <span class="type">bool</span>) (*Node, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> n.zk.CreateNodeIfNotExist(n.path+path, data, isPersisted)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span></span> Get() ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	data, stat, err := n.zk.conn.Get(n.absPath)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		n.stat = stat</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> data, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span></span> Set(data []<span class="type">byte</span>) (err <span class="type">error</span>) &#123;</span><br><span class="line">	stat, err := n.zk.conn.Set(n.absPath, data, n.stat.Version)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		n.stat = stat</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span></span> GetChildren() (cNodes []<span class="type">string</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	cNodes, _, err = n.zk.conn.Children(n.absPath)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span></span> GetChildrenNodes() (cNodes []*Node, err <span class="type">error</span>) &#123;</span><br><span class="line">	cNodesName, _, err := n.zk.conn.Children(n.absPath)</span><br><span class="line">	<span class="keyword">for</span> _, path := <span class="keyword">range</span> cNodesName &#123;</span><br><span class="line">		cnode, err := n.zk.GetNode(n.path + <span class="string">&quot;/&quot;</span> + path)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		cNodes = <span class="built_in">append</span>(cNodes, cnode)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span></span> Remove() <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> n.zk.conn.Delete(n.absPath, n.stat.Version)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span></span> Refresh() <span class="type">error</span> &#123;</span><br><span class="line">	exist, stat, err := n.zk.conn.Exists(n.absPath)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !exist &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;path[%s] not exist&quot;</span>, n.absPath)</span><br><span class="line">	&#125;</span><br><span class="line">	n.stat = stat</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span></span> Watch(context context.Context, watchEvent <span class="type">int</span>, callback <span class="function"><span class="keyword">func</span><span class="params">(*CallbackParam)</span></span> <span class="type">error</span>) (err <span class="type">error</span>) &#123;</span><br><span class="line">	conn := n.zk.conn</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> stat *zk.Stat</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> ExistEvent &lt;-<span class="keyword">chan</span> zk.Event</span><br><span class="line">	<span class="keyword">var</span> DataEvent &lt;-<span class="keyword">chan</span> zk.Event</span><br><span class="line">	<span class="keyword">var</span> ChildEvent &lt;-<span class="keyword">chan</span> zk.Event</span><br><span class="line">	<span class="keyword">var</span> exist <span class="type">bool</span></span><br><span class="line">	<span class="keyword">var</span> data []<span class="type">byte</span></span><br><span class="line">	<span class="keyword">var</span> child []<span class="type">string</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> watchEvent&amp;EventCreate &gt; <span class="number">0</span> || watchEvent&amp;EventDelete &gt; <span class="number">0</span> &#123;</span><br><span class="line">		exist, stat, ExistEvent, err = conn.ExistsW(n.absPath)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> watchEvent&amp;EventDataChange &gt; <span class="number">0</span> &#123;</span><br><span class="line">		data, stat, DataEvent, err = conn.GetW(n.absPath)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> watchEvent&amp;EventChildChange &gt; <span class="number">0</span> &#123;</span><br><span class="line">		child, stat, ChildEvent, err = conn.ChildrenW(n.absPath)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	n.stat = stat</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> e := &lt;-ExistEvent:</span><br><span class="line">			<span class="comment">// 检查</span></span><br><span class="line">			<span class="keyword">if</span> e.Type != zk.EventNodeCreated || e.Type != zk.EventNodeDeleted &#123;</span><br><span class="line">				<span class="comment">// todo</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 参数</span></span><br><span class="line">			et := <span class="built_in">new</span>(CallbackParam)</span><br><span class="line">			<span class="keyword">if</span> e.Type == zk.EventNodeCreated &#123;</span><br><span class="line">				et.EventType = EventCreate</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> e.Type == zk.EventNodeDeleted &#123;</span><br><span class="line">				et.EventType = EventDelete</span><br><span class="line">			&#125;</span><br><span class="line">			et.Data = exist <span class="comment">// data是数据改变前的</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 处理</span></span><br><span class="line">			err = callback(et)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// watch</span></span><br><span class="line">			exist, stat, ExistEvent, err = conn.ExistsW(n.absPath)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> e := &lt;-DataEvent:</span><br><span class="line">			<span class="keyword">if</span> e.Type != zk.EventNodeDataChanged &#123;</span><br><span class="line">				<span class="comment">// todo</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			et := <span class="built_in">new</span>(CallbackParam)</span><br><span class="line">			et.EventType = EventDataChange</span><br><span class="line">			et.Data = data <span class="comment">// data是数据改变前的</span></span><br><span class="line"></span><br><span class="line">			err = callback(et)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			data, stat, DataEvent, err = conn.GetW(n.absPath)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">			n.stat = stat</span><br><span class="line">		<span class="keyword">case</span> e := &lt;-ChildEvent:</span><br><span class="line">			<span class="comment">// 检查</span></span><br><span class="line">			<span class="keyword">if</span> e.Type != zk.EventNodeChildrenChanged &#123;</span><br><span class="line">				<span class="comment">// todo</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 参数</span></span><br><span class="line">			et := <span class="built_in">new</span>(CallbackParam)</span><br><span class="line">			et.EventType = EventChildChange</span><br><span class="line">			et.Data = child <span class="comment">// data是数据改变前的</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 处理</span></span><br><span class="line">			err = callback(et)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// watch</span></span><br><span class="line">			child, stat, ChildEvent, err = conn.ChildrenW(n.absPath)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">			n.stat = stat</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> &lt;-context.Done():</span><br><span class="line">			<span class="comment">// 关闭下游</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CallbackParam <span class="keyword">struct</span> &#123;</span><br><span class="line">	EventType <span class="type">int</span></span><br><span class="line">	Data      <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>分布式</category>
        <category>服务发现</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>分布式</tag>
        <tag>服务发现</tag>
        <tag>分布式调用</tag>
      </tags>
  </entry>
  <entry>
    <title>redis</title>
    <url>/2022/10/05/redis/</url>
    <content><![CDATA[<p>常用redis命令手册：<a href="http://doc.redisfans.com/">http://doc.redisfans.com/</a></p>
<h1 id="基本数据结构和应用"><a href="#基本数据结构和应用" class="headerlink" title="基本数据结构和应用"></a>基本数据结构和应用</h1><p>Redis 提供存储的5种基本数据结构：string，list，set，map，zset</p>
<p>下面是redis常见的应用场景：</p>
<p><strong>缓存</strong></p>
<p>可以string直接缓存整个对象，例如json，或者自定义的分隔符等</p>
<p>可以hash缓存字段经常变动的对象。例如购物车这种。</p>
<p><strong>计数</strong></p>
<p>因为 Redis 处理命令是单线程，所以执行命令的过程是原子的。因此 String 数据类型适合计数场景，比如计算访问次数、点赞、转发、库存数量等等。</p>
<p><strong>点赞</strong></p>
<p>Set 类型可以保证一个用户只能点一个赞，例如以文章id作为key，用户id作为val。</p>
<p><strong>排重</strong></p>
<p>Set的不可重复特性</p>
<p><strong>共同关注</strong></p>
<p>Set 类型支持交集运算，所以可以用来计算共同关注的好友、公众号等。</p>
<p><strong>分布式锁</strong></p>
<p>SET 命令有个 NX 参数可以实现「key不存在才插入」，可以用它来实现分布式锁：</p>
<p><strong>共享 Session 信息</strong></p>
<p><strong>排行榜</strong></p>
<p>利用zset有序特性</p>
<p><strong>排序</strong></p>
<p>利用zset 有序特性</p>
<p><strong>统计签到（二值类数值存储）</strong></p>
<p>利用bitmap 的bit 数组的有序性和二值性。</p>
<p><strong>判断用户是否登陆（二值类数值存储）</strong></p>
<p>利用bitmap存储数据的二值性，用户可以用id代表数组索引</p>
<p><strong>uv统计</strong></p>
<p>使用hyperloglog命令</p>
<p><strong>地理位置计算</strong></p>
<p>使用geo命令</p>
<p><strong>消息队列</strong></p>
<p>利用list的存储数据的有序性（左边进，右边出，先进先出）</p>
<p><strong>延时队列</strong></p>
<p>利用zset的score特性，按照时间来，相当于优先队列。</p>
<p><strong>进程通信</strong></p>
<p>发布订阅组件</p>
<p><strong>限流</strong></p>
<h1 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h1><p>在平时的开发过程中，会有一些bool类型数据需要存取，比如用户一年的签到记录，要记录365天。如果直接使用int或者map记录，每个用户要记录365，当用户数很多时，需要的存储空间也会很大。为了解决这个问题，可以使用redis的位图。</p>
<p>位图的优势在于存取 二值 类型的信息，可以节省很多存储空间</p>
<p>位图的特性保存的主要有两个信息，一个是本身是数组的”顺序信息”，一个是bit数据的”二值信息”</p>
<p>所以对于365天的时间”顺序信息”，每天是否签到的”二值类信息”的场景非常适合。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>setbit</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setbit key offset value</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; setbit key1 1 1 <span class="comment">## 设置索引1（第二个位置的bit）的值为1</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit key1 7 1 <span class="comment">## 设置索引7（第八个位置的bit）的值为1</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit key1 6 0 <span class="comment">## 设置索引6（第七个位置的bit）的值为0</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit key1 14 1 <span class="comment">## 设置索引14（第七个位置的bit）的值为1</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit key1 9 1 <span class="comment">## 设置索引9（第七个位置的bit）的值为1</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">&quot;AB&quot;</span></span><br></pre></td></tr></table></figure>



<p>getbit</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">getbit key offset</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; getbit key1 1 <span class="comment">## 获取索引1（第二个位置的bit）的值</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit key1 7 <span class="comment">## 获取索引7（第八个位置的bit）的值</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit key1 6 <span class="comment">## 获取索引6（第七个位置的bit）的值</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>



<p>bitcount</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bitcount key [start end]  <span class="comment">## start和end指的是string的[]byte索引位置，并非bit位置。例如 0 1 是值0号索引和1号索引中的bit个数</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; bitcount key1 <span class="comment">## 获取整个key1 字符串的bit个数</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; bitcount key1 0 0 <span class="comment">## 获取索引0的字符和到索引0的字符的bit个数</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; bitcount key1 0 1 <span class="comment">## 获取索引0的字符和到索引1的字符的bit个数</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; bitcount key1 1 1  <span class="comment">## 获取索引1的字符和到索引1的字符的bit个数</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">&quot;AB&quot;</span></span><br></pre></td></tr></table></figure>



<p>bitpos</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bitpos key bit [start end]  <span class="comment"># 获取指定范围的第一个bit的索引</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; bitpos key1 0 <span class="comment">## 全范围获取第一个0bit的索引</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; bitpos key1 1 <span class="comment">## 全范围获取第一个1bit的索引</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; bitpos key1 1 1 2 <span class="comment">## 获取第一个1bit的索引，范围从 []byte第一个索引算起到 []byte 第二个索引结束</span></span><br><span class="line">(<span class="built_in">integer</span>) 9</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>bitfield</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bitfield key [get <span class="built_in">type</span> offset] [<span class="built_in">set</span> <span class="built_in">type</span> offset value] [INCRBY <span class="built_in">type</span> offset increment]</span><br><span class="line"><span class="comment">## bitfield 中的 offset 范围指的是bit的offset，不是byte的，一般offset指的bit偏移，start end 指的 byte的索引</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; bitfield key1 get u8 0 <span class="comment">## 取无符号的8位bit，从0号位置开始往后取</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 65  <span class="comment"># &#x27;A&#x27; 就是65</span></span><br><span class="line">127.0.0.1:6379&gt; bitfield key1 get u8 8 <span class="comment">## 取无符号的8位bit，从8号位置开始往后取</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 66 <span class="comment"># &#x27;B&#x27; 就是66</span></span><br><span class="line">127.0.0.1:6379&gt; bitfield key1 get u8 0 get u8 8 <span class="comment">## 批量获取</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 65</span><br><span class="line">2) (<span class="built_in">integer</span>) 66</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量设置</span></span><br><span class="line">127.0.0.1:6379&gt; bitfield key1 <span class="built_in">set</span> u8 16 67 <span class="built_in">set</span> u8 24 68</span><br><span class="line">1) (<span class="built_in">integer</span>) 0</span><br><span class="line">2) (<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">&quot;ABCD&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定范围修改</span></span><br><span class="line">127.0.0.1:6379&gt; bitfield key1 incrby u8 24 1</span><br><span class="line">1) (<span class="built_in">integer</span>) 69</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">&quot;ABCE&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; bitfield key1 incrby u8 24 2 </span><br><span class="line">1) (<span class="built_in">integer</span>) 70</span><br><span class="line">127.0.0.1:6379&gt; bitfield key1 incrby u8 24 -2</span><br><span class="line">1) (<span class="built_in">integer</span>) 68</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## ps： u8 不是固定的，还有有符号  i8，当然也不只是8，还可以是各种步长，但是为了方便，一个byte就是8个bit，以及方便从字符对应到ascii码处理，平时最好还是以u8为步长去处理。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>位图并不是独立数据结构，他本质还是原来的string数据结构。对位图的操作其实就是对string的[]byte 数组操作。</p>
<p>如图：</p>
<img src="/2022/10/05/redis/redis-bit-1.drawio.png" class="">



<p>redis 的位图是自动扩展的，如果设置的偏位置超出了第一个字符byte的8位，就会自动将[]byte数组扩展，就像看到到 “A” -&gt; “AB” 一样。</p>
<h1 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h1><p>统计PV可以直接加一个计数器，记录每天的数值值即可。</p>
<p>统计UV需要排重复，统计每个用户，不能重复计算，如果给每个用户单独设置一个set数据结构。当数据量很大时，会非常占用内存空间，而我们仅仅只是想统计一个uv而已。而我们对这个uv的数据不需要太精确，所以redis出了一个HyperLogLog，可以用于处理这种独立统计的场景。</p>
<h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>HyperLogLog的使用主要是三个命令</p>
<ul>
<li>pfadd  增加计数</li>
<li>pfcount   统计计数</li>
<li>pfmerge 合并两个集合</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pfadd key element [element...]</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; pfadd keyhll user1 <span class="comment">## 添加</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd keyhll user1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; pfadd keyhll user2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd keyhll user3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount keyhll <span class="comment">## 统计集合有多少个</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pfcount key [key...]</span><br><span class="line"><span class="comment">## pfcount 还可以合并两个集合进行统计，（两个集合中的重复元素会被排重）</span></span><br><span class="line">127.0.0.1:6379&gt; pfadd keyhll2 user1 user4 user5 user6</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount keyhll keyhll2</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line"></span><br><span class="line">pfmerge key [key...]</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; pfcount keyhll keyhll2</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; pfmerge keyhll3 keyhll keyhll2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;keyhll3&quot;</span></span><br><span class="line">2) <span class="string">&quot;keyhll2&quot;</span></span><br><span class="line">3) <span class="string">&quot;keyhll&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; pfcount keyhll3</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br></pre></td></tr></table></figure>



<h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>给定一个整数，每次记录下低位连续零位的最大长度K，当给定的整数数量足够多时，根据K值可以估算出整数数量N。</p>
<img src="/2022/10/05/redis/redis-hyperloglog-1.drawio.png" class="">

<p>&#x2F;&#x2F; todo 数学证明</p>
<p>关键在于我们对于相同的数值可以不管。</p>
<p>N&#x3D;2^K</p>
<p>N介于 2^k和2^(k+1)之间，当记录maxbit的桶足够多时，也就更精确。</p>
<p>实际上，每个创建的HyperLogLog占用的空间只有12kb，这12kb就是记录了2^14个桶，每个桶的maxbit占用6bit，12kb&#x3D;(2^14)*6&#x2F;8</p>
<h1 id="GEO地理位置计算"><a href="#GEO地理位置计算" class="headerlink" title="GEO地理位置计算"></a>GEO地理位置计算</h1><p>对于寻找附近的人的场景，redis提供了geo的相关指令。</p>
<p>GEO 底层本身并没有设计新的底层数据结构，而是直接使用了 zset 集合类型。通过geohash算法，实现二维的经纬度数据转换到一维的数据。然后对二维地图做区间划分，然后对区间进行编码。转换后的一维数据在这进行编码排序后的区间中找到自己的区间，zset存的就是区间的编码值，按照编码值作为分数进行排序。</p>
<p>当要寻找对应坐标附近的点时，在这个一维的线上获取附近的点即可。</p>
<p>如图转化过程</p>
<img src="/2022/10/05/redis/redis-geohash-wiki.png" class="">



<p>现在存在一个问题，就是当我们是图中2号节点，想查找附近的点时，看到这条线串起来的附近的点只有 0,1,2,3 但是8号节点就在附近，是否会漏掉？</p>
<p>1.一般当我们以某个节点为坐标寻找附近的点时，都是相对于这个坐标比较大的范围，例如以2节点为中心画个圆，这个圆的半径不会是小到只包括邻近的区域，一般都是较大的范围，而这个范围足够包括图中 2-3-4-5-6-7-8 这个长度</p>
<p>2.当划分的区域足够多时，划分的次数更多，区域更多，区域面积更小了，也会更精确。</p>
<h2 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h2><p>redis提供GEO的指令有6个</p>
<ul>
<li>geoadd</li>
<li>geodist</li>
<li>geopos</li>
<li>geohash</li>
<li>georadiusbymember</li>
<li>georadius</li>
</ul>
<p>添加成员坐标</p>
<p>ps：geo没有单独提供删除指令，但是geo本质是一个zset，可以type看一下，删除可以使用zrem指令删除</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">geoadd key longtitude latitude member</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; geoadd company 116.48105 39.996794 juejin</span><br><span class="line">127.0.0.1:6379&gt; geoadd company 116.514203 39.905409 ireader</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd company 116.489033 40.007669 meituan</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd company 116.562108 39.787602 jd 116.334255 40.027400 xiaomi</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure>



<p>计算两个元素之间的距离</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">geodist key member1 member2 [unit]</span><br><span class="line">127.0.0.1:6379&gt; geodist company juejin ireader km</span><br><span class="line"><span class="string">&quot;10.5501&quot;</span></span><br></pre></td></tr></table></figure>



<p>获取元素位置</p>
<p>以下可以看到获取到的经纬度和geoadd进去的坐标有误差，是因为geohash对二维坐标进行的映射后不是放原来自己的精确值，一组经纬度落在某个区间后，就用区间的编码值来表示，并把编码值作为zset 元素的权重分数。相当于一个个槽位，存放的时候以这些槽位为准。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">geopos key1 member</span><br><span class="line">127.0.0.1:6379&gt; geopos company juejin</span><br><span class="line">1) 1) <span class="string">&quot;116.48104995489120483&quot;</span></span><br><span class="line">   2) <span class="string">&quot;39.99679348858259686&quot;</span></span><br></pre></td></tr></table></figure>



<p>获取元素的hash值</p>
<p>geo可以获取元素的经纬度编码后的字符串，他是以base32编码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">geohash key member</span><br><span class="line">127.0.0.1:6379&gt; geohash company juejin</span><br><span class="line">1) <span class="string">&quot;wx4gd94yjn0&quot;</span></span><br></pre></td></tr></table></figure>



<p>根据成员信息来查询附近元素</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">georadiusbymember key member redius [unit] [withcoord][withdist][withhash][count n][asc|desc]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找ireader 附近 20 km 以内的3个成员，按距离正排</span></span><br><span class="line">127.0.0.1:6379&gt; georadiusbymember company ireader 20 km count 3 asc</span><br><span class="line">1) <span class="string">&quot;ireader&quot;</span></span><br><span class="line">2) <span class="string">&quot;juejin&quot;</span></span><br><span class="line">3) <span class="string">&quot;meituan&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># georadiusbymember 有三个可选参数 withcoord withdist withhash </span></span><br><span class="line"><span class="comment"># withhash 显示原始坐标</span></span><br><span class="line"><span class="comment"># withdist 显示距离</span></span><br><span class="line"><span class="comment"># withhash 显示坐标的hash值</span></span><br><span class="line">127.0.0.1:6379&gt; georadiusbymember company ireader 20 km withcoord withhash withdist count 3 asc</span><br><span class="line">1) 1) <span class="string">&quot;ireader&quot;</span></span><br><span class="line">   2) <span class="string">&quot;0.0000&quot;</span></span><br><span class="line">   3) (<span class="built_in">integer</span>) 4069886008361398</span><br><span class="line">   4) 1) <span class="string">&quot;116.5142020583152771&quot;</span></span><br><span class="line">      2) <span class="string">&quot;39.90540918662494363&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;juejin&quot;</span></span><br><span class="line">   2) <span class="string">&quot;10.5501&quot;</span></span><br><span class="line">   3) (<span class="built_in">integer</span>) 4069887154388167</span><br><span class="line">   4) 1) <span class="string">&quot;116.48104995489120483&quot;</span></span><br><span class="line">      2) <span class="string">&quot;39.99679348858259686&quot;</span></span><br><span class="line">3) 1) <span class="string">&quot;meituan&quot;</span></span><br><span class="line">   2) <span class="string">&quot;11.5748&quot;</span></span><br><span class="line">   3) (<span class="built_in">integer</span>) 4069887179083478</span><br><span class="line">   4) 1) <span class="string">&quot;116.48903220891952515&quot;</span></span><br><span class="line">      2) <span class="string">&quot;40.00766997707732031&quot;</span></span><br></pre></td></tr></table></figure>



<p>根据坐标值来查询附近元素，应用场景例如用户根据当前坐标值查找”附近餐馆”等信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">georadius key longtitude latitude redius [unit] [count n][asc|desc]</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; georadius company 116.514202 39.905409 20 km withdist count 3 asc</span><br><span class="line">1) 1) <span class="string">&quot;ireader&quot;</span></span><br><span class="line">   2) <span class="string">&quot;0.0000&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;juejin&quot;</span></span><br><span class="line">   2) <span class="string">&quot;10.5501&quot;</span></span><br><span class="line">3) 1) <span class="string">&quot;meituan&quot;</span></span><br><span class="line">   2) <span class="string">&quot;11.5748&quot;</span></span><br></pre></td></tr></table></figure>





<p>在坐标数据过大的场景中，将坐标全部放在zset集合中，单个key数据过大，集群的槽迁移会出现卡顿现象，所以使用单独的redis实例会比较好。然后坐标信息拆分粒度。</p>
<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p>分布式锁的实现一般有两种思路</p>
<ol>
<li>一种是通过原子性，来保证只有一个人抢占到锁。</li>
<li>一种是通过串行化，来保证操作的顺序性。</li>
</ol>
<p>redis实现的分布式锁一般是第一种。利用 setnx 和 redis 单线程的特性，保证多个人setnx只有一个人会设置成功。</p>
<p>对于 2.8版本后的redis，set 支持设置 nx 和 expire 特性，所以实现分布式锁非常简单，抢占的时候直接set，退出的时候直接删除即可。</p>
<p>对于2.8版本前的redis，如下图：</p>
<img src="/2022/10/05/redis/redis-lock.drawio.png" class="">





<h1 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h1><p>限流的实现一般有3种思路：</p>
<ol>
<li>时间窗口</li>
<li>令牌</li>
<li>漏斗</li>
</ol>
<p>&#x2F;&#x2F; todo 画图</p>
<p>&#x2F;&#x2F; todo 单独写一篇限流的blog，写下demo代码</p>
<p>&#x2F;&#x2F; todo 写下设计思路</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ratelimiter</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto/sha1&quot;</span></span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/go-redis/redis&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// redis</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间窗口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> script = <span class="string">`</span></span><br><span class="line"><span class="string">local tokens_key = KEYS[1]</span></span><br><span class="line"><span class="string">local timestamp_key = KEYS[2]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">local rate = tonumber(ARGV[1])</span></span><br><span class="line"><span class="string">local capacity = tonumber(ARGV[2])</span></span><br><span class="line"><span class="string">local now = tonumber(ARGV[3])</span></span><br><span class="line"><span class="string">local requested = tonumber(ARGV[4])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">local fill_time = capacity/rate</span></span><br><span class="line"><span class="string">local ttl = math.floor(fill_time*2)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">local last_tokens = tonumber(redis.call(&quot;get&quot;, tokens_key))</span></span><br><span class="line"><span class="string">if last_tokens == nil then</span></span><br><span class="line"><span class="string">    last_tokens = capacity</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">local last_refreshed = tonumber(redis.call(&quot;get&quot;, timestamp_key))</span></span><br><span class="line"><span class="string">if last_refreshed == nil then</span></span><br><span class="line"><span class="string">    last_refreshed = 0</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">local delta = math.max(0, now-last_refreshed)</span></span><br><span class="line"><span class="string">local filled_tokens = math.min(capacity, last_tokens+(delta*rate))</span></span><br><span class="line"><span class="string">local allowed = filled_tokens &gt;= requested</span></span><br><span class="line"><span class="string">local new_tokens = filled_tokens</span></span><br><span class="line"><span class="string">if allowed then</span></span><br><span class="line"><span class="string">    new_tokens = filled_tokens - requested</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">redis.call(&quot;setex&quot;, tokens_key, ttl, new_tokens)</span></span><br><span class="line"><span class="string">redis.call(&quot;setex&quot;, timestamp_key, ttl, now)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">return &#123; allowed, new_tokens &#125;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Limit defines the maximum frequency of some events.</span></span><br><span class="line"><span class="comment">// Limit is represented as number of events per second.</span></span><br><span class="line"><span class="comment">// A zero Limit allows no events.</span></span><br><span class="line"><span class="keyword">type</span> Limit <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Inf is the infinite rate limit; it allows all events (even if burst is zero).</span></span><br><span class="line"><span class="keyword">const</span> Inf = Limit(math.MaxFloat64)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Limiter <span class="keyword">struct</span> &#123;</span><br><span class="line">	client *redis.Client</span><br><span class="line"></span><br><span class="line">	limit Limit</span><br><span class="line">	burst <span class="type">int</span></span><br><span class="line"></span><br><span class="line">	scriptHash <span class="type">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// mu sync.Mutex</span></span><br><span class="line"></span><br><span class="line">	key <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateLimiter returns a new Limiter that allows events up to rate r and permits</span></span><br><span class="line"><span class="comment">// bursts of at most b tokens.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateLimiter</span><span class="params">(r Limit, b <span class="type">int</span>, key <span class="type">string</span>, client *redis.Client)</span></span> (lmt *Limiter, err <span class="type">error</span>) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建limiter</span></span><br><span class="line">	lmt = <span class="built_in">new</span>(Limiter)</span><br><span class="line">	lmt.client = client</span><br><span class="line">	lmt.limit = r</span><br><span class="line">	lmt.burst = b</span><br><span class="line">	lmt.key = key</span><br><span class="line"></span><br><span class="line">	<span class="comment">//load script</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		timer := time.NewTicker(<span class="number">5</span> * time.Second)</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line">				lmt.loadScript()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> lmt, lmt.loadScript()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lmt *Limiter)</span></span> loadScript() <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> lmt.client == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;redis client is nil&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lmt.scriptHash = fmt.Sprintf(<span class="string">&quot;%x&quot;</span>, sha1.Sum([]<span class="type">byte</span>(script)))</span><br><span class="line">	exists, err := lmt.client.ScriptExists(lmt.scriptHash).Result()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(err)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// load script when missing.</span></span><br><span class="line">	<span class="keyword">if</span> !exists[<span class="number">0</span>] &#123;</span><br><span class="line">		_, err := lmt.client.ScriptLoad(script).Result()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Println(err)</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Every converts a minimum time interval between events to a Limit.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Every</span><span class="params">(interval time.Duration)</span></span> Limit &#123;</span><br><span class="line">	<span class="keyword">if</span> interval &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Inf</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span> / Limit(interval.Seconds())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow is shorthand for AllowN(time.Now(), 1).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> Allow() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> lim.AllowN(time.Now(), <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AllowN reports whether n events may happen at time now.</span></span><br><span class="line"><span class="comment">// Use this method if you intend to drop / skip events that exceed the rate limit.</span></span><br><span class="line"><span class="comment">// Otherwise use Reserve or Wait.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> AllowN(now time.Time, n <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> lim.reserveN(now, n).ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A Reservation holds information about events that are permitted by a Limiter to happen after a delay.</span></span><br><span class="line"><span class="comment">// A Reservation may be canceled, which may enable the Limiter to permit additional events.</span></span><br><span class="line"><span class="keyword">type</span> Reservation <span class="keyword">struct</span> &#123;</span><br><span class="line">	ok     <span class="type">bool</span></span><br><span class="line">	tokens <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lmt *Limiter)</span></span> reserveN(now time.Time, n <span class="type">int</span>) Reservation &#123;</span><br><span class="line">	<span class="keyword">if</span> lmt.client == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Reservation&#123;</span><br><span class="line">			ok:     <span class="literal">true</span>,</span><br><span class="line">			tokens: n,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	results, err := lmt.client.EvalSha(</span><br><span class="line">		lmt.scriptHash,</span><br><span class="line">		[]<span class="type">string</span>&#123;lmt.key + <span class="string">&quot;.tokens&quot;</span>, lmt.key + <span class="string">&quot;.ts&quot;</span>&#125;,</span><br><span class="line">		<span class="type">float64</span>(lmt.limit),</span><br><span class="line">		lmt.burst,</span><br><span class="line">		now.Unix(),</span><br><span class="line">		n,</span><br><span class="line">	).Result()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;fail to call rate limit: &quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> Reservation&#123;</span><br><span class="line">			ok:     <span class="literal">true</span>,</span><br><span class="line">			tokens: n,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rs, ok := results.([]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		newTokens, _ := rs[<span class="number">1</span>].(<span class="type">int64</span>)</span><br><span class="line">		<span class="keyword">return</span> Reservation&#123;</span><br><span class="line">			ok:     rs[<span class="number">0</span>] == <span class="type">int64</span>(<span class="number">1</span>),</span><br><span class="line">			tokens: <span class="type">int</span>(newTokens),</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	log.Println(<span class="string">&quot;fail to transform results&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> Reservation&#123;</span><br><span class="line">		ok:     <span class="literal">true</span>,</span><br><span class="line">		tokens: n,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="队列通信"><a href="#队列通信" class="headerlink" title="队列通信"></a>队列通信</h1><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>直接使用list数据结构，lpush，rpop或者 rpush，lpop。redis处理请求是先执行命令，再保存。不是数据库那种先写日志。所以redis不保证消息不丢失。这种队列一般用来做消息通知，而不是消费数据传输。</p>
<h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><p>延迟队列是指把当前要做的事情，往后推迟一段时间再做。延迟队列的常见使用场景有以下几种：</p>
<ul>
<li>在淘宝、京东等购物平台上下单，超过一定时间未付款，订单会自动取消；</li>
<li>打车的时候，在规定时间没有车主接单，平台会取消你的单并提醒你暂时没有车主接单；</li>
<li>点外卖的时候，如果商家在10分钟还没接单，就会自动取消订单；</li>
</ul>
<p>在 Redis 可以使用有序集合（ZSet）的方式来实现延迟消息队列的，ZSet的score用来存时间（或者当前时间+timeout），然后出队根据当前时间+timeout（或者当前时间）去获取。</p>
<h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><p>主要命令如下</p>
<ul>
<li><strong>SUBSCRIBE channel [channel …]</strong> 订阅给定的一个或多个频道的信息。</li>
<li>**PSUBSCRIBE pattern [pattern …] ** 订阅一个或多个符合给定模式的频道。</li>
<li><strong>UNSUBSCRIBE [channel [channel …]]</strong> 指示客户端退订给定的频道。</li>
<li><strong>PUNSUBSCRIBE [pattern [pattern …]]</strong> 指示客户端退订所有给定模式。</li>
<li><strong>PUBLISH channel message</strong>  将信息 <code>message</code> 发送到指定的频道 <code>channel</code> 。</li>
<li><strong>PUBSUB <subcommand> [argument [argument …]]</strong></li>
</ul>
<p>这里展示一些主要的pub sub，更多参考 redis 手册</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">## 订阅 chan1 chan2</span></span><br><span class="line">127.0.0.1:6379&gt; subscribe chan1 chan2</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line">2) <span class="string">&quot;chan1&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line">2) <span class="string">&quot;chan2&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment">## 发布到 chan1</span></span><br><span class="line">127.0.0.1:6379&gt; publish chan1 v1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment">## PUBSUB &lt;subcommand&gt; [argument [argument ...]]</span></span><br><span class="line"><span class="comment">## 查看频道数量</span></span><br><span class="line"><span class="comment">## PUBSUB CHANNELS [pattern]</span></span><br><span class="line">127.0.0.1:6379&gt; pubsub CHANNELS *</span><br><span class="line">1) <span class="string">&quot;chan2&quot;</span></span><br><span class="line">2) <span class="string">&quot;chan1&quot;</span></span><br><span class="line"><span class="comment">## 更多用法参考redis手册 http://doc.redisfans.com/</span></span><br></pre></td></tr></table></figure>





<p>pubsub 的 缺点</p>
<p>发布订阅模式，不能持久化也就无法可靠的保存消息。pubsub的发布者生产一个消息，redis会直接将相应的消费者传递过去，如果一个订阅者都没有，那么消息会被直接丢弃。例如有三个订阅者，其中一个订阅者c在中途断开连接了，发布者继续发布消息，等订阅者c重新连接上的时候，在这期间的数据已经没有了。</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>Redis 支持事务</p>
<p>传统数据库支持的事务指令都有 begin，commit 和 rollback。</p>
<p>redis对应的支持的事务指令是：multi，exec 和 discard。</p>
<p>使用如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; discard</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br></pre></td></tr></table></figure>





<p>redis的事务和传统数据库的事务不太一样，或者应该把redis支持的事务理解为一系列保证不会被打断的命令集。所有的指令在exec之前都不会执行，而是缓存在服务器的一个 <strong>事务队列</strong> 中，服务器一旦收到 exec ，才开始执行整个队列中的命令，执行完毕后一次性返回所有指令的运行结果。而且redis保证这个事务队列之心的时候不会执行其他指令。 </p>
<p>redis的事务不保证原子性，既启用multi 后，在执行的命令中，是否成功是未知的，要等到exec之后才知道结果，如果exec之后，multi和exec中间有一条命令出错，其他命令依然会执行。所以不具备原子性特性。（虽然是说命令在exec之前都不会执行，但是redis是会去检查key是否存在的，例如在命令中get 一个不存在的key，是会收到报错信息的。）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k2 v2</span><br><span class="line">(error) ERR wrong number of arguments <span class="keyword">for</span> <span class="string">&#x27;get&#x27;</span> <span class="built_in">command</span></span><br></pre></td></tr></table></figure>





<p>watch 机制</p>
<p>redis提供了一种watch机制，他是一种乐观锁，使用时，在multi 执行之前先watch 一系列key，当事务执行时，收到exec，redis会检查watch的key的情况，是否有改变，只有watch的key中有一个改变，那redis会放弃这次事务的整个命令队列的执行。</p>
<p>注意 </p>
<ul>
<li>watch是在multi前执行的。redis紧张在multi和exec之间执行watch</li>
<li>这个判断key有没有改变的依据不是multi开启的时候，而是watch开启的时候。也就是说 watch和multi之间如果有另一个进程改变了key，就注定这个事务会失败了。哪怕改变key的时候，multi还没开启。</li>
<li>watch只和连接挂钩，连接断开，watch就失效了</li>
<li>watch在执行一次事务之后就解除了。(不管事务成功还是失败)</li>
</ul>
<p>watch 使用如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; watch k1 k2 k3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k3 3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) OK</span><br><span class="line"></span><br><span class="line"><span class="comment">### 改变的情况</span></span><br><span class="line">127.0.0.1:6379&gt; watch k1 k2 k3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 22</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k3 33 <span class="comment">### 此时，在exec执行之前，在另一个进程中修改k3的值为333</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">(nil)   <span class="comment">## 执行失败，k1,k2,k3还是exec前的值</span></span><br><span class="line">127.0.0.1:6379&gt; get k3</span><br><span class="line"><span class="string">&quot;333&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line"><span class="string">&quot;2&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>













<h1 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h1><p>redis一般都保存这大量数据，当我们想查找到特定的key时候，有两种方式</p>
<p>一种是简单地使用keys，一种是使用scan。</p>
<p>第一种使用keys 一般只在测试环境等数据量少的地方时候，keys是直接遍历整个redis的map，复杂度是O(n)，而redis是单线程处理命令的。所以万一keys遍历的数据量过大，会导致其他命令卡住。</p>
<p>所以实际使用时，都是使用scan来遍历</p>
<p>scan的基本使用如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scan 0 match key* count 1000</span><br><span class="line">1) <span class="string">&quot;0&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;keyhll&quot;</span></span><br><span class="line">   2) <span class="string">&quot;keyhll3&quot;</span></span><br><span class="line">   3) <span class="string">&quot;keyhll2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; scan 0 match key* count 2</span><br><span class="line">1) <span class="string">&quot;2&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;keyhll&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; scan 2 match key* count 2</span><br><span class="line">1) <span class="string">&quot;0&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;keyhll3&quot;</span></span><br><span class="line">   2) <span class="string">&quot;keyhll2&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="遍历的是什么"><a href="#遍历的是什么" class="headerlink" title="遍历的是什么"></a>遍历的是什么</h2><p>scan的复杂度也是O(n)，但是他是通过游标分布进行的，不会阻塞线程，在redis中，数据都是存放在map中的，这个map有很多槽，scan每次扫指定数量的槽位并返回，返回时还要携带一个信息，用来表示已经遍历过哪些槽位了。这里使用”游标”来承载这个信息。</p>
<p>命令中的count 1000 不是限定返回数量，而是限定服务器单词遍历的字典槽位数量。</p>
<p>scan指令返回的游标就是数组的位置索引，count表示要遍历的槽位，返回的结果可能多可能少，是因为有些槽位可能是空的。每次scan 都会将 对应数量的槽位上的链表元素进行匹配后过滤返回给客户端。</p>
<p>如图：</p>
<img src="/2022/10/05/redis/redis-scan-slot-1.drawio.png" class="">





<h2 id="高位进位加法"><a href="#高位进位加法" class="headerlink" title="高位进位加法"></a>高位进位加法</h2><p>考虑到遍历redis字典时可能出现扩容和缩容，scan的遍历顺序不是从数组的0位一直遍历到末尾，而是采用了高位进位加法来遍历。</p>
<p>什么是高位进位加法？如图：</p>
<img src="/2022/10/05/redis/redis-scan-add.drawio.png" class="">



<p>为什么要使用高位进位加法？为了支持遍历时扩容</p>
<p>map扩容的时候，需要重新分配一个新的2倍大小的数组，然后将原来数组的元素全部rehash后取模，然后分配到新数组中。</p>
<p>举个例子，原本的数组由8 slot扩容到16 slot，假如第3个 slot （011）存放有 元素 3 和 11， 因为长度变为原来的两倍了，所以原本放在 011 槽位的元素会被分配到 0011和 1011 两个槽位，1011对于原来的 011 来说，相当于在最高位+1。</p>
<p>如图：</p>
<img src="/2022/10/05/redis/redis-scan-2.drawio.png" class="">



<p>结合扩容和缩容前后的情况，如图：</p>
<img src="/2022/10/05/redis/redis-scan.drawio.png" class="">



<p>假如现在客户端刚scan 010，处理完 010 的槽位数据，正要 scan 110 的时候，服务器发生扩容&#x2F;缩容：</p>
<p>服务器发生扩容，扩容后，110槽位上所有的数据都分配到了 0110和1110 的槽位。这是scan 110 ，游标数值对应 0110 ，服务器就直接遍历0110，0110 之前的数据都是遍历过了的，这样就可以避免扩容后对已经遍历过的槽位重复遍历。</p>
<p>服务器发生缩容，缩容后，因为容量的索引最高是 11 ，游标数值超过，取模，得到对应要访问的槽位是10，这是就从10 这个槽位往后遍历，10 槽位前的都是遍历过的了。不过有个问题，那就是 10 这个槽位是包含了 110 和 010 的，也就是对 010 这个槽位上的元素进行了重复遍历。 </p>
<p>由上面我们可以知道</p>
<p>服务器不需要为游标保存状态。</p>
<p>scan遍历返回的结果可能会有重复。（缩容的时候）</p>
<p>一趟遍历（多次scan）的过程中，新加数据是不一定能遍历到的，因为可能新加的数据在前面已经scan过的槽位上。</p>
<p>单次返回的结果是空不代表遍历结束，只能说明游标遍历的这些槽位没有数据，遍历的结束的标志要看返回的游标值是否为0</p>
<h2 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h2><p>在map扩容的时候，会一次性将旧数组下的元素全部转移到新数组下面，如果map中的slot下的元素很多，线程会出现卡顿。一般常用的处理方法是使用渐进式rehash，redis也是这么处理的。</p>
<p>map会同时保留新旧两个数组，然后在定时任务以及后续对hash的访问操作中，把旧数组中的元素移动到新数组上，如果在旧数组找不到数据，还要到新数组去找，其实本质就是把迁移工作均摊到每次访问上。</p>
<p>Ps：在集群环境下，如果单个key的数据太大，会导致数据迁移卡顿，以及在扩容的时候需要一次性申请大内存，也会导致操作系统腾出空间而卡顿。如果这个key被删除，内存回收也会导致卡顿。</p>
<p>所以在平时业务开发中，尽量避免大key的产生。</p>
<p>总之，大 key 会带来以下四种影响：</p>
<ul>
<li><strong>客户端超时阻塞</strong>。由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</li>
<li><strong>引发网络阻塞</strong>。每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。</li>
<li><strong>阻塞工作线程</strong>。如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。</li>
<li><strong>内存分布不均</strong>。集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜情况，部分有大 key 的 Redis 节点占用内存多，QPS 也会比较大。</li>
</ul>
<h1 id="RESP协议"><a href="#RESP协议" class="headerlink" title="RESP协议"></a>RESP协议</h1><p>演示模拟redis-cli和redis-server</p>
<p>当tcp连接建立后，所有基于tcp的连接的上层应用都要有自己的一套规则，连接的双方遵循这套规则来处理数据，因为tcp传的都是数据，也就是byte数组。上层应用要根据遵循的协议来读取这个byte数组才有意义。</p>
<p>redis使用了比较简单的文本协议，但是依然可以取得极高的访问性能。因为使用简单的协议就意味着不必在从socket读出数据后对这份byte数组做浪费cpu时间的复杂的解析。</p>
<p>redis使用的文本协议叫做 redis序列化协议，简称RESP（Redis Serialization Protocol）</p>
<p>resp将传输的数据结构分为5种小单元类型，单元结束时统一加上回车符和换行符<code>\r\n</code></p>
<ol>
<li>单行字符串以 <code>+</code> 符号开头。</li>
<li>多行字符串以 <code>$</code> 符号开头，后面跟着字符串长度。</li>
<li>整数值以 <code>:</code> 符号开头，后面跟着整数的字符串形式。</li>
<li>错误消息以 <code>-</code> 符号开头。 </li>
<li>数组以 <code>*</code> 符号开头，后面跟数组的长度</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">+hello world\r\n</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$11</span>\r\nhello world\r\n</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:1024\r\n</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-WRONGTYPE Operation against a key holding the wrong kind of svalue\r\n</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 数组 [1,2,3]</span></span><br><span class="line">*3\r\n:1\r\n:2\r\n:3\r\n</span><br><span class="line"></span><br><span class="line"><span class="comment">## 字符串+数字数组 [&quot;hello world&quot;,&quot;ironhead&quot;,2000]</span></span><br><span class="line">*3\r\n<span class="variable">$11</span>\r\nhello world\r\n<span class="variable">$8</span>\r\nironhead\r\n:2000\r\n</span><br><span class="line"></span><br><span class="line"><span class="comment">## NULL</span></span><br><span class="line">$-1\r\n</span><br><span class="line"></span><br><span class="line"><span class="comment">## 空串</span></span><br><span class="line"><span class="variable">$0</span>\r\n\r\n</span><br><span class="line"></span><br><span class="line"><span class="comment">## 嵌套 ，在redis中例如scan返回的数据是存在一个数组嵌套另一个数组的情况的。例子如下</span></span><br><span class="line">*2\r\n<span class="variable">$1</span>\r\n0\r\n*2\r\n<span class="variable">$11</span>\r\nhello world\r\n<span class="variable">$8</span>\r\nironhead\r\n</span><br></pre></td></tr></table></figure>



<h2 id="使用协议和redis-cli通信"><a href="#使用协议和redis-cli通信" class="headerlink" title="使用协议和redis-cli通信"></a>使用协议和redis-cli通信</h2><p>为了检验这套协议，我们做个实验，使用redis自带的 redis-cli，然后我们自己创建服务，然后使用redis-cli来连接我们自己创建的server，这个server也遵循 redis序列化协议，就能通信。</p>
<p>小实验目标：</p>
<ul>
<li><p>小服务的listen 6379端口 ，和redis-cli 建立tcp连接后，接收redis-cli的命令，观察命令长什么样。</p>
</li>
<li><p>当前小服务只做 get set del test1 test2 命令的处理。各个命令对应的响应解释如代码中注释所说，然后观察redis-cli收到的回复长什么样。</p>
</li>
</ul>
<p>代码如下：（ps：我们目标只是检验resp通信协议，不在实现复杂的服务，所以代码只是一个只能处理简单get set 命令的服务）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;os/signal&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;syscall&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> DataMap <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	ctx, cancel := context.WithCancel(context.TODO())</span><br><span class="line"></span><br><span class="line">	listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:6379&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> tempDelay time.Duration <span class="comment">// how long to sleep on accept failure</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			conn, err := listener.Accept()</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"></span><br><span class="line">					log.Println(<span class="string">&quot;退出，关闭下游&quot;</span>)</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> ne, ok := err.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class="line">					<span class="keyword">if</span> tempDelay == <span class="number">0</span> &#123;</span><br><span class="line">						tempDelay = <span class="number">5</span> * time.Millisecond</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						tempDelay *= <span class="number">2</span></span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> max := <span class="number">1</span> * time.Second; tempDelay &gt; max &#123;</span><br><span class="line">						tempDelay = max</span><br><span class="line">					&#125;</span><br><span class="line">					log.Println(<span class="string">&quot;http: Accept error: %v; retrying in %v&quot;</span>, err, tempDelay)</span><br><span class="line">					time.Sleep(tempDelay)</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">go</span> handle(conn, ctx)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	sig := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">	signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">	&lt;-sig</span><br><span class="line">	cancel()</span><br><span class="line">	wg.Wait()</span><br><span class="line">	log.Println(<span class="string">&quot;安全退出&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(conn net.Conn, ctx context.Context)</span></span> &#123;</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> buf [<span class="number">1024</span>]<span class="type">byte</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		conn.SetReadDeadline(time.Now().Add(<span class="number">10</span> * time.Second))</span><br><span class="line">		n, err := conn.Read(buf[:])</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		recv := <span class="type">string</span>(buf[:n])</span><br><span class="line"></span><br><span class="line">		log.Println(recv) <span class="comment">//打印收到的数据，方便调试</span></span><br><span class="line"></span><br><span class="line">		resp := do(recv)</span><br><span class="line"></span><br><span class="line">		n, err = conn.Write([]<span class="type">byte</span>(resp))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单的解析,简单做默认只有 set,get,del</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(data <span class="type">string</span>)</span></span> (resp <span class="type">string</span>) &#123;</span><br><span class="line">	strs := strings.Split(data, <span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">	s := strs[<span class="number">0</span>] <span class="comment">// 默认命令过来的一定是数组 *&#123;num&#125;</span></span><br><span class="line">	num, _ := strconv.Atoi(s[<span class="number">1</span>:])</span><br><span class="line">	<span class="keyword">if</span> num == <span class="number">1</span> &#123; <span class="comment">// num 为1是刚连接的时候的COMMAND</span></span><br><span class="line">		<span class="comment">//return &quot;*1\r\n+OK\r\n&quot;</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;$2\r\nOK\r\n&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	action := strs[<span class="number">2</span>]</span><br><span class="line">	mu.Lock()</span><br><span class="line">	<span class="keyword">switch</span> action &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;set&quot;</span>: <span class="comment">// 测试单行字符串</span></span><br><span class="line">		DataMap[strs[<span class="number">4</span>]] = strs[<span class="number">6</span>]</span><br><span class="line">		resp = <span class="string">&quot;+OK\r\n&quot;</span> <span class="comment">// OK</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;get&quot;</span>:</span><br><span class="line">		val, ok := DataMap[strs[<span class="number">4</span>]]</span><br><span class="line">		<span class="keyword">if</span> !ok &#123; <span class="comment">// 测试数组</span></span><br><span class="line">			resp = <span class="string">&quot;*1\r\n$5\r\nempty\r\n&quot;</span> <span class="comment">// 1) &quot;empty&quot;</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// 测试单行字符串</span></span><br><span class="line">			resp = <span class="string">&quot;+&quot;</span> + val + <span class="string">&quot;\r\n&quot;</span> <span class="comment">// val</span></span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;del&quot;</span>: <span class="comment">// 测试字符串</span></span><br><span class="line">		<span class="built_in">delete</span>(DataMap, strs[<span class="number">4</span>])</span><br><span class="line">		resp = <span class="string">&quot;$7\r\nsuccess\r\n&quot;</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;test&quot;</span>: <span class="comment">// 测试数组中 存在 字符串和 数字</span></span><br><span class="line">		resp = <span class="string">&quot;*3\r\n$11\r\nhello world\r\n$8\r\nironhead\r\n:3\r\n&quot;</span> <span class="comment">//</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;test2&quot;</span>: <span class="comment">// 测试数组嵌套</span></span><br><span class="line">		resp = <span class="string">&quot;*2\r\n$1\r\n0\r\n*2\r\n$11\r\nhello world\r\n$8\r\nironhead\r\n&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> resp</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="使用协议和redis-server通信"><a href="#使用协议和redis-server通信" class="headerlink" title="使用协议和redis-server通信"></a>使用协议和redis-server通信</h2><p>同上，只要我们以遵循redis序列化协议的方式处理从tcp连接获取的数据。也能实现和redis-server通信。</p>
<p>我们dial 6379 和 redis-server建立连接，获取终端的输入，把终端输入解析成 resp 的数据格式。写入 socket。（ps：将数据解析成resp 的处理 是简单做的，没有考虑复杂命令集。）</p>
<p>实验目标：</p>
<ul>
<li>终端输入 set key3 val3，在redis-server中观察（redis-cli连接后观察）是否存在key3和查看key类型和val</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="comment">//&quot;bufio&quot;</span></span><br><span class="line">	<span class="comment">//&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//&quot;log&quot;</span></span><br><span class="line">	<span class="comment">//&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//inputReader := bufio.NewReader(os.Stdin)</span></span><br><span class="line">	<span class="comment">//recv, _ = inputReader.ReadString(&#x27;\n&#x27;)</span></span><br><span class="line">	<span class="comment">//fmt.Println([]byte(recv))</span></span><br><span class="line"></span><br><span class="line">	conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:6379&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> buf [<span class="number">1024</span>]<span class="type">byte</span></span><br><span class="line">	<span class="keyword">var</span> inputbuf [<span class="number">1024</span>]<span class="type">byte</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line">		os.Stdout.SetWriteDeadline(time.Now().Add(<span class="number">10</span> * time.Second))</span><br><span class="line">		os.Stdout.Write([]<span class="type">byte</span>(<span class="string">&quot;my-redis-cli-&quot;</span> + conn.RemoteAddr().String() + <span class="string">&quot;&gt;&quot;</span>))</span><br><span class="line"></span><br><span class="line">		os.Stdin.SetReadDeadline(time.Now().Add(<span class="number">10</span> * time.Second))</span><br><span class="line">		n, err := os.Stdin.Read(inputbuf[:])</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		input := <span class="type">string</span>(inputbuf[:n])</span><br><span class="line"></span><br><span class="line">		<span class="comment">// todo input 转化成 resp风格命令</span></span><br><span class="line"></span><br><span class="line">		output := do(input)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 连续的两个命令看看是否有粘包问题。</span></span><br><span class="line">		<span class="comment">//n, err := conn.Write([]byte(&quot;*3\r\n$3\r\nset\r\n$2\r\nk1\r\n$2\r\nv1\r\n&quot; +</span></span><br><span class="line">		<span class="comment">//	&quot;*3\r\n$3\r\nset\r\n$2\r\nk2\r\n$2\r\nv2\r\n&quot;))</span></span><br><span class="line">		n, err = conn.Write([]<span class="type">byte</span>(output))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		conn.SetReadDeadline(time.Now().Add(<span class="number">10</span> * time.Second))</span><br><span class="line">		n, err = conn.Read(buf[:])</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		recv := <span class="type">string</span>(buf[:n])</span><br><span class="line">		fmt.Printf(recv)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单解析</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(input <span class="type">string</span>)</span></span> (output <span class="type">string</span>) &#123;</span><br><span class="line"></span><br><span class="line">	sep := <span class="string">&quot;\r\n&quot;</span></span><br><span class="line">	input = strings.Trim(input, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	strs := strings.Split(input, <span class="string">&quot; &quot;</span>)</span><br><span class="line">	num := <span class="built_in">len</span>(strs)</span><br><span class="line"></span><br><span class="line">	output = output + <span class="string">&quot;*&quot;</span> + strconv.Itoa(num) + sep</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line">		n := <span class="built_in">len</span>(strs[i])</span><br><span class="line">		output = output + <span class="string">&quot;$&quot;</span> + strconv.Itoa(n) + sep</span><br><span class="line">		output = output + strs[i] + sep</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><p>管道技术（Pipeline）是客户端提供的一种批处理技术，用于一次处理多个 Redis 命令，从而提高整个交互的性能。</p>
<p>管道技术本质上是客户端提供的功能，而非 Redis 服务器端的功能。对于redis服务器来说，他照样继续处理收到的redis命令，不会有什么特殊处理。</p>
<p>一条命令的执行过程如下：</p>
<p>client 进程和server 进程建立连接后，client 调用write将消息（redis命令）写到操作系统为socket分配的发送缓冲 send buffer中。</p>
<p>client 操作系统在合适的时间将发送缓冲的内容经过协议栈的层层处理，最后发到网卡，网卡将数据发到路由，通过 网络 的层层传递 最后到达服务器的网卡。</p>
<p>服务器的网卡收到数据，DMA将数据收到收包队列 ring buffer 中，硬件中断处理，操作系统启用ksoftirqd 线程处理，然后经过协议栈层层处理，到达服务器操作系统为这次连接socket分配的接收缓冲recv buffer。</p>
<p>服务器进程调用read 将数据取出，解析命令作出处理，然后将处理后的结果调用write，发送到服务器进程的socket的发送缓冲 send buffer中。</p>
<p>然后同理，数据也是经过server的send buffer –&gt; server的协议栈 –&gt; server的网卡 –&gt; 网络 –&gt; client的网卡 –&gt; client的协议栈 –&gt; client的socket的recv buffer；</p>
<p>client 进程调用 read 读出 socket中的数据，这一条命令的处理才算完成。对于client来说，真正耗时的是网络io和数据传输，写入到sendbuffer中并不耗时间。</p>
<img src="/2022/10/05/redis/redis-net-1.drawio.png" class="">



<h2 id="关于连接的read和write"><a href="#关于连接的read和write" class="headerlink" title="关于连接的read和write"></a>关于连接的read和write</h2><p>write操作并不是要等到目标服务器收到数据才返回，write操作只负责将数据写入到本地操作系统维护的发送缓冲中就返回了。剩下的交给操作系统内核来将数据发送出去。只有在发送缓冲满了的时候，write才会耗时等待缓冲中的数据被发送处理腾出空间来。写操作io只有在这时才是耗时的大头。</p>
<p>read 操作并非一定是从目标服务器读取数据，read操作只负责将数据从本地操作系统内核维护的接收缓冲中拉取数据就完事了。只有缓冲是空的，需要等待数据到来，read才是真正等待网络io的耗时。</p>
<h1 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h1><p>redis是单线程的。这个”单线程”是指处理命令是单线程的。也就是说 <strong>[ 接收客户端请求-&gt;解析请求 -&gt;进行数据读写等操作-&gt;发送数据给客户端 ] <strong>这个过程是由一个线程（主线程）来完成的。但是，Redis 程序并不是单线程的 ，Redis 在启动的时候，是会</strong>启动后台线程</strong>的</p>
<p>redis单线程为什么能这么快？</p>
<ol>
<li>数据都在内存中。</li>
<li>单线程避免了线程切换带来的开销</li>
</ol>
<p>redis是单线程，如何处理那么多的并发客户端连接？</p>
<p>redis通过”多路IO复用”机制，使用非阻塞IO轮询。</p>
<h2 id="多路复用原理"><a href="#多路复用原理" class="headerlink" title="多路复用原理"></a>多路复用原理</h2><p>在传统的同步阻塞网络编程模型里，性能上不来的根本原因是频繁地切换进程线程上下文，一个用户请求会让一个进程去处理。</p>
<p>而<strong>多路复用</strong>让很多的用户连接来复用同一个进(线)程，<strong>多路</strong>指的是许许多多个用户的网络连接。<strong>复用</strong>指的是对进(线)程的复用。但是要在一个进程中管理各个socket的文件描述符。需要有 socket 事件管理机制。select&#x2F;poll&#x2F;epoll&#x2F;kqueue，这里epoll是目前linux最常见的也行比较新的，普遍的。以epoll为例：</p>
<p>epoll主要有3个方法</p>
<ul>
<li>epoll_create 顾名思义，创建一个epoll</li>
<li>epoll_ctl 根据参数的不同用来添加一个fd到epoll或者删除等。</li>
<li>epoll_wait 获取事件，根据参数的不同，可以是阻塞，非阻塞，有限等待等方式。</li>
</ul>
<p>大致如下：</p>
<img src="/2022/10/05/redis/epoll-1.drawio.png" class="">

<p>当网卡上收到数据包后，Linux 内核进行一系列的处理后把数据放到 socket 的接收队列。然后会检查是否有 epoll 在管理它，如果是则在 epoll 的就绪队列中插入一个元素。epoll_wait 的操作就非常的简单了，就是到 epoll 的就绪队列上来查询有没有事件发生就行了。</p>
<p>读写事件是怎么被触发的？</p>
<p>看接收缓冲是否有数据和发送缓冲是否有数据。当数据到来，接收缓冲有数据，就往epoll的就绪队列添加读事件。当数据发送，发送缓冲腾出空间，就往epoll的就绪队列添加写事件。</p>
<p>接下来，我们直接看redis代码的实现。</p>
<p>相关代码主要看 server.c 和 ae.c 和 ae_epoll.c 和 networking.c 文件。</p>
<p>和 epoll 相关的代码在 ae_epoll.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeApiState</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> epfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">events</span>;</span></span><br><span class="line">&#125; aeApiState;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">aeApiCreate</span><span class="params">(aeEventLoop *eventLoop)</span> &#123;...&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">aeApiResize</span><span class="params">(aeEventLoop *eventLoop, <span class="type">int</span> setsize)</span>  &#123;...&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">aeApiFree</span><span class="params">(aeEventLoop *eventLoop)</span>  &#123;...&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">aeApiAddEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="type">int</span> fd, <span class="type">int</span> mask)</span>  &#123;...&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">aeApiDelEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="type">int</span> fd, <span class="type">int</span> delmask)</span> &#123;...&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">aeApiPoll</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">struct</span> timeval *tvp)</span> &#123;...&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *<span class="title function_">aeApiName</span><span class="params">(<span class="type">void</span>)</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>







<p>可以在redis的主线程中看到（server.c ）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  initServer();</span><br><span class="line">  ...</span><br><span class="line">  aeSetBeforeSleepProc(server.el,beforeSleep);<span class="comment">// 各种事件注册的时候都会保存到这个数组里：eventLoop-&gt;events</span></span><br><span class="line">  aeMain(server.el);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中主要的是 initServer 和 aeMain</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initServer</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="comment">// 创建 epoll</span></span><br><span class="line">  	server.el = aeCreateEventLoop(server.maxclients+CONFIG_FDSET_INCR);</span><br><span class="line">  ...</span><br><span class="line">   	</span><br><span class="line">    <span class="comment">// 打开监听socket</span></span><br><span class="line">    <span class="keyword">if</span> (server.port != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        listenToPort(server.port,server.ipfd,&amp;server.ipfd_count) == C_ERR)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">...</span><br><span class="line">		<span class="comment">/* Create the serverCron() time event, that&#x27;s our main way to process</span></span><br><span class="line"><span class="comment">     * background operations. */</span></span><br><span class="line">    <span class="keyword">if</span>(aeCreateTimeEvent(server.el, <span class="number">1</span>, serverCron, <span class="literal">NULL</span>, <span class="literal">NULL</span>) == AE_ERR) &#123; <span class="comment">///注册服务定时任务</span></span><br><span class="line">        serverPanic(<span class="string">&quot;Can&#x27;t create the serverCron time event.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">  	<span class="comment">// 注册监听READ事件和对应事件的处理函数 acceptTcpHandler</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.ipfd_count; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE,  <span class="comment">// 注册读事件处理逻辑</span></span><br><span class="line">            acceptTcpHandler,<span class="literal">NULL</span>) == AE_ERR)</span><br><span class="line">            &#123;</span><br><span class="line">                serverPanic(</span><br><span class="line">                    <span class="string">&quot;Unrecoverable error creating server.ipfd file event.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (server.sofd &gt; <span class="number">0</span> &amp;&amp; aeCreateFileEvent(server.el,server.sofd,AE_READABLE,</span><br><span class="line">        acceptUnixHandler,<span class="literal">NULL</span>) == AE_ERR) serverPanic(<span class="string">&quot;Unrecoverable error creating server.sofd file event.&quot;</span>);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>redis server 在初始化中listen端口并注册了对应事件的处理函数，这里主要关注三个函数：</p>
<ul>
<li>aeCreateEventLoop</li>
<li>aeCreateFileEvent</li>
<li>aeMain(server.el)</li>
</ul>
<p>aeCreateEventLoop中 调用了 aeApiCreate，我们可以看到aeApiCreate 中使用的 <strong>epoll_create</strong> 创建epoll</p>
<p>aeCreateFileEvent 中 调用了 aeApiAddEvent，我们可以看到aeApiAddEvent 中使用 **epoll_ctl ** 注册事件</p>
<p>aeMain 中 for 轮询调用aeProcessEvents，aeProcessEvents 调用了aeApiPoll，aeApiPoll中使用了 <strong>epoll_wait</strong> 拉取事件</p>
<p>在 aeCreateFileEvent 函数中，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">aeCreateFileEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="type">int</span> fd, <span class="type">int</span> mask,</span></span><br><span class="line"><span class="params">        aeFileProc *proc, <span class="type">void</span> *clientData)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    aeFileEvent *fe = &amp;eventLoop-&gt;events[fd];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (aeApiAddEvent(eventLoop, fd, mask) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> AE_ERR;</span><br><span class="line">    fe-&gt;mask |= mask;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_READABLE) fe-&gt;rfileProc = proc;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_WRITABLE) fe-&gt;wfileProc = proc;</span><br><span class="line">    fe-&gt;clientData = clientData;</span><br><span class="line">    <span class="keyword">if</span> (fd &gt; eventLoop-&gt;maxfd)</span><br><span class="line">        eventLoop-&gt;maxfd = fd;</span><br><span class="line">    <span class="keyword">return</span> AE_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 aeCreateFileEvent 将 proc，给到了eventLoop中的events 的 rfileProc ，对应的就是 看 initServer中 <code>aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE, acceptTcpHandler,NULL)</code>   acceptTcpHandler。</p>
<p>在 aeMain函数中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> &#123;</span><br><span class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!eventLoop-&gt;stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;beforesleep != <span class="literal">NULL</span>)</span><br><span class="line">            eventLoop-&gt;beforesleep(eventLoop); <span class="comment">// </span></span><br><span class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>redis 轮询 执行  <code>aeProcessEvents(eventLoop, AE_ALL_EVENTS)</code> 和 <code>beforesleep(eventLoop);</code></p>
<p>而aeProcessEvents 是主要的处理逻辑，主要关注的代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">aeProcessEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">if</span> (eventLoop-&gt;maxfd != <span class="number">-1</span> ||</span><br><span class="line">        ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) &#123;</span><br><span class="line">      ...</span><br><span class="line">    		numevents = aeApiPoll(eventLoop, tvp); <span class="comment">// 拉取检查事件</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</span><br><span class="line">            aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];</span><br><span class="line">            <span class="type">int</span> mask = eventLoop-&gt;fired[j].mask;</span><br><span class="line">            <span class="type">int</span> fd = eventLoop-&gt;fired[j].fd;</span><br><span class="line">            <span class="type">int</span> rfired = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	    			<span class="comment">/* note the fe-&gt;mask &amp; mask &amp; ... code: maybe an already processed</span></span><br><span class="line"><span class="comment">             * event removed an element that fired and we still didn&#x27;t</span></span><br><span class="line"><span class="comment">             * processed, so we check if the event is still valid. */</span></span><br><span class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;  <span class="comment">// 读事件</span></span><br><span class="line">                rfired = <span class="number">1</span>;</span><br><span class="line">                fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask); <span class="comment">// 读事件对应的处理函数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123; <span class="comment">// 写事件</span></span><br><span class="line">                <span class="keyword">if</span> (!rfired || fe-&gt;wfileProc != fe-&gt;rfileProc)</span><br><span class="line">                    fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask); <span class="comment">// 写事件对应的处理函数</span></span><br><span class="line">            &#125;</span><br><span class="line">            processed++;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">  ...</span><br><span class="line">  	<span class="comment">/* Check time events */</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS)</span><br><span class="line">    processed += processTimeEvents(eventLoop);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的逻辑我们也能看到。redis单线程去 poll 事件，然后执行，只有执行完了，才可能poll下一个事件。这样每次处理只有一个线程才做。</p>
<p>简单说就是监听端口的socket 的fd每次收到epoll过来的读事件，就会对应执行 acceptTcpHandler函数。</p>
<p>看下 aeProcessEvents 中的 processTimeEvents ，他处理的是在 initServer中 注册的 serverCron的逻辑，serverConn中是一些服务器自身维护的逻辑如检查key过期时间，数据持久化等操作。不是我们理解redis 线程io模型 的重点，先不讨论，只要知道这个处理逻辑经过 <code>aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL)</code> 注册到epoll中，然后aeMain 每过一定的时间就会去执行 serverCron的逻辑。</p>
<p>我们再来看看 acceptTcpHandler 函数，他调用了 anetTcpAccept 函数。简单来说就是一个根据 监听的 socket的fd，获取新到来连接，获得tcp连接的socket的fd。acceptTcpHandler 在获取连接的fd之后，调用了 acceptCommonHandler，acceptCommonHandler主要关注的处理是调用了，createClient。代码处理如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">client *<span class="title function_">createClient</span><span class="params">(<span class="type">int</span> fd)</span> &#123;</span><br><span class="line">    client *c = zmalloc(<span class="keyword">sizeof</span>(client));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* passing -1 as fd it is possible to create a non connected client.</span></span><br><span class="line"><span class="comment">     * This is useful since all the commands needs to be executed</span></span><br><span class="line"><span class="comment">     * in the context of a client. When commands are executed in other</span></span><br><span class="line"><span class="comment">     * contexts (for instance a Lua script) we need a non connected client. */</span></span><br><span class="line">    <span class="keyword">if</span> (fd != <span class="number">-1</span>) &#123;</span><br><span class="line">        anetNonBlock(<span class="literal">NULL</span>,fd);</span><br><span class="line">        anetEnableTcpNoDelay(<span class="literal">NULL</span>,fd);</span><br><span class="line">        <span class="keyword">if</span> (server.tcpkeepalive)</span><br><span class="line">            anetKeepAlive(<span class="literal">NULL</span>,fd,server.tcpkeepalive);</span><br><span class="line">        <span class="keyword">if</span> (aeCreateFileEvent(server.el,fd,AE_READABLE,  <span class="comment">// 注册事件通知和处理函数readQueryFromClient</span></span><br><span class="line">            readQueryFromClient, c) == AE_ERR)</span><br><span class="line">        &#123;</span><br><span class="line">            close(fd);</span><br><span class="line">            zfree(c);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		...</span><br><span class="line">    <span class="keyword">if</span> (fd != <span class="number">-1</span>) listAddNodeTail(server.clients,c); <span class="comment">/// 添加到redisServer的cients链表队列里面</span></span><br><span class="line">    initClientMultiState(c);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到所有建立连接的fd都会被创建client 并作为链表node 添加到 server的client 链表。</p>
<p>在上面创建的client中。往epoll中注册了读事件通知以处理 readQueryFromClient</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">readQueryFromClient</span><span class="params">(aeEventLoop *el, <span class="type">int</span> fd, <span class="type">void</span> *privdata, <span class="type">int</span> mask)</span> &#123;</span><br><span class="line">  ... </span><br><span class="line">  nread = read(fd, c-&gt;querybuf+qblen, readlen); <span class="comment">// 读取socket数据</span></span><br><span class="line">  ...</span><br><span class="line">  processInputBuffer(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 processInputBuffer处理客户端的输入，解析，执行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// networking.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">processInputBuffer</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  	<span class="keyword">if</span> (c-&gt;reqtype == PROTO_REQ_INLINE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (processInlineBuffer(c) != C_OK) <span class="keyword">break</span>; <span class="comment">// 解析数据，</span></span><br><span class="line">    <span class="comment">// 执行命令，</span></span><br><span class="line">    ...</span><br><span class="line">      <span class="keyword">if</span> (processCommand(c) == C_OK)  <span class="comment">///执行命令</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">processInlineBuffer</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (sdslen(argv[j])) &#123;</span><br><span class="line">     c-&gt;argv[c-&gt;argc] = createObject(OBJ_STRING,argv[j]);  <span class="comment">// 对应命令</span></span><br><span class="line">     c-&gt;argc++;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// object.c</span></span><br><span class="line">robj *<span class="title function_">createObject</span><span class="params">(<span class="type">int</span> type, <span class="type">void</span> *ptr)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  o-&gt;ptr = ptr;  <span class="comment">// 命令的字符串</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后 我们关注 client 连接有读写事件时的处理 readQueryFromClient的processInputBuffer。命令主要是读取数据并根据resp解析数据，然后调用 processCommand</p>
<p>然后再看下其中最重要的<code>processCommand</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">processCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">    c-&gt;cmd = c-&gt;lastcmd = lookupCommand(c-&gt;argv[<span class="number">0</span>]-&gt;ptr); <span class="comment">// 根据之前processInlineBuffer解析的命令字符串找到对应的命令处理逻辑</span></span><br><span class="line">  ... <span class="comment">// 都是一些校验相关的逻辑。不是这次的重点，先省略</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != execCommand &amp;&amp; c-&gt;cmd-&gt;proc != discardCommand &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != multiCommand &amp;&amp; c-&gt;cmd-&gt;proc != watchCommand)</span><br><span class="line">    &#123;</span><br><span class="line">        queueMultiCommand(c);</span><br><span class="line">        addReply(c,shared.queued);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        call(c,CMD_CALL_FULL); <span class="comment">// 函数里面调用的 c-&gt;cmd-&gt;proc</span></span><br><span class="line">        c-&gt;woff = server.master_repl_offset;</span><br><span class="line">        <span class="keyword">if</span> (listLength(server.ready_keys))</span><br><span class="line">            handleClientsBlockedOnLists();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 server.c 中定义了每一个命令对应的处理函数，<code>lookupCommand</code>和<code>c-&gt;cmd-&gt;proc</code> 会找到对应的命令函数去执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> <span class="title">redisCommandTable</span>[] =</span> &#123;</span><br><span class="line">    &#123;<span class="string">&quot;get&quot;</span>,getCommand,<span class="number">2</span>,<span class="string">&quot;rF&quot;</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;set&quot;</span>,setCommand,<span class="number">-3</span>,<span class="string">&quot;wm&quot;</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;setnx&quot;</span>,setnxCommand,<span class="number">3</span>,<span class="string">&quot;wmF&quot;</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以get 命令为例，getCommand 会被执行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// t_string.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    getGenericCommand(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getGenericCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    robj *o;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.nullbulk)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;type != OBJ_STRING) &#123;</span><br><span class="line">        addReply(c,shared.wrongtypeerr);</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addReplyBulk(c,o);</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到主要两个函数 <code>lookupKeyReadOrReply</code> 和 <code>addReplyBulk</code> 系列函数会被执行，这里不是讨论线程模型的重点就不继续往下挖了。</p>
<p>其中 <code>addReplyBulk</code> 是用于设置回复数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Add a Redis Object as a bulk reply */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addReplyBulk</span><span class="params">(client *c, robj *obj)</span> &#123;</span><br><span class="line">    addReplyBulkLen(c,obj);</span><br><span class="line">    addReply(c,obj); <span class="comment">// 将返回值写入到输出缓冲区中</span></span><br><span class="line">    addReply(c,shared.crlf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addReply</span><span class="params">(client *c, robj *obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (prepareClientToWrite(c) != C_OK) <span class="keyword">return</span>; <span class="comment">// 判断是否需要返回数据，然后将client添加到等待写返回数据的队列中</span></span><br><span class="line">		...</span><br><span class="line">    <span class="keyword">if</span> (sdsEncodedObject(obj)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_addReplyToBuffer(c,obj-&gt;ptr,sdslen(obj-&gt;ptr)) != C_OK)<span class="comment">// 将返回值写入到输出缓冲区</span></span><br><span class="line">            _addReplyObjectToList(c,obj);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj-&gt;encoding == OBJ_ENCODING_INT) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Wrong obj-&gt;encoding in addReply()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">prepareClientToWrite</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">     <span class="keyword">if</span> (!clientHasPendingReplies(c) &amp;&amp;</span><br><span class="line">        !(c-&gt;flags &amp; CLIENT_PENDING_WRITE) &amp;&amp;</span><br><span class="line">        (c-&gt;replstate == REPL_STATE_NONE ||</span><br><span class="line">         (c-&gt;replstate == SLAVE_STATE_ONLINE &amp;&amp; !c-&gt;repl_put_online_on_ack)))&#123;</span><br><span class="line">       ...</span><br><span class="line">       listAddNodeHead(server.clients_pending_write,c);  <span class="comment">// 添加到等待写返回数据的队列中</span></span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上面可以知道，命令执行完后，会检查自己是否有输出要写入，但是他不会马上写入，处于性能考虑。对于服务器来说，最关心的命令执行已经结束了。输出并不是那么紧急，可以把输出写到缓冲，然后加入队列，等待写输出。队列中的每一个元素都是有待写返回数据的 client 对象。</p>
<p>然后我们再来看下 <code>_addReplyToBuffer</code> 和 <code>_addReplyStringToList</code> 这两个函数是一起的。<code>_addReplyToBuffer</code> 往缓冲中写 <code>memcpy(c-&gt;buf+c-&gt;bufpos,s,len);</code> 如果写不下了。再由<code>_addReplyStringToList</code> 添加到链表，等待下次继续写。</p>
<p>现在我们知道了。redis处理后都将输出放到缓冲，然后丢到队列里面。那么</p>
<p>由谁来消费这个队列？</p>
<p>什么时候会消费这个队列？</p>
<p>这里我们根据 注册写监听的 epoll 往上找，或者根据 这个队列的 消费函数调用者，往上找，最后找到<code>beforesleep</code></p>
<p>这个函数在 <code>aeMain</code> 函数中被轮询。在 <code>aeSetBeforeSleepProc(server.el,beforeSleep);</code>  设置的。看下这个函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">beforeSleep</span><span class="params">(<span class="keyword">struct</span> aeEventLoop *eventLoop)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">     <span class="comment">/* Handle writes with pending output buffers. */</span></span><br><span class="line">    handleClientsWithPendingWrites();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>buforeSleep 不仅仅只做输出，他其中还有很多任务逻辑。但是我们现在只关注网络io相关的。可以看到他去处理写输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">handleClientsWithPendingWrites</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">		listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    <span class="type">int</span> processed = listLength(server.clients_pending_write);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器遍历队列</span></span><br><span class="line">    listRewind(server.clients_pending_write,&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line">        c-&gt;flags &amp;= ~CLIENT_PENDING_WRITE;</span><br><span class="line">        listDelNode(server.clients_pending_write,ln);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入到fd</span></span><br><span class="line">        <span class="comment">/* Try to write buffers to the client socket. */</span></span><br><span class="line">        <span class="keyword">if</span> (writeToClient(c-&gt;fd,c,<span class="number">0</span>) == C_ERR) <span class="keyword">continue</span>;</span><br><span class="line">				</span><br><span class="line">      	<span class="comment">/* If there is nothing left, do nothing. Otherwise install</span></span><br><span class="line"><span class="comment">         * the write handler. */</span></span><br><span class="line">        <span class="keyword">if</span> (clientHasPendingReplies(c) &amp;&amp;  <span class="comment">// //判断是否写完，写不下了就注册写事件，等待下一轮的输出</span></span><br><span class="line">            aeCreateFileEvent(server.el, c-&gt;fd, AE_WRITABLE,</span><br><span class="line">                sendReplyToClient, c) == AE_ERR)</span><br><span class="line">        &#123;</span><br><span class="line">            freeClientAsync(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以看到函数的大致处理逻辑是，遍历 等待输出的链表队列，如果写不下就加入队列，注册写事件，等待下一轮的写入。</p>
<p>这里”写不下”是什么概念呢？系统为每个 socket 设置了接收缓冲和发送缓存区。出于性能考虑，我们write的参数肯定不是阻塞写。使用非阻塞写，当数据量超过写缓冲时，自然就会一部分是写不下的。</p>
<p>为什么说阻塞写性能会低？阻塞写在写不下的时候会阻塞等待发送缓冲的数据发送出去从而腾出空间，而”等待发送缓冲数据发送出去”这个时间是网络io，相比cpu在内存操作是更加耗时的。</p>
<p>我们知道读事件是数据到来，可以读取会触发。注册写事件后，这个”写事件”是怎么触发的呢？内核检查发现发送缓冲有空间的时候。其实这个读写事件准确的说，是看接收缓冲是否有数据和发送缓冲是否有数据。当数据到来，接收缓冲有数据，就往epoll的就绪队列添加读事件。当数据发送，发送缓冲腾出空间，就往epoll的就绪队列添加写事件。</p>
<p>其中主要的是 <code>writeToClient</code> ，<code>clientHasPendingReplies</code> 和 <code>aeCreateFileEvent</code> </p>
<p>现在我们知道服务器主要线程在处理什么了</p>
<ul>
<li>初始化的时候initServer 创建epoll并注册epoll 事件通知和设置对应事件处理</li>
<li>aeMain轮询的时候主要根据epoll的事件通知有两个逻辑<ul>
<li>fd的读写事件通知，调用对应的注册进来的函数</li>
<li>时间事件通知，处理定时任务 serverCron</li>
</ul>
</li>
</ul>
<p>这个根据事件类型调用的函数主要有3类：</p>
<ul>
<li>listen 的 fd 的 读事件：主要accept创建client</li>
<li>已经建立连接的tcp的fd的读事件：主要获取数据，解析并执行命令，将结果放到发送队列</li>
<li>已经建立连接的tcp的fd的写事件：主要获取发送队列中还没发送完的数据，写入到fd中。</li>
</ul>
<p>根据以上，我们可以总结出整个结构图如下：</p>
<img src="/2022/10/05/redis/redis-netio-1.drawio.png" class="">



















<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p>redis实现持久化有两种方式</p>
<ul>
<li>AOF 日志</li>
<li>RDB 快照</li>
</ul>
<p>AOF和RDB的持久化都是fork出一个子进程来进行持久化的。而为什么能这么做，主要是用到操作系统一个写时复制的机制</p>
<h2 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h2><p>写时复制是什么？父进程刚fork出子进程的时候，父进程和子进程的数据段和代码段是一样的。而且操作系统虽然让两者看起来都有自己的数据段，但是实际上他们各自的页表的物理页指向的是同一份。当父进程修改数据时，操作系统才会把这一页物理页换成新的物理页。而子进程只做持久化，不会去修改业务数据，子进程的数据还是在fork那一刻的整个数据状态。相当于父进程fork的时候的整个内存数据的快照。</p>
<p>如图：</p>
<img src="/2022/10/05/redis/copy-on-write-1.drawio.png" class="">







<h2 id="AOF日志"><a href="#AOF日志" class="headerlink" title="AOF日志"></a>AOF日志</h2><p>Redis 每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里，然后重启 Redis 的时候，先去读取这个文件里的命令，并且执行它，这种保存写操作命令到日志的持久化方式，就是 Redis 里的 <strong>AOF(*Append Only File*)</strong> 持久化功能，<strong>注意只会记录写操作命令，读操作命令是不会被记录的</strong></p>
<p>AOF 日志文件其实就是普通的文本，我们可以通过 <code>cat</code> 命令查看里面的内容。当然，里面的内容是按RESP存储的。</p>
<p>随着执行的写操作命令越来越多，文件的大小会越来越大。如果当 AOF 日志文件过大就会带来性能问题，比如重启 Redis 后，需要读 AOF 文件的内容以恢复数据，如果文件过大，整个恢复的过程就会很慢。</p>
<p>所以redis为AOF提供了<strong>AOF 重写机制</strong>，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。AOF 重写机制是在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件。</p>
<p>根据 <code>struct redisCommand redisCommandTable[]</code> 中的命令，我们可以看到<code>bgrewriteaof</code>  命令使用了 <code>bgrewriteaofCommand</code> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bgrewriteaofCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (server.aof_child_pid != <span class="number">-1</span>) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">&quot;Background append only file rewriting already in progress&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span>) &#123;</span><br><span class="line">        server.aof_rewrite_scheduled = <span class="number">1</span>;</span><br><span class="line">        addReplyStatus(c,<span class="string">&quot;Background append only file rewriting scheduled&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rewriteAppendOnlyFileBackground() == C_OK) &#123;</span><br><span class="line">        addReplyStatus(c,<span class="string">&quot;Background append only file rewriting started&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addReply(c,shared.err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">rewriteAppendOnlyFileBackground</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">if</span> ((childpid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道redis处理命令是单线程，如果进行备份写日志，就还有进行文件的io操作，而文件io操作明显属于慢操作。为了不阻塞主线程，redis需要一边持久化，一边处理客户端的请求。而持久化的时候，内存数据还在改变，比如一个key在持久化，结果一个请求过来吧key删掉了。所以redis使用fork 出子进程来处理：</p>
<ul>
<li>子进程进行 AOF 重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程；</li>
<li>子进程和父进程都有自己的一份数据结构（虽然底层依然是相同的物理页，但os会保证他们逻辑上改动都是自己的数据，通过写时复制机制）。父进程去处理命令的时候不需要担心内存数据冲突，无需加锁。</li>
</ul>
<p>而子进程在持久化时，父进程在这期间修改的数据可以留到下一次aof的时候再做持久化。</p>
<p>关于数据安全问题：</p>
<p>AOF日志是以文件的形式存储的，当程序对aof日志文件进行些操作的时候，实际上是将内容写到了内核文件描述符分配的一个内存缓冲上。然后内核会异步将脏数据刷回磁盘。</p>
<p>如果此时机器突然宕机，aof日志内容可能还没有来得及刷回磁盘，这个时候就会丢失日志。</p>
<p>在操作系统中，提供一个一个fsync的函数，可以指定让os强制将缓冲刷回磁盘。只有redis进程调用fsyn函数就可以保证aof日志不丢失，但是fsync是io操作，会影响redis高性能地处理命令。</p>
<p>所以在生产环节中，redis通常都是每隔1s左右执行一次fsync操作。至于实际多少秒，则是在数据安全和性能之间做一个权衡。</p>
<p>AOF的缺点：</p>
<p>AOF体积更大，占用空间，启动的时候要取一条一条的执行，启动慢。</p>
<p>AOF的优点：</p>
<p>增量保存，使得每次保存耗时小。</p>
<h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>RDB 文件的内容是二进制数据。</p>
<p>Redis 的快照是<strong>全量快照</strong>，也就是说每次执行快照，都是把内存中的「所有数据」都记录到磁盘中。</p>
<p>RDB 快照就是记录某一个瞬间的内存数据，记录的是实际数据，而 AOF 文件记录的是命令操作的日志，而不是实际的数据。</p>
<p>Redis 提供了两个命令来生成 RDB 文件，分别是 <code>save</code> 和 <code>bgsave</code>，他们的区别就在于是否在「主线程」里执行：</p>
<ul>
<li>执行了 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，<strong>会阻塞主线程</strong>；</li>
<li>执行了 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样可以<strong>避免主线程的阻塞</strong>；</li>
</ul>
<p>RDB 文件的加载工作是在服务器启动时自动执行的，Redis 并没有提供专门用于加载 RDB 文件的命令。</p>
<p>Redis 还可以通过配置文件的选项来实现每隔一段时间自动执行一次 bgsave 命令，默认会提供以下配置：</p>
<p>在 redis的定时任务<code>serverCron</code> 中，有一项工作是执行RDB持久化<code>rdbSaveBackground</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">serverCron</span><span class="params">(<span class="keyword">struct</span> aeEventLoop *eventLoop, <span class="type">long</span> <span class="type">long</span> id, <span class="type">void</span> *clientData)</span> &#123;</span><br><span class="line">		...</span><br><span class="line">    <span class="keyword">if</span> (rdbSaveBackground(server.rdb_filename) == C_OK)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rdb.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rdbSaveBackground</span><span class="params">(<span class="type">char</span> *filename)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">   <span class="keyword">if</span> ((childpid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 rdb 是每隔一段时间就fork子进程去执行。所以配置文件中 的配置实际上是每隔一段时间就fork出子进程。</p>
<p>RDB的缺点：</p>
<p>因为RDB是全量保存数据，所以在生产环境中，每次执行的间隔会比较大，例如5分钟，15分钟。在服务器发生故障时，丢失的数据会比 AOF 持久化的方式更多，因为 RDB 快照是全量快照的方式，因此执行的频率不能太频繁，否则会影响 Redis 性能，而 AOF 日志可以以秒级的方式记录操作命令，所以丢失的数据就相对更少。</p>
<p>RDB的优点：</p>
<p>因为RDB是二进制的全量快照，所以存储方面相比AOF会更节省空间。</p>
<h2 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h2><p>根据AOF和RDB各自的优缺点。我们可以选择两者混合的方式来持久化。</p>
<p>每次RDB都会把当前的快照持久化下来，同时在RDB的时候AOF重写开始记录。</p>
<p>在redis重启的时候，先加载RDB，在重放AOF。</p>
<p>在这里，AOF日志不再是全量日志，而是在RDB开始到下一次RDB开始之间的增量日志。如下图：</p>
<img src="/2022/10/05/redis/redis-rdb-aof.drawio.png" class="">









<p>扩展：</p>
<p>在传统的数据库中，都是先写日志再执行命令，而redis是先执行命令，再去写日志，为什么？</p>
<p>其他数据库优先做持久化再执行命令是因为，数据库更注重”数据不丢失”，”数据一致性”等问题。</p>
<p>而redis更多担任的是一个缓存的角色。更注重效率，如果redis先写日志再执行，对于client来说就太慢了。</p>
<h1 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h1><p>redis的key可以设置一个过期时间。</p>
<p>redis处理过期的key有两种途径</p>
<ul>
<li>定期扫描清理</li>
<li>懒惰删除</li>
</ul>
<h2 id="定期扫描策略"><a href="#定期扫描策略" class="headerlink" title="定期扫描策略"></a>定期扫描策略</h2><p>redis会将每个设置了过期时间的key放入一个独立的map中，之后会定期便利这个map来删除到期的key，如下 expires 就是存放，dict就是字典类型的数据结构，我习惯叫做map，以下统称map</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    dict *dict;                 <span class="comment">/* The keyspace for this DB */</span></span><br><span class="line">    dict *expires;              <span class="comment">/* Timeout of keys with a timeout set */</span></span><br><span class="line">    dict *blocking_keys;        <span class="comment">/* Keys with clients waiting for data (BLPOP) */</span></span><br><span class="line">    dict *ready_keys;           <span class="comment">/* Blocked keys that received a PUSH */</span></span><br><span class="line">    dict *watched_keys;         <span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> *<span class="title">eviction_pool</span>;</span>    <span class="comment">/* Eviction pool of keys */</span></span><br><span class="line">    <span class="type">int</span> id;                     <span class="comment">/* Database ID */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> avg_ttl;          <span class="comment">/* Average TTL, just for stats */</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>



<p>什么时候触发扫描策略，有两个地方调用到，一个是 <code>serverCron</code> ，一个<code>beforSleep</code> ,这两个由前面知识知道，一个是redis服务的定时任务，一个是主要线程的轮询函数之一。他们最终都调用了 <code>activeExpireCycle</code> 函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">activeExpireCycle</span><span class="params">(<span class="type">int</span> type)</span> &#123;</span><br><span class="line">  	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; dbs_per_call; j++) &#123;</span><br><span class="line">        <span class="type">int</span> expired;   <span class="comment">// 用来记录这一趟清理的过期key数量</span></span><br><span class="line">  	...</span><br><span class="line">      <span class="comment">/* Continue to expire if at the end of the cycle more than 25%</span></span><br><span class="line"><span class="comment">         * of the keys were expired. */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">          ...</span><br><span class="line">          <span class="keyword">while</span> (num--) &#123;</span><br><span class="line">                dictEntry *de;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> ttl;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((de = dictGetRandomKey(db-&gt;expires)) == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">            		ttl = dictGetSignedIntegerVal(de)-now;</span><br><span class="line">                <span class="keyword">if</span> (activeExpireCycleTryExpire(db,de,now)) expired++;</span><br><span class="line">               	...</span><br><span class="line">          &#125;</span><br><span class="line">          ...</span><br><span class="line">          <span class="keyword">if</span> (timelimit_exit) <span class="keyword">return</span>;  <span class="comment">// 超时就退出</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (expired &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP/<span class="number">4</span>); <span class="comment">// 如果过期的key超过25%，说明过期key挺多，继续清理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>redis过期扫描不会遍历过期字典中的所有key，步骤如下：</p>
<ol>
<li>从过期字典中随机选出20个key。</li>
<li>删除这20个key中已经过期的key。</li>
<li>如果过期的key比例超过1&#x2F;4，那就重复步骤1。</li>
</ol>
<p>同时，为了保证过期扫描不会出现一直循环，导致线程一直在做过期扫描的情况，redis限制了扫描时间。默认不会超过25ms</p>
<p>定时删除策略的<strong>优点</strong>：</p>
<ul>
<li>可以保证过期 key 会被尽快删除，也就是内存可以被尽快地释放。因此，定时删除对内存是最友好的。</li>
</ul>
<p>定时删除策略的<strong>缺点</strong>：</p>
<ul>
<li>在过期 key 比较多的情况下，删除过期 key 可能会占用相当一部分 CPU 时间，在内存不紧张但 CPU 时间紧张的情况下，将 CPU 时间用于删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响。所以，定时删除策略对 CPU 不友好。</li>
</ul>
<h2 id="懒惰删除策略"><a href="#懒惰删除策略" class="headerlink" title="懒惰删除策略"></a>懒惰删除策略</h2><p>懒惰删除就是在redis访问到这个key的时候，对key的过期时间检查，如果过期就删除，返回空key。</p>
<p>Redis 的惰性删除策略由 db.c 文件中的 <code>expireIfNeeded</code> 函数实现，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> &#123;</span><br><span class="line">  <span class="type">mstime_t</span> when = getExpire(db,key);</span><br><span class="line">  <span class="keyword">if</span> (when &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* No expire for this key */</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">/* Return when this key has not expired */</span></span><br><span class="line">    <span class="keyword">if</span> (now &lt;= when) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Delete the key */</span></span><br><span class="line">    server.stat_expiredkeys++;</span><br><span class="line">    propagateExpire(db,key);</span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_EXPIRED,</span><br><span class="line">        <span class="string">&quot;expired&quot;</span>,key,db-&gt;id);</span><br><span class="line">    <span class="keyword">return</span> dbDelete(db,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>惰性删除策略的<strong>优点</strong>：</p>
<ul>
<li>因为每次访问时，才会检查 key 是否过期，所以此策略只会使用很少的系统资源，因此，惰性删除策略对 CPU 时间最友好。</li>
</ul>
<p>惰性删除策略的<strong>缺点</strong>：</p>
<ul>
<li>如果一个 key 已经过期，而这个 key 又仍然保留在数据库中，那么只要这个过期 key 一直没有被访问，它所占用的内存就不会释放，造成了一定的内存空间浪费。所以，惰性删除策略对内存不友好。</li>
</ul>
<p>注意问题：</p>
<p>假如redis中所有的key在同一时间过期了，会出现什么情况？</p>
<p>redis会持续扫描过期字典中的key，这就会导致线上读写请求出现明显的卡顿。导致这种卡顿的另外一种原因是内存管理需要频繁地回收内存页，这会产生一定的cpu时间消耗。</p>
<p>当client请求到来时，服务器如果正好进入过期扫描状态，client的请求将会等待至少25ms后才会进行处理。如果客户端将超时时间设置得比较短，例如10ms，那么就会出现大量的链接因为超时而关闭，业务端就会出现异常，而此时还无法从redis的slowlog中看到慢查询记录，因为慢查询记录的是命令处理过程慢的。</p>
<h1 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h1><p>当redis内存超出物理内存限制时，内存的数据会开始和磁盘产生频繁的交换。</p>
<p>在生产环境中，不允许redis出现交换行为，限制最大使用内存，redis提供了配置参数maxmemory来限制内存。</p>
<p>当实际内存超出maxmemory是，redis提供了集中可选策略。来让用户自己决定如何腾出心的空间。</p>
<ul>
<li>noeviction：不继续服务写请求（默认淘汰策略）</li>
<li>volatile-random：尝试淘汰设置了过期时间的key。随机</li>
<li>volatile-lru：尝试淘汰设置了过期时间的key。设置了过期且最近最少使用的key被淘汰</li>
<li>volatile-ttl：尝试淘汰设置了过期时间的key。但是会以剩余有效期作为淘汰优先级</li>
<li>allkeys-random：随机淘汰key</li>
<li>allkeys-lru：淘汰最近最少使用的key</li>
</ul>
<p>一般来说，实现LRU会使用一个链表+map，但是lru会使用许多额外内存。所以redis实现的是近似LRU：</p>
<p>近似LRU的核心就是随机采样来淘汰。</p>
<p>redis给每个key增加了一个额外字段，用来保存最后一次被访问的时间戳。</p>
<p>发现内存超出maxmemory，就会执行一次LRU淘汰算法。</p>
<p>最急采样出5个key。然后淘汰掉最旧的key。如果淘汰后内存还是超出maxmemory，那就继续采样淘汰，直到内存低于maxmemory为止。</p>
<p>什么时候触发淘汰？在处理命令的时候，会去检查，函数如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* server.c */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">processCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">		...</span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory) &#123;</span><br><span class="line">      <span class="type">int</span> retval = freeMemoryIfNeeded();</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">freeMemoryIfNeeded</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">// 计算要free的内存空间，会一直free到空间够为止</span></span><br><span class="line">    mem_tofree = mem_used - server.maxmemory;</span><br><span class="line">    mem_freed = <span class="number">0</span>;</span><br><span class="line">    latencyStartMonitor(latency);</span><br><span class="line">    <span class="keyword">while</span> (mem_freed &lt; mem_tofree) &#123;</span><br><span class="line">      			... <span class="comment">// 还有其他各种策略的处理，这里我们就看简单的 random</span></span><br><span class="line">      			<span class="comment">/* volatile-random and allkeys-random policy */</span></span><br><span class="line">            <span class="keyword">if</span> (server.maxmemory_policy == MAXMEMORY_ALLKEYS_RANDOM ||</span><br><span class="line">                server.maxmemory_policy == MAXMEMORY_VOLATILE_RANDOM)</span><br><span class="line">            &#123;</span><br><span class="line">                de = dictGetRandomKey(dict);</span><br><span class="line">                bestkey = dictGetKey(de);  <span class="comment">// 策略选定要删除的key</span></span><br><span class="line">            &#125;</span><br><span class="line">      			...</span><br><span class="line">              </span><br><span class="line">            <span class="comment">// 删除上面策略选中的key</span></span><br><span class="line">            <span class="comment">/* Finally remove the selected key. */</span></span><br><span class="line">            <span class="keyword">if</span> (bestkey) &#123;</span><br><span class="line">              ...</span><br><span class="line">              robj *keyobj = createStringObject(bestkey,sdslen(bestkey));</span><br><span class="line">              ...</span><br><span class="line">              dbDelete(db,keyobj);</span><br><span class="line">              ...</span><br><span class="line">            &#125;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="数据结构的源码"><a href="#数据结构的源码" class="headerlink" title="数据结构的源码"></a>数据结构的源码</h1><h2 id="各种存储的数据结构底层使用的数据结构"><a href="#各种存储的数据结构底层使用的数据结构" class="headerlink" title="各种存储的数据结构底层使用的数据结构"></a>各种存储的数据结构底层使用的数据结构</h2><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>String 类型的底层的数据结构实现主要是 int 和 SDS（简单动态字符串）。</p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List 类型的底层数据结构是由<strong>双向链表或压缩列表</strong>实现的：</p>
<ul>
<li>如果列表的元素个数小于 <code>512</code> 个（默认值，可由 <code>list-max-ziplist-entries</code> 配置），列表每个元素的值都小于 <code>64</code> 字节（默认值，可由 <code>list-max-ziplist-value</code> 配置），Redis 会使用<strong>压缩列表</strong>作为 List 类型的底层数据结构；</li>
<li>如果列表的元素不满足上面的条件，Redis 会使用<strong>双向链表</strong>作为 List 类型的底层数据结构；</li>
</ul>
<p>但是<strong>在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表</strong>。</p>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>Hash 类型的底层数据结构是由<strong>压缩列表或哈希表</strong>实现的：</p>
<ul>
<li>如果哈希类型元素个数小于 <code>512</code> 个（默认值，可由 <code>hash-max-ziplist-entries</code> 配置），所有值小于 <code>64</code> 字节（默认值，可由 <code>hash-max-ziplist-value</code> 配置）的话，Redis 会使用<strong>压缩列表</strong>作为 Hash 类型的底层数据结构；</li>
<li>如果哈希类型元素不满足上面条件，Redis 会使用<strong>哈希表</strong>作为 Hash 类型的 底层数据结构。</li>
</ul>
<p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了</strong>。</p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>Set 类型的底层数据结构是由<strong>哈希表或整数集合</strong>实现的：</p>
<ul>
<li>如果集合中的元素都是整数且元素个数小于 <code>512</code> （默认值，<code>set-maxintset-entries</code>配置）个，Redis 会使用<strong>整数集合</strong>作为 Set 类型的底层数据结构；</li>
<li>如果集合中的元素不满足上面条件，则 Redis 使用<strong>哈希表</strong>作为 Set 类型的底层数据结构。</li>
</ul>
<h3 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h3><p>Zset 类型的底层数据结构是由<strong>压缩列表或跳表</strong>实现的：</p>
<ul>
<li>如果有序集合的元素个数小于 <code>128</code> 个，并且每个元素的值小于 <code>64</code> 字节时，Redis 会使用<strong>压缩列表</strong>作为 Zset 类型的底层数据结构；</li>
<li>如果有序集合的元素不满足上面的条件，Redis 会使用<strong>跳表</strong>作为 Zset 类型的底层数据结构；</li>
</ul>
<p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。</strong></p>
<hr>
<p>redis是如何保存数据的？</p>
<p>redis使用一个<strong>哈希表</strong>来保存所有键值对。哈希表其实就是一个数组，数组中的元素叫做哈希桶。</p>
<p>Redis 的哈希桶是怎么保存键值对数据的呢？</p>
<p>哈希桶存放的是指向键值对数据的指针（dictEntry*），这样通过指针就能找到键值对数据，然后因为键值对的值可以保存字符串对象和集合数据类型的对象，所以键值对的数据结构中并不是直接保存值本身，而是保存了 void * key 和 void * value 指针，分别指向了实际的键对象和值对象，这样一来，即使值是集合数据，也可以通过 void * value 指针找到。</p>
<p>Redis 中的每个对象都由 redisObject 结构表示。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*server.h*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Object types */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_STRING 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_LIST 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_SET 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ZSET 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_HASH 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Objects encoding. Some kind of objects like Strings and Hashes can be</span></span><br><span class="line"><span class="comment"> * internally represented in multiple ways. The &#x27;encoding&#x27; field of the object</span></span><br><span class="line"><span class="comment"> * is set to one of this fields for this object. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_ZIPMAP 3  <span class="comment">/* Encoded as zipmap */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_LINKEDLIST 4 <span class="comment">/* Encoded as regular linked list */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_ZIPLIST 5 <span class="comment">/* Encoded as ziplist */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_EMBSTR 8  <span class="comment">/* Embedded sds string encoding */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_QUICKLIST 9 <span class="comment">/* Encoded as linked list of ziplists */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>; <span class="comment">// 标识该对象存储的是什么类型的对象（String 对象、 List 对象、Hash 对象、Set 对象和 Zset 对象）</span></span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>; <span class="comment">// 标识该对象使用了哪种底层的数据结构；</span></span><br><span class="line">    <span class="type">unsigned</span> lru:LRU_BITS; <span class="comment">/* lru time (relative to server.lruclock) */</span></span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line">    <span class="type">void</span> *ptr; <span class="comment">// 指向底层数据结构的指针。</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>





<p>各数据结构关系如下：</p>
<img src="/2022/10/05/redis/redis-dict-2.png" class="">







<h2 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h2><p>redis中的字符串是可以修改的字符串，在内存中是以字节数组形式存储的。redis使用c语言写的，但是redis不使用c中的字符串作为自己的字符串实现，因为c语言中的字符串的长度确定是以<code>\0</code> 作为结束符，然后遍历整个字节数组。调用一次strlen的时间复杂度是O(n)。redis选择单独使用一个数值来记录字符串长度。</p>
<p>（ps：事实上其他语言也好，用c语言实现的服务也好。出于性能考虑都会使用一个字段来记录字符串长度。c语言依然保留以<code>\0</code> 的方式是因为c语言在嵌入式领域广泛使用。而嵌入式资源宝贵，同时大部分机器对时间O(n)没有那么敏感。更重视资源的利用）</p>
<p>redis使用自己实现的字符串结构，代码如下：</p>
<p>sds.h sds.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> len; <span class="comment">/* used */</span>  </span><br><span class="line">    <span class="type">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中 </p>
<ul>
<li>len 代表字符串长度</li>
<li>alloc 代表分配空间长度</li>
<li>flag 代表sds类型（ sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64。）</li>
<li>buf 是字节数组</li>
</ul>
<p>5种sds类型的主要<strong>区别就在于，它们数据结构中的 len 和 alloc 成员变量的数据类型不同</strong>。</p>
<p>例如sdshdr32 表示表示字符数组长度和分配空间大小不能超过 2 的 32 次方。</p>
<h3 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h3><p>除了设计不同类型的结构体，Redis 在编程上还<strong>使用了专门的编译优化来节省内存空间</strong>，即在 struct 声明了 <code>__attribute__ ((packed))</code> ，它的作用是：<strong>告诉编译器取消结构体在编译过程中的优化对齐，按照实际占用字节数进行对齐</strong>。</p>
<p>比如，sdshdr16 类型的 SDS，默认情况下，编译器会按照 2 字节对齐的方式给变量分配内存，这意味着，即使一个变量的大小不到 2 个字节，编译器也会给它分配 2 个字节。</p>
<p>举个例子，假设下面这个结构体，它有两个成员变量，类型分别是 char 和 int，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test1</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"> &#125; test1;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>, <span class="keyword">sizeof</span>(test1));<span class="comment">// 8</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果输出是8</p>
<p>对应内存的分配：</p>
<img src="/2022/10/05/redis/alloc-1.png" class="">



<p>这是因为默认情况下，编译器是使用「字节对齐」的方式分配内存，虽然 char 类型只占一个字节，但是由于成员变量里有 int 类型，它占用了 4 个字节，所以在成员变量为 char 类型分配内存时，会分配 4 个字节，其中这多余的 3 个字节是为了字节对齐而分配的，相当于有 3 个字节被浪费掉了。</p>
<p>如果不想编译器使用字节对齐的方式进行分配内存，可以采用了 <code>__attribute__ ((packed))</code> 属性定义结构体，这样一来，结构体实际占用多少内存空间，编译器就分配多少空间。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>((<span class="title">packed</span>)) <span class="title">test2</span>  &#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"> &#125; test2;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>, <span class="keyword">sizeof</span>(test2));</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时打印的结果是 5（1 个字节 char + 4 字节 int）。</p>
<img src="/2022/10/05/redis/alloc-2.png" class="">



<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>redis数据结构如下：</p>
<p>adlist.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="type">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>



<p>结构如下图：</p>
<img src="/2022/10/05/redis/redis-linklist.png" class="">



<p>链表的缺陷:</p>
<ul>
<li>链表每个节点之间的内存都是不连续的，意味着<strong>无法很好利用 CPU 缓存</strong>。能很好利用 CPU 缓存的数据结构就是数组，因为数组的内存是连续的，这样就可以充分利用 CPU 缓存来加速访问。</li>
<li>还有一点，保存一个链表节点的值都需要一个链表节点结构头的分配，<strong>内存开销较大</strong>。</li>
</ul>
<p>因此，Redis在数据量较小的情况下会使用压缩列表来存储节省空间。</p>
<h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><p>&#x2F;&#x2F; 内存紧凑型的数据结构,，占用一块连续的内存空间，不仅可以利用 CPU 缓存</p>
<p>&#x2F;&#x2F;优缺点</p>
<p>&#x2F;&#x2F; 连锁更新问题</p>
<p>&#x2F;&#x2F;ziplist</p>
<p>&#x2F;&#x2F;quicklist</p>
<p>&#x2F;&#x2F;listpack</p>
<p>redis5.0 引进了一个新的数据结构listpack，他是对ziplist结构的改进版本，在存储空间上会更加节省。</p>
<p>&#x2F;&#x2F; 连锁更新问题</p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>代码如下：</p>
<p>dict.h dict.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *key; <span class="comment">//键值对中的键</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125; v; <span class="comment">//键值对中的值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span> <span class="comment">//指向下一个哈希表节点，形成链表</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="type">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="type">int</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>dictEntry 结构里不仅包含指向键和值的指针，还包含了指向下一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对链接起来，以此来解决哈希冲突的问题。</p>
<p>结构如下图：</p>
<img src="/2022/10/05/redis/redis-hash-1.png" class="">



<h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><p>整数集合是 Set 对象的底层实现之一。当一个 Set 对象只包含整数值元素，并且元素数量不大时，就会使用整数集这个数据结构作为底层实现。</p>
<p>intset.h intset.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding; <span class="comment">//编码方式</span></span><br><span class="line">    <span class="type">uint32_t</span> length; <span class="comment">//集合包含的元素数量</span></span><br><span class="line">    <span class="type">int8_t</span> contents[]; <span class="comment">//保存元素的数组</span></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<p>可以看到，保存元素的容器是一个 contents 数组，虽然 contents 被声明为 int8_t 类型的数组，但是实际上 contents 数组并不保存任何 int8_t 类型的元素，contents 数组的真正类型取决于 intset 结构体里的 encoding 属性的值。比如：</p>
<ul>
<li>如果 encoding 属性值为 INTSET_ENC_INT16，那么 contents 就是一个 int16_t 类型的数组，数组中每2个元素当作一个元素，类型都是 int16_t；</li>
<li>如果 encoding 属性值为 INTSET_ENC_INT32，那么 contents 就是一个 int32_t 类型的数组，数组中每2个元素当作一个元素，类型都是 int32_t；</li>
<li>如果 encoding 属性值为 INTSET_ENC_INT64，那么 contents 就是一个 int64_t 类型的数组，数组中每8个元素当作一个元素，类型都是 int64_t；</li>
</ul>
<h3 id="整数集合升级"><a href="#整数集合升级" class="headerlink" title="整数集合升级"></a>整数集合升级</h3><p>整数集合会有一个升级规则，就是当我们将一个新元素加入到整数集合里面，如果新元素的类型（int32_t）比整数集合现有所有元素的类型（int16_t）都要长时，整数集合需要先进行升级，也就是按新元素的类型（int32_t）扩展 contents 数组的空间大小，然后才能将新元素加入到整数集合里，当然升级的过程中，也要维持整数集合的有序性。</p>
<p>整数集合升级的过程不会重新分配一个新类型的数组，而是在原本的数组上扩展空间，然后在将每个元素按间隔类型大小分割，如果 encoding 属性值为 INTSET_ENC_INT16，则每个元素的间隔就是 16 位。</p>
<p>举个例子，假设有一个整数集合里有 3 个类型为 int16_t 的元素。</p>
<p>现在，往这个整数集合中加入一个新元素 65535，这个新元素需要用 int32_t 类型来保存，所以整数集合要进行升级操作，首先需要为 contents 数组扩容，<strong>在原本空间的大小之上再扩容多 80 位（4x32-3x16&#x3D;80），这样就能保存下 4 个类型为 int32_t 的元素</strong>。</p>
<img src="/2022/10/05/redis/redis-intset-1.png" class="">

<p>扩容完 contents 数组空间大小后，需要将之前的三个元素转换为 int32_t 类型，并将转换后的元素放置到正确的位上面，并且需要维持底层数组的有序性不变，整个转换过程如下：</p>
<img src="/2022/10/05/redis/redis-intset-2.png" class="">







<h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>





<p>&#x2F;&#x2F; todo 说明跳表的结构，增删改查过程，从概率上讲为什么时间复杂度是 logN</p>
<h2 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    quicklistNode *head;</span><br><span class="line">    quicklistNode *tail;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> count;        <span class="comment">/* total count of all entries in all ziplists */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> len;           <span class="comment">/* number of quicklistNodes */</span></span><br><span class="line">    <span class="type">int</span> fill : <span class="number">16</span>;              <span class="comment">/* fill factor for individual nodes */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> compress : <span class="number">16</span>; <span class="comment">/* depth of end nodes not to compress;0=off */</span></span><br><span class="line">&#125; quicklist;</span><br></pre></td></tr></table></figure>



<img src="/2022/10/05/redis/redis-quicklist.png" class="">



<hr>
<p>&#x2F;&#x2F; todo 写listpack</p>
<p>&#x2F;&#x2F; todo 写cluster设计，槽迁移</p>
<p>&#x2F;&#x2F; todo 写stream 数据结构</p>
]]></content>
      <categories>
        <category>database</category>
        <category>redis</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>database</tag>
      </tags>
  </entry>
</search>
