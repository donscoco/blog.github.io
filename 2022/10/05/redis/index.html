<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"donscoco.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="常用redis命令手册：http:&#x2F;&#x2F;doc.redisfans.com&#x2F; 基本数据结构和应用Redis 提供存储的5种基本数据结构：string，list，set，map，zset 下面是redis常见的应用场景： 缓存 可以string直接缓存整个对象，例如json，或者自定义的分隔符等 可以hash缓存字段经常变动的对象。例如购物车这种。 计数 因为 Redis 处理命令是单线程，所以执行命">
<meta property="og:type" content="article">
<meta property="og:title" content="redis">
<meta property="og:url" content="https://donscoco.github.io/2022/10/05/redis/index.html">
<meta property="og:site_name" content="donscoco">
<meta property="og:description" content="常用redis命令手册：http:&#x2F;&#x2F;doc.redisfans.com&#x2F; 基本数据结构和应用Redis 提供存储的5种基本数据结构：string，list，set，map，zset 下面是redis常见的应用场景： 缓存 可以string直接缓存整个对象，例如json，或者自定义的分隔符等 可以hash缓存字段经常变动的对象。例如购物车这种。 计数 因为 Redis 处理命令是单线程，所以执行命">
<meta property="og:locale">
<meta property="og:image" content="https://donscoco.github.io/2022/10/05/redis/redis-bit-1.drawio.png">
<meta property="og:image" content="https://donscoco.github.io/2022/10/05/redis/redis-hyperloglog-1.drawio.png">
<meta property="og:image" content="https://donscoco.github.io/2022/10/05/redis/redis-geohash-wiki.png">
<meta property="og:image" content="https://donscoco.github.io/2022/10/05/redis/redis-lock.drawio.png">
<meta property="og:image" content="https://donscoco.github.io/2022/10/05/redis/redis-scan-slot-1.drawio.png">
<meta property="og:image" content="https://donscoco.github.io/2022/10/05/redis/redis-scan-add.drawio.png">
<meta property="og:image" content="https://donscoco.github.io/2022/10/05/redis/redis-scan-2.drawio.png">
<meta property="og:image" content="https://donscoco.github.io/2022/10/05/redis/redis-scan.drawio.png">
<meta property="og:image" content="https://donscoco.github.io/2022/10/05/redis/redis-net-1.drawio.png">
<meta property="og:image" content="https://donscoco.github.io/2022/10/05/redis/epoll-1.drawio.png">
<meta property="og:image" content="https://donscoco.github.io/2022/10/05/redis/redis-netio-1.drawio.png">
<meta property="og:image" content="https://donscoco.github.io/2022/10/05/redis/copy-on-write-1.drawio.png">
<meta property="og:image" content="https://donscoco.github.io/2022/10/05/redis/redis-rdb-aof.drawio.png">
<meta property="og:image" content="https://donscoco.github.io/2022/10/05/redis/redis-dict-2.png">
<meta property="og:image" content="https://donscoco.github.io/2022/10/05/redis/alloc-1.png">
<meta property="og:image" content="https://donscoco.github.io/2022/10/05/redis/alloc-2.png">
<meta property="og:image" content="https://donscoco.github.io/2022/10/05/redis/redis-linklist.png">
<meta property="og:image" content="https://donscoco.github.io/2022/10/05/redis/redis-hash-1.png">
<meta property="og:image" content="https://donscoco.github.io/2022/10/05/redis/redis-intset-1.png">
<meta property="og:image" content="https://donscoco.github.io/2022/10/05/redis/redis-intset-2.png">
<meta property="og:image" content="https://donscoco.github.io/2022/10/05/redis/redis-quicklist.png">
<meta property="article:published_time" content="2022-10-04T16:00:00.000Z">
<meta property="article:modified_time" content="2023-01-08T20:02:33.510Z">
<meta property="article:author" content="donscoco">
<meta property="article:tag" content="数据库">
<meta property="article:tag" content="database">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://donscoco.github.io/2022/10/05/redis/redis-bit-1.drawio.png">

<link rel="canonical" href="https://donscoco.github.io/2022/10/05/redis/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'default'
  };
</script>

  <title>redis | donscoco</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">donscoco</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="https://donscoco.github.io/2022/10/05/redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Misaka.jpg">
      <meta itemprop="name" content="donscoco">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="donscoco">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          redis
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-10-05 00:00:00" itemprop="dateCreated datePublished" datetime="2022-10-05T00:00:00+08:00">2022-10-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-09 04:02:33" itemprop="dateModified" datetime="2023-01-09T04:02:33+08:00">2023-01-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/database/" itemprop="url" rel="index"><span itemprop="name">database</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/database/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>常用redis命令手册：<a target="_blank" rel="noopener" href="http://doc.redisfans.com/">http://doc.redisfans.com/</a></p>
<h1 id="基本数据结构和应用"><a href="#基本数据结构和应用" class="headerlink" title="基本数据结构和应用"></a>基本数据结构和应用</h1><p>Redis 提供存储的5种基本数据结构：string，list，set，map，zset</p>
<p>下面是redis常见的应用场景：</p>
<p><strong>缓存</strong></p>
<p>可以string直接缓存整个对象，例如json，或者自定义的分隔符等</p>
<p>可以hash缓存字段经常变动的对象。例如购物车这种。</p>
<p><strong>计数</strong></p>
<p>因为 Redis 处理命令是单线程，所以执行命令的过程是原子的。因此 String 数据类型适合计数场景，比如计算访问次数、点赞、转发、库存数量等等。</p>
<p><strong>点赞</strong></p>
<p>Set 类型可以保证一个用户只能点一个赞，例如以文章id作为key，用户id作为val。</p>
<p><strong>排重</strong></p>
<p>Set的不可重复特性</p>
<p><strong>共同关注</strong></p>
<p>Set 类型支持交集运算，所以可以用来计算共同关注的好友、公众号等。</p>
<p><strong>分布式锁</strong></p>
<p>SET 命令有个 NX 参数可以实现「key不存在才插入」，可以用它来实现分布式锁：</p>
<p><strong>共享 Session 信息</strong></p>
<p><strong>排行榜</strong></p>
<p>利用zset有序特性</p>
<p><strong>排序</strong></p>
<p>利用zset 有序特性</p>
<p><strong>统计签到（二值类数值存储）</strong></p>
<p>利用bitmap 的bit 数组的有序性和二值性。</p>
<p><strong>判断用户是否登陆（二值类数值存储）</strong></p>
<p>利用bitmap存储数据的二值性，用户可以用id代表数组索引</p>
<p><strong>uv统计</strong></p>
<p>使用hyperloglog命令</p>
<p><strong>地理位置计算</strong></p>
<p>使用geo命令</p>
<p><strong>消息队列</strong></p>
<p>利用list的存储数据的有序性（左边进，右边出，先进先出）</p>
<p><strong>延时队列</strong></p>
<p>利用zset的score特性，按照时间来，相当于优先队列。</p>
<p><strong>进程通信</strong></p>
<p>发布订阅组件</p>
<p><strong>限流</strong></p>
<h1 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h1><p>在平时的开发过程中，会有一些bool类型数据需要存取，比如用户一年的签到记录，要记录365天。如果直接使用int或者map记录，每个用户要记录365，当用户数很多时，需要的存储空间也会很大。为了解决这个问题，可以使用redis的位图。</p>
<p>位图的优势在于存取 二值 类型的信息，可以节省很多存储空间</p>
<p>位图的特性保存的主要有两个信息，一个是本身是数组的”顺序信息”，一个是bit数据的”二值信息”</p>
<p>所以对于365天的时间”顺序信息”，每天是否签到的”二值类信息”的场景非常适合。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>setbit</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">setbit key offset value</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; setbit key1 1 1 <span class="comment">## 设置索引1（第二个位置的bit）的值为1</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit key1 7 1 <span class="comment">## 设置索引7（第八个位置的bit）的值为1</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit key1 6 0 <span class="comment">## 设置索引6（第七个位置的bit）的值为0</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit key1 14 1 <span class="comment">## 设置索引14（第七个位置的bit）的值为1</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit key1 9 1 <span class="comment">## 设置索引9（第七个位置的bit）的值为1</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">&quot;AB&quot;</span></span><br></pre></td></tr></table></figure>



<p>getbit</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getbit key offset</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; getbit key1 1 <span class="comment">## 获取索引1（第二个位置的bit）的值</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit key1 7 <span class="comment">## 获取索引7（第八个位置的bit）的值</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit key1 6 <span class="comment">## 获取索引6（第七个位置的bit）的值</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>



<p>bitcount</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bitcount key [start end]  <span class="comment">## start和end指的是string的[]byte索引位置，并非bit位置。例如 0 1 是值0号索引和1号索引中的bit个数</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; bitcount key1 <span class="comment">## 获取整个key1 字符串的bit个数</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; bitcount key1 0 0 <span class="comment">## 获取索引0的字符和到索引0的字符的bit个数</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; bitcount key1 0 1 <span class="comment">## 获取索引0的字符和到索引1的字符的bit个数</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; bitcount key1 1 1  <span class="comment">## 获取索引1的字符和到索引1的字符的bit个数</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">&quot;AB&quot;</span></span><br></pre></td></tr></table></figure>



<p>bitpos</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bitpos key bit [start end]  <span class="comment"># 获取指定范围的第一个bit的索引</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; bitpos key1 0 <span class="comment">## 全范围获取第一个0bit的索引</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; bitpos key1 1 <span class="comment">## 全范围获取第一个1bit的索引</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; bitpos key1 1 1 2 <span class="comment">## 获取第一个1bit的索引，范围从 []byte第一个索引算起到 []byte 第二个索引结束</span></span><br><span class="line">(<span class="built_in">integer</span>) 9</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>bitfield</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">bitfield key [get <span class="built_in">type</span> offset] [<span class="built_in">set</span> <span class="built_in">type</span> offset value] [INCRBY <span class="built_in">type</span> offset increment]</span><br><span class="line"><span class="comment">## bitfield 中的 offset 范围指的是bit的offset，不是byte的，一般offset指的bit偏移，start end 指的 byte的索引</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; bitfield key1 get u8 0 <span class="comment">## 取无符号的8位bit，从0号位置开始往后取</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 65  <span class="comment"># &#x27;A&#x27; 就是65</span></span><br><span class="line">127.0.0.1:6379&gt; bitfield key1 get u8 8 <span class="comment">## 取无符号的8位bit，从8号位置开始往后取</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 66 <span class="comment"># &#x27;B&#x27; 就是66</span></span><br><span class="line">127.0.0.1:6379&gt; bitfield key1 get u8 0 get u8 8 <span class="comment">## 批量获取</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 65</span><br><span class="line">2) (<span class="built_in">integer</span>) 66</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量设置</span></span><br><span class="line">127.0.0.1:6379&gt; bitfield key1 <span class="built_in">set</span> u8 16 67 <span class="built_in">set</span> u8 24 68</span><br><span class="line">1) (<span class="built_in">integer</span>) 0</span><br><span class="line">2) (<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">&quot;ABCD&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定范围修改</span></span><br><span class="line">127.0.0.1:6379&gt; bitfield key1 incrby u8 24 1</span><br><span class="line">1) (<span class="built_in">integer</span>) 69</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">&quot;ABCE&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; bitfield key1 incrby u8 24 2 </span><br><span class="line">1) (<span class="built_in">integer</span>) 70</span><br><span class="line">127.0.0.1:6379&gt; bitfield key1 incrby u8 24 -2</span><br><span class="line">1) (<span class="built_in">integer</span>) 68</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## ps： u8 不是固定的，还有有符号  i8，当然也不只是8，还可以是各种步长，但是为了方便，一个byte就是8个bit，以及方便从字符对应到ascii码处理，平时最好还是以u8为步长去处理。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>位图并不是独立数据结构，他本质还是原来的string数据结构。对位图的操作其实就是对string的[]byte 数组操作。</p>
<p>如图：</p>
<img src="/2022/10/05/redis/redis-bit-1.drawio.png" class="">



<p>redis 的位图是自动扩展的，如果设置的偏位置超出了第一个字符byte的8位，就会自动将[]byte数组扩展，就像看到到 “A” -&gt; “AB” 一样。</p>
<h1 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h1><p>统计PV可以直接加一个计数器，记录每天的数值值即可。</p>
<p>统计UV需要排重复，统计每个用户，不能重复计算，如果给每个用户单独设置一个set数据结构。当数据量很大时，会非常占用内存空间，而我们仅仅只是想统计一个uv而已。而我们对这个uv的数据不需要太精确，所以redis出了一个HyperLogLog，可以用于处理这种独立统计的场景。</p>
<h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>HyperLogLog的使用主要是三个命令</p>
<ul>
<li>pfadd  增加计数</li>
<li>pfcount   统计计数</li>
<li>pfmerge 合并两个集合</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">pfadd key element [element...]</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; pfadd keyhll user1 <span class="comment">## 添加</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd keyhll user1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; pfadd keyhll user2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd keyhll user3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount keyhll <span class="comment">## 统计集合有多少个</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pfcount key [key...]</span><br><span class="line"><span class="comment">## pfcount 还可以合并两个集合进行统计，（两个集合中的重复元素会被排重）</span></span><br><span class="line">127.0.0.1:6379&gt; pfadd keyhll2 user1 user4 user5 user6</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount keyhll keyhll2</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line"></span><br><span class="line">pfmerge key [key...]</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; pfcount keyhll keyhll2</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; pfmerge keyhll3 keyhll keyhll2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;keyhll3&quot;</span></span><br><span class="line">2) <span class="string">&quot;keyhll2&quot;</span></span><br><span class="line">3) <span class="string">&quot;keyhll&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; pfcount keyhll3</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br></pre></td></tr></table></figure>



<h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>给定一个整数，每次记录下低位连续零位的最大长度K，当给定的整数数量足够多时，根据K值可以估算出整数数量N。</p>
<img src="/2022/10/05/redis/redis-hyperloglog-1.drawio.png" class="">

<p>&#x2F;&#x2F; todo 数学证明</p>
<p>关键在于我们对于相同的数值可以不管。</p>
<p>N&#x3D;2^K</p>
<p>N介于 2^k和2^(k+1)之间，当记录maxbit的桶足够多时，也就更精确。</p>
<p>实际上，每个创建的HyperLogLog占用的空间只有12kb，这12kb就是记录了2^14个桶，每个桶的maxbit占用6bit，12kb&#x3D;(2^14)*6&#x2F;8</p>
<h1 id="GEO地理位置计算"><a href="#GEO地理位置计算" class="headerlink" title="GEO地理位置计算"></a>GEO地理位置计算</h1><p>对于寻找附近的人的场景，redis提供了geo的相关指令。</p>
<p>GEO 底层本身并没有设计新的底层数据结构，而是直接使用了 zset 集合类型。通过geohash算法，实现二维的经纬度数据转换到一维的数据。然后对二维地图做区间划分，然后对区间进行编码。转换后的一维数据在这进行编码排序后的区间中找到自己的区间，zset存的就是区间的编码值，按照编码值作为分数进行排序。</p>
<p>当要寻找对应坐标附近的点时，在这个一维的线上获取附近的点即可。</p>
<p>如图转化过程</p>
<img src="/2022/10/05/redis/redis-geohash-wiki.png" class="">



<p>现在存在一个问题，就是当我们是图中2号节点，想查找附近的点时，看到这条线串起来的附近的点只有 0,1,2,3 但是8号节点就在附近，是否会漏掉？</p>
<p>1.一般当我们以某个节点为坐标寻找附近的点时，都是相对于这个坐标比较大的范围，例如以2节点为中心画个圆，这个圆的半径不会是小到只包括邻近的区域，一般都是较大的范围，而这个范围足够包括图中 2-3-4-5-6-7-8 这个长度</p>
<p>2.当划分的区域足够多时，划分的次数更多，区域更多，区域面积更小了，也会更精确。</p>
<h2 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h2><p>redis提供GEO的指令有6个</p>
<ul>
<li>geoadd</li>
<li>geodist</li>
<li>geopos</li>
<li>geohash</li>
<li>georadiusbymember</li>
<li>georadius</li>
</ul>
<p>添加成员坐标</p>
<p>ps：geo没有单独提供删除指令，但是geo本质是一个zset，可以type看一下，删除可以使用zrem指令删除</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">geoadd key longtitude latitude member</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; geoadd company 116.48105 39.996794 juejin</span><br><span class="line">127.0.0.1:6379&gt; geoadd company 116.514203 39.905409 ireader</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd company 116.489033 40.007669 meituan</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd company 116.562108 39.787602 jd 116.334255 40.027400 xiaomi</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure>



<p>计算两个元素之间的距离</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">geodist key member1 member2 [unit]</span><br><span class="line">127.0.0.1:6379&gt; geodist company juejin ireader km</span><br><span class="line"><span class="string">&quot;10.5501&quot;</span></span><br></pre></td></tr></table></figure>



<p>获取元素位置</p>
<p>以下可以看到获取到的经纬度和geoadd进去的坐标有误差，是因为geohash对二维坐标进行的映射后不是放原来自己的精确值，一组经纬度落在某个区间后，就用区间的编码值来表示，并把编码值作为zset 元素的权重分数。相当于一个个槽位，存放的时候以这些槽位为准。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">geopos key1 member</span><br><span class="line">127.0.0.1:6379&gt; geopos company juejin</span><br><span class="line">1) 1) <span class="string">&quot;116.48104995489120483&quot;</span></span><br><span class="line">   2) <span class="string">&quot;39.99679348858259686&quot;</span></span><br></pre></td></tr></table></figure>



<p>获取元素的hash值</p>
<p>geo可以获取元素的经纬度编码后的字符串，他是以base32编码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">geohash key member</span><br><span class="line">127.0.0.1:6379&gt; geohash company juejin</span><br><span class="line">1) <span class="string">&quot;wx4gd94yjn0&quot;</span></span><br></pre></td></tr></table></figure>



<p>根据成员信息来查询附近元素</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">georadiusbymember key member redius [unit] [withcoord][withdist][withhash][count n][asc|desc]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找ireader 附近 20 km 以内的3个成员，按距离正排</span></span><br><span class="line">127.0.0.1:6379&gt; georadiusbymember company ireader 20 km count 3 asc</span><br><span class="line">1) <span class="string">&quot;ireader&quot;</span></span><br><span class="line">2) <span class="string">&quot;juejin&quot;</span></span><br><span class="line">3) <span class="string">&quot;meituan&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># georadiusbymember 有三个可选参数 withcoord withdist withhash </span></span><br><span class="line"><span class="comment"># withhash 显示原始坐标</span></span><br><span class="line"><span class="comment"># withdist 显示距离</span></span><br><span class="line"><span class="comment"># withhash 显示坐标的hash值</span></span><br><span class="line">127.0.0.1:6379&gt; georadiusbymember company ireader 20 km withcoord withhash withdist count 3 asc</span><br><span class="line">1) 1) <span class="string">&quot;ireader&quot;</span></span><br><span class="line">   2) <span class="string">&quot;0.0000&quot;</span></span><br><span class="line">   3) (<span class="built_in">integer</span>) 4069886008361398</span><br><span class="line">   4) 1) <span class="string">&quot;116.5142020583152771&quot;</span></span><br><span class="line">      2) <span class="string">&quot;39.90540918662494363&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;juejin&quot;</span></span><br><span class="line">   2) <span class="string">&quot;10.5501&quot;</span></span><br><span class="line">   3) (<span class="built_in">integer</span>) 4069887154388167</span><br><span class="line">   4) 1) <span class="string">&quot;116.48104995489120483&quot;</span></span><br><span class="line">      2) <span class="string">&quot;39.99679348858259686&quot;</span></span><br><span class="line">3) 1) <span class="string">&quot;meituan&quot;</span></span><br><span class="line">   2) <span class="string">&quot;11.5748&quot;</span></span><br><span class="line">   3) (<span class="built_in">integer</span>) 4069887179083478</span><br><span class="line">   4) 1) <span class="string">&quot;116.48903220891952515&quot;</span></span><br><span class="line">      2) <span class="string">&quot;40.00766997707732031&quot;</span></span><br></pre></td></tr></table></figure>



<p>根据坐标值来查询附近元素，应用场景例如用户根据当前坐标值查找”附近餐馆”等信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">georadius key longtitude latitude redius [unit] [count n][asc|desc]</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; georadius company 116.514202 39.905409 20 km withdist count 3 asc</span><br><span class="line">1) 1) <span class="string">&quot;ireader&quot;</span></span><br><span class="line">   2) <span class="string">&quot;0.0000&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;juejin&quot;</span></span><br><span class="line">   2) <span class="string">&quot;10.5501&quot;</span></span><br><span class="line">3) 1) <span class="string">&quot;meituan&quot;</span></span><br><span class="line">   2) <span class="string">&quot;11.5748&quot;</span></span><br></pre></td></tr></table></figure>





<p>在坐标数据过大的场景中，将坐标全部放在zset集合中，单个key数据过大，集群的槽迁移会出现卡顿现象，所以使用单独的redis实例会比较好。然后坐标信息拆分粒度。</p>
<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p>分布式锁的实现一般有两种思路</p>
<ol>
<li>一种是通过原子性，来保证只有一个人抢占到锁。</li>
<li>一种是通过串行化，来保证操作的顺序性。</li>
</ol>
<p>redis实现的分布式锁一般是第一种。利用 setnx 和 redis 单线程的特性，保证多个人setnx只有一个人会设置成功。</p>
<p>对于 2.8版本后的redis，set 支持设置 nx 和 expire 特性，所以实现分布式锁非常简单，抢占的时候直接set，退出的时候直接删除即可。</p>
<p>对于2.8版本前的redis，如下图：</p>
<img src="/2022/10/05/redis/redis-lock.drawio.png" class="">





<h1 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h1><p>限流的实现一般有3种思路：</p>
<ol>
<li>时间窗口</li>
<li>令牌</li>
<li>漏斗</li>
</ol>
<p>&#x2F;&#x2F; todo 画图</p>
<p>&#x2F;&#x2F; todo 单独写一篇限流的blog，写下demo代码</p>
<p>&#x2F;&#x2F; todo 写下设计思路</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ratelimiter</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto/sha1&quot;</span></span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/go-redis/redis&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// redis</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间窗口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> script = <span class="string">`</span></span><br><span class="line"><span class="string">local tokens_key = KEYS[1]</span></span><br><span class="line"><span class="string">local timestamp_key = KEYS[2]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">local rate = tonumber(ARGV[1])</span></span><br><span class="line"><span class="string">local capacity = tonumber(ARGV[2])</span></span><br><span class="line"><span class="string">local now = tonumber(ARGV[3])</span></span><br><span class="line"><span class="string">local requested = tonumber(ARGV[4])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">local fill_time = capacity/rate</span></span><br><span class="line"><span class="string">local ttl = math.floor(fill_time*2)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">local last_tokens = tonumber(redis.call(&quot;get&quot;, tokens_key))</span></span><br><span class="line"><span class="string">if last_tokens == nil then</span></span><br><span class="line"><span class="string">    last_tokens = capacity</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">local last_refreshed = tonumber(redis.call(&quot;get&quot;, timestamp_key))</span></span><br><span class="line"><span class="string">if last_refreshed == nil then</span></span><br><span class="line"><span class="string">    last_refreshed = 0</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">local delta = math.max(0, now-last_refreshed)</span></span><br><span class="line"><span class="string">local filled_tokens = math.min(capacity, last_tokens+(delta*rate))</span></span><br><span class="line"><span class="string">local allowed = filled_tokens &gt;= requested</span></span><br><span class="line"><span class="string">local new_tokens = filled_tokens</span></span><br><span class="line"><span class="string">if allowed then</span></span><br><span class="line"><span class="string">    new_tokens = filled_tokens - requested</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">redis.call(&quot;setex&quot;, tokens_key, ttl, new_tokens)</span></span><br><span class="line"><span class="string">redis.call(&quot;setex&quot;, timestamp_key, ttl, now)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">return &#123; allowed, new_tokens &#125;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Limit defines the maximum frequency of some events.</span></span><br><span class="line"><span class="comment">// Limit is represented as number of events per second.</span></span><br><span class="line"><span class="comment">// A zero Limit allows no events.</span></span><br><span class="line"><span class="keyword">type</span> Limit <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Inf is the infinite rate limit; it allows all events (even if burst is zero).</span></span><br><span class="line"><span class="keyword">const</span> Inf = Limit(math.MaxFloat64)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Limiter <span class="keyword">struct</span> &#123;</span><br><span class="line">	client *redis.Client</span><br><span class="line"></span><br><span class="line">	limit Limit</span><br><span class="line">	burst <span class="type">int</span></span><br><span class="line"></span><br><span class="line">	scriptHash <span class="type">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// mu sync.Mutex</span></span><br><span class="line"></span><br><span class="line">	key <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateLimiter returns a new Limiter that allows events up to rate r and permits</span></span><br><span class="line"><span class="comment">// bursts of at most b tokens.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateLimiter</span><span class="params">(r Limit, b <span class="type">int</span>, key <span class="type">string</span>, client *redis.Client)</span></span> (lmt *Limiter, err <span class="type">error</span>) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建limiter</span></span><br><span class="line">	lmt = <span class="built_in">new</span>(Limiter)</span><br><span class="line">	lmt.client = client</span><br><span class="line">	lmt.limit = r</span><br><span class="line">	lmt.burst = b</span><br><span class="line">	lmt.key = key</span><br><span class="line"></span><br><span class="line">	<span class="comment">//load script</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		timer := time.NewTicker(<span class="number">5</span> * time.Second)</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line">				lmt.loadScript()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> lmt, lmt.loadScript()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lmt *Limiter)</span></span> loadScript() <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> lmt.client == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;redis client is nil&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lmt.scriptHash = fmt.Sprintf(<span class="string">&quot;%x&quot;</span>, sha1.Sum([]<span class="type">byte</span>(script)))</span><br><span class="line">	exists, err := lmt.client.ScriptExists(lmt.scriptHash).Result()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(err)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// load script when missing.</span></span><br><span class="line">	<span class="keyword">if</span> !exists[<span class="number">0</span>] &#123;</span><br><span class="line">		_, err := lmt.client.ScriptLoad(script).Result()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Println(err)</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Every converts a minimum time interval between events to a Limit.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Every</span><span class="params">(interval time.Duration)</span></span> Limit &#123;</span><br><span class="line">	<span class="keyword">if</span> interval &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Inf</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span> / Limit(interval.Seconds())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow is shorthand for AllowN(time.Now(), 1).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> Allow() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> lim.AllowN(time.Now(), <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AllowN reports whether n events may happen at time now.</span></span><br><span class="line"><span class="comment">// Use this method if you intend to drop / skip events that exceed the rate limit.</span></span><br><span class="line"><span class="comment">// Otherwise use Reserve or Wait.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> AllowN(now time.Time, n <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> lim.reserveN(now, n).ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A Reservation holds information about events that are permitted by a Limiter to happen after a delay.</span></span><br><span class="line"><span class="comment">// A Reservation may be canceled, which may enable the Limiter to permit additional events.</span></span><br><span class="line"><span class="keyword">type</span> Reservation <span class="keyword">struct</span> &#123;</span><br><span class="line">	ok     <span class="type">bool</span></span><br><span class="line">	tokens <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lmt *Limiter)</span></span> reserveN(now time.Time, n <span class="type">int</span>) Reservation &#123;</span><br><span class="line">	<span class="keyword">if</span> lmt.client == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Reservation&#123;</span><br><span class="line">			ok:     <span class="literal">true</span>,</span><br><span class="line">			tokens: n,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	results, err := lmt.client.EvalSha(</span><br><span class="line">		lmt.scriptHash,</span><br><span class="line">		[]<span class="type">string</span>&#123;lmt.key + <span class="string">&quot;.tokens&quot;</span>, lmt.key + <span class="string">&quot;.ts&quot;</span>&#125;,</span><br><span class="line">		<span class="type">float64</span>(lmt.limit),</span><br><span class="line">		lmt.burst,</span><br><span class="line">		now.Unix(),</span><br><span class="line">		n,</span><br><span class="line">	).Result()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;fail to call rate limit: &quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> Reservation&#123;</span><br><span class="line">			ok:     <span class="literal">true</span>,</span><br><span class="line">			tokens: n,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rs, ok := results.([]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		newTokens, _ := rs[<span class="number">1</span>].(<span class="type">int64</span>)</span><br><span class="line">		<span class="keyword">return</span> Reservation&#123;</span><br><span class="line">			ok:     rs[<span class="number">0</span>] == <span class="type">int64</span>(<span class="number">1</span>),</span><br><span class="line">			tokens: <span class="type">int</span>(newTokens),</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	log.Println(<span class="string">&quot;fail to transform results&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> Reservation&#123;</span><br><span class="line">		ok:     <span class="literal">true</span>,</span><br><span class="line">		tokens: n,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="队列通信"><a href="#队列通信" class="headerlink" title="队列通信"></a>队列通信</h1><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>直接使用list数据结构，lpush，rpop或者 rpush，lpop。redis处理请求是先执行命令，再保存。不是数据库那种先写日志。所以redis不保证消息不丢失。这种队列一般用来做消息通知，而不是消费数据传输。</p>
<h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><p>延迟队列是指把当前要做的事情，往后推迟一段时间再做。延迟队列的常见使用场景有以下几种：</p>
<ul>
<li>在淘宝、京东等购物平台上下单，超过一定时间未付款，订单会自动取消；</li>
<li>打车的时候，在规定时间没有车主接单，平台会取消你的单并提醒你暂时没有车主接单；</li>
<li>点外卖的时候，如果商家在10分钟还没接单，就会自动取消订单；</li>
</ul>
<p>在 Redis 可以使用有序集合（ZSet）的方式来实现延迟消息队列的，ZSet的score用来存时间（或者当前时间+timeout），然后出队根据当前时间+timeout（或者当前时间）去获取。</p>
<h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><p>主要命令如下</p>
<ul>
<li><strong>SUBSCRIBE channel [channel …]</strong> 订阅给定的一个或多个频道的信息。</li>
<li>**PSUBSCRIBE pattern [pattern …] ** 订阅一个或多个符合给定模式的频道。</li>
<li><strong>UNSUBSCRIBE [channel [channel …]]</strong> 指示客户端退订给定的频道。</li>
<li><strong>PUNSUBSCRIBE [pattern [pattern …]]</strong> 指示客户端退订所有给定模式。</li>
<li><strong>PUBLISH channel message</strong>  将信息 <code>message</code> 发送到指定的频道 <code>channel</code> 。</li>
<li><strong>PUBSUB <subcommand> [argument [argument …]]</strong></li>
</ul>
<p>这里展示一些主要的pub sub，更多参考 redis 手册</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">## 订阅 chan1 chan2</span></span><br><span class="line">127.0.0.1:6379&gt; subscribe chan1 chan2</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line">2) <span class="string">&quot;chan1&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line">2) <span class="string">&quot;chan2&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment">## 发布到 chan1</span></span><br><span class="line">127.0.0.1:6379&gt; publish chan1 v1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment">## PUBSUB &lt;subcommand&gt; [argument [argument ...]]</span></span><br><span class="line"><span class="comment">## 查看频道数量</span></span><br><span class="line"><span class="comment">## PUBSUB CHANNELS [pattern]</span></span><br><span class="line">127.0.0.1:6379&gt; pubsub CHANNELS *</span><br><span class="line">1) <span class="string">&quot;chan2&quot;</span></span><br><span class="line">2) <span class="string">&quot;chan1&quot;</span></span><br><span class="line"><span class="comment">## 更多用法参考redis手册 http://doc.redisfans.com/</span></span><br></pre></td></tr></table></figure>





<p>pubsub 的 缺点</p>
<p>发布订阅模式，不能持久化也就无法可靠的保存消息。pubsub的发布者生产一个消息，redis会直接将相应的消费者传递过去，如果一个订阅者都没有，那么消息会被直接丢弃。例如有三个订阅者，其中一个订阅者c在中途断开连接了，发布者继续发布消息，等订阅者c重新连接上的时候，在这期间的数据已经没有了。</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>Redis 支持事务</p>
<p>传统数据库支持的事务指令都有 begin，commit 和 rollback。</p>
<p>redis对应的支持的事务指令是：multi，exec 和 discard。</p>
<p>使用如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; discard</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br></pre></td></tr></table></figure>





<p>redis的事务和传统数据库的事务不太一样，或者应该把redis支持的事务理解为一系列保证不会被打断的命令集。所有的指令在exec之前都不会执行，而是缓存在服务器的一个 <strong>事务队列</strong> 中，服务器一旦收到 exec ，才开始执行整个队列中的命令，执行完毕后一次性返回所有指令的运行结果。而且redis保证这个事务队列之心的时候不会执行其他指令。 </p>
<p>redis的事务不保证原子性，既启用multi 后，在执行的命令中，是否成功是未知的，要等到exec之后才知道结果，如果exec之后，multi和exec中间有一条命令出错，其他命令依然会执行。所以不具备原子性特性。（虽然是说命令在exec之前都不会执行，但是redis是会去检查key是否存在的，例如在命令中get 一个不存在的key，是会收到报错信息的。）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k2 v2</span><br><span class="line">(error) ERR wrong number of arguments <span class="keyword">for</span> <span class="string">&#x27;get&#x27;</span> <span class="built_in">command</span></span><br></pre></td></tr></table></figure>





<p>watch 机制</p>
<p>redis提供了一种watch机制，他是一种乐观锁，使用时，在multi 执行之前先watch 一系列key，当事务执行时，收到exec，redis会检查watch的key的情况，是否有改变，只有watch的key中有一个改变，那redis会放弃这次事务的整个命令队列的执行。</p>
<p>注意 </p>
<ul>
<li>watch是在multi前执行的。redis紧张在multi和exec之间执行watch</li>
<li>这个判断key有没有改变的依据不是multi开启的时候，而是watch开启的时候。也就是说 watch和multi之间如果有另一个进程改变了key，就注定这个事务会失败了。哪怕改变key的时候，multi还没开启。</li>
<li>watch只和连接挂钩，连接断开，watch就失效了</li>
<li>watch在执行一次事务之后就解除了。(不管事务成功还是失败)</li>
</ul>
<p>watch 使用如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; watch k1 k2 k3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k3 3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) OK</span><br><span class="line"></span><br><span class="line"><span class="comment">### 改变的情况</span></span><br><span class="line">127.0.0.1:6379&gt; watch k1 k2 k3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 22</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k3 33 <span class="comment">### 此时，在exec执行之前，在另一个进程中修改k3的值为333</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">(nil)   <span class="comment">## 执行失败，k1,k2,k3还是exec前的值</span></span><br><span class="line">127.0.0.1:6379&gt; get k3</span><br><span class="line"><span class="string">&quot;333&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line"><span class="string">&quot;2&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>













<h1 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h1><p>redis一般都保存这大量数据，当我们想查找到特定的key时候，有两种方式</p>
<p>一种是简单地使用keys，一种是使用scan。</p>
<p>第一种使用keys 一般只在测试环境等数据量少的地方时候，keys是直接遍历整个redis的map，复杂度是O(n)，而redis是单线程处理命令的。所以万一keys遍历的数据量过大，会导致其他命令卡住。</p>
<p>所以实际使用时，都是使用scan来遍历</p>
<p>scan的基本使用如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scan 0 match key* count 1000</span><br><span class="line">1) <span class="string">&quot;0&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;keyhll&quot;</span></span><br><span class="line">   2) <span class="string">&quot;keyhll3&quot;</span></span><br><span class="line">   3) <span class="string">&quot;keyhll2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; scan 0 match key* count 2</span><br><span class="line">1) <span class="string">&quot;2&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;keyhll&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; scan 2 match key* count 2</span><br><span class="line">1) <span class="string">&quot;0&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;keyhll3&quot;</span></span><br><span class="line">   2) <span class="string">&quot;keyhll2&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="遍历的是什么"><a href="#遍历的是什么" class="headerlink" title="遍历的是什么"></a>遍历的是什么</h2><p>scan的复杂度也是O(n)，但是他是通过游标分布进行的，不会阻塞线程，在redis中，数据都是存放在map中的，这个map有很多槽，scan每次扫指定数量的槽位并返回，返回时还要携带一个信息，用来表示已经遍历过哪些槽位了。这里使用”游标”来承载这个信息。</p>
<p>命令中的count 1000 不是限定返回数量，而是限定服务器单词遍历的字典槽位数量。</p>
<p>scan指令返回的游标就是数组的位置索引，count表示要遍历的槽位，返回的结果可能多可能少，是因为有些槽位可能是空的。每次scan 都会将 对应数量的槽位上的链表元素进行匹配后过滤返回给客户端。</p>
<p>如图：</p>
<img src="/2022/10/05/redis/redis-scan-slot-1.drawio.png" class="">





<h2 id="高位进位加法"><a href="#高位进位加法" class="headerlink" title="高位进位加法"></a>高位进位加法</h2><p>考虑到遍历redis字典时可能出现扩容和缩容，scan的遍历顺序不是从数组的0位一直遍历到末尾，而是采用了高位进位加法来遍历。</p>
<p>什么是高位进位加法？如图：</p>
<img src="/2022/10/05/redis/redis-scan-add.drawio.png" class="">



<p>为什么要使用高位进位加法？为了支持遍历时扩容</p>
<p>map扩容的时候，需要重新分配一个新的2倍大小的数组，然后将原来数组的元素全部rehash后取模，然后分配到新数组中。</p>
<p>举个例子，原本的数组由8 slot扩容到16 slot，假如第3个 slot （011）存放有 元素 3 和 11， 因为长度变为原来的两倍了，所以原本放在 011 槽位的元素会被分配到 0011和 1011 两个槽位，1011对于原来的 011 来说，相当于在最高位+1。</p>
<p>如图：</p>
<img src="/2022/10/05/redis/redis-scan-2.drawio.png" class="">



<p>结合扩容和缩容前后的情况，如图：</p>
<img src="/2022/10/05/redis/redis-scan.drawio.png" class="">



<p>假如现在客户端刚scan 010，处理完 010 的槽位数据，正要 scan 110 的时候，服务器发生扩容&#x2F;缩容：</p>
<p>服务器发生扩容，扩容后，110槽位上所有的数据都分配到了 0110和1110 的槽位。这是scan 110 ，游标数值对应 0110 ，服务器就直接遍历0110，0110 之前的数据都是遍历过了的，这样就可以避免扩容后对已经遍历过的槽位重复遍历。</p>
<p>服务器发生缩容，缩容后，因为容量的索引最高是 11 ，游标数值超过，取模，得到对应要访问的槽位是10，这是就从10 这个槽位往后遍历，10 槽位前的都是遍历过的了。不过有个问题，那就是 10 这个槽位是包含了 110 和 010 的，也就是对 010 这个槽位上的元素进行了重复遍历。 </p>
<p>由上面我们可以知道</p>
<p>服务器不需要为游标保存状态。</p>
<p>scan遍历返回的结果可能会有重复。（缩容的时候）</p>
<p>一趟遍历（多次scan）的过程中，新加数据是不一定能遍历到的，因为可能新加的数据在前面已经scan过的槽位上。</p>
<p>单次返回的结果是空不代表遍历结束，只能说明游标遍历的这些槽位没有数据，遍历的结束的标志要看返回的游标值是否为0</p>
<h2 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h2><p>在map扩容的时候，会一次性将旧数组下的元素全部转移到新数组下面，如果map中的slot下的元素很多，线程会出现卡顿。一般常用的处理方法是使用渐进式rehash，redis也是这么处理的。</p>
<p>map会同时保留新旧两个数组，然后在定时任务以及后续对hash的访问操作中，把旧数组中的元素移动到新数组上，如果在旧数组找不到数据，还要到新数组去找，其实本质就是把迁移工作均摊到每次访问上。</p>
<p>Ps：在集群环境下，如果单个key的数据太大，会导致数据迁移卡顿，以及在扩容的时候需要一次性申请大内存，也会导致操作系统腾出空间而卡顿。如果这个key被删除，内存回收也会导致卡顿。</p>
<p>所以在平时业务开发中，尽量避免大key的产生。</p>
<p>总之，大 key 会带来以下四种影响：</p>
<ul>
<li><strong>客户端超时阻塞</strong>。由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</li>
<li><strong>引发网络阻塞</strong>。每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。</li>
<li><strong>阻塞工作线程</strong>。如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。</li>
<li><strong>内存分布不均</strong>。集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜情况，部分有大 key 的 Redis 节点占用内存多，QPS 也会比较大。</li>
</ul>
<h1 id="RESP协议"><a href="#RESP协议" class="headerlink" title="RESP协议"></a>RESP协议</h1><p>演示模拟redis-cli和redis-server</p>
<p>当tcp连接建立后，所有基于tcp的连接的上层应用都要有自己的一套规则，连接的双方遵循这套规则来处理数据，因为tcp传的都是数据，也就是byte数组。上层应用要根据遵循的协议来读取这个byte数组才有意义。</p>
<p>redis使用了比较简单的文本协议，但是依然可以取得极高的访问性能。因为使用简单的协议就意味着不必在从socket读出数据后对这份byte数组做浪费cpu时间的复杂的解析。</p>
<p>redis使用的文本协议叫做 redis序列化协议，简称RESP（Redis Serialization Protocol）</p>
<p>resp将传输的数据结构分为5种小单元类型，单元结束时统一加上回车符和换行符<code>\r\n</code></p>
<ol>
<li>单行字符串以 <code>+</code> 符号开头。</li>
<li>多行字符串以 <code>$</code> 符号开头，后面跟着字符串长度。</li>
<li>整数值以 <code>:</code> 符号开头，后面跟着整数的字符串形式。</li>
<li>错误消息以 <code>-</code> 符号开头。 </li>
<li>数组以 <code>*</code> 符号开头，后面跟数组的长度</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+hello world\r\n</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$11</span>\r\nhello world\r\n</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:1024\r\n</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-WRONGTYPE Operation against a key holding the wrong kind of svalue\r\n</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 数组 [1,2,3]</span></span><br><span class="line">*3\r\n:1\r\n:2\r\n:3\r\n</span><br><span class="line"></span><br><span class="line"><span class="comment">## 字符串+数字数组 [&quot;hello world&quot;,&quot;ironhead&quot;,2000]</span></span><br><span class="line">*3\r\n<span class="variable">$11</span>\r\nhello world\r\n<span class="variable">$8</span>\r\nironhead\r\n:2000\r\n</span><br><span class="line"></span><br><span class="line"><span class="comment">## NULL</span></span><br><span class="line">$-1\r\n</span><br><span class="line"></span><br><span class="line"><span class="comment">## 空串</span></span><br><span class="line"><span class="variable">$0</span>\r\n\r\n</span><br><span class="line"></span><br><span class="line"><span class="comment">## 嵌套 ，在redis中例如scan返回的数据是存在一个数组嵌套另一个数组的情况的。例子如下</span></span><br><span class="line">*2\r\n<span class="variable">$1</span>\r\n0\r\n*2\r\n<span class="variable">$11</span>\r\nhello world\r\n<span class="variable">$8</span>\r\nironhead\r\n</span><br></pre></td></tr></table></figure>



<h2 id="使用协议和redis-cli通信"><a href="#使用协议和redis-cli通信" class="headerlink" title="使用协议和redis-cli通信"></a>使用协议和redis-cli通信</h2><p>为了检验这套协议，我们做个实验，使用redis自带的 redis-cli，然后我们自己创建服务，然后使用redis-cli来连接我们自己创建的server，这个server也遵循 redis序列化协议，就能通信。</p>
<p>小实验目标：</p>
<ul>
<li><p>小服务的listen 6379端口 ，和redis-cli 建立tcp连接后，接收redis-cli的命令，观察命令长什么样。</p>
</li>
<li><p>当前小服务只做 get set del test1 test2 命令的处理。各个命令对应的响应解释如代码中注释所说，然后观察redis-cli收到的回复长什么样。</p>
</li>
</ul>
<p>代码如下：（ps：我们目标只是检验resp通信协议，不在实现复杂的服务，所以代码只是一个只能处理简单get set 命令的服务）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;os/signal&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;syscall&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> DataMap <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	ctx, cancel := context.WithCancel(context.TODO())</span><br><span class="line"></span><br><span class="line">	listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:6379&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> tempDelay time.Duration <span class="comment">// how long to sleep on accept failure</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			conn, err := listener.Accept()</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"></span><br><span class="line">					log.Println(<span class="string">&quot;退出，关闭下游&quot;</span>)</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> ne, ok := err.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class="line">					<span class="keyword">if</span> tempDelay == <span class="number">0</span> &#123;</span><br><span class="line">						tempDelay = <span class="number">5</span> * time.Millisecond</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						tempDelay *= <span class="number">2</span></span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> max := <span class="number">1</span> * time.Second; tempDelay &gt; max &#123;</span><br><span class="line">						tempDelay = max</span><br><span class="line">					&#125;</span><br><span class="line">					log.Println(<span class="string">&quot;http: Accept error: %v; retrying in %v&quot;</span>, err, tempDelay)</span><br><span class="line">					time.Sleep(tempDelay)</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">go</span> handle(conn, ctx)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	sig := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">	signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">	&lt;-sig</span><br><span class="line">	cancel()</span><br><span class="line">	wg.Wait()</span><br><span class="line">	log.Println(<span class="string">&quot;安全退出&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(conn net.Conn, ctx context.Context)</span></span> &#123;</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> buf [<span class="number">1024</span>]<span class="type">byte</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		conn.SetReadDeadline(time.Now().Add(<span class="number">10</span> * time.Second))</span><br><span class="line">		n, err := conn.Read(buf[:])</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		recv := <span class="type">string</span>(buf[:n])</span><br><span class="line"></span><br><span class="line">		log.Println(recv) <span class="comment">//打印收到的数据，方便调试</span></span><br><span class="line"></span><br><span class="line">		resp := do(recv)</span><br><span class="line"></span><br><span class="line">		n, err = conn.Write([]<span class="type">byte</span>(resp))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单的解析,简单做默认只有 set,get,del</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(data <span class="type">string</span>)</span></span> (resp <span class="type">string</span>) &#123;</span><br><span class="line">	strs := strings.Split(data, <span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">	s := strs[<span class="number">0</span>] <span class="comment">// 默认命令过来的一定是数组 *&#123;num&#125;</span></span><br><span class="line">	num, _ := strconv.Atoi(s[<span class="number">1</span>:])</span><br><span class="line">	<span class="keyword">if</span> num == <span class="number">1</span> &#123; <span class="comment">// num 为1是刚连接的时候的COMMAND</span></span><br><span class="line">		<span class="comment">//return &quot;*1\r\n+OK\r\n&quot;</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;$2\r\nOK\r\n&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	action := strs[<span class="number">2</span>]</span><br><span class="line">	mu.Lock()</span><br><span class="line">	<span class="keyword">switch</span> action &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;set&quot;</span>: <span class="comment">// 测试单行字符串</span></span><br><span class="line">		DataMap[strs[<span class="number">4</span>]] = strs[<span class="number">6</span>]</span><br><span class="line">		resp = <span class="string">&quot;+OK\r\n&quot;</span> <span class="comment">// OK</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;get&quot;</span>:</span><br><span class="line">		val, ok := DataMap[strs[<span class="number">4</span>]]</span><br><span class="line">		<span class="keyword">if</span> !ok &#123; <span class="comment">// 测试数组</span></span><br><span class="line">			resp = <span class="string">&quot;*1\r\n$5\r\nempty\r\n&quot;</span> <span class="comment">// 1) &quot;empty&quot;</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// 测试单行字符串</span></span><br><span class="line">			resp = <span class="string">&quot;+&quot;</span> + val + <span class="string">&quot;\r\n&quot;</span> <span class="comment">// val</span></span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;del&quot;</span>: <span class="comment">// 测试字符串</span></span><br><span class="line">		<span class="built_in">delete</span>(DataMap, strs[<span class="number">4</span>])</span><br><span class="line">		resp = <span class="string">&quot;$7\r\nsuccess\r\n&quot;</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;test&quot;</span>: <span class="comment">// 测试数组中 存在 字符串和 数字</span></span><br><span class="line">		resp = <span class="string">&quot;*3\r\n$11\r\nhello world\r\n$8\r\nironhead\r\n:3\r\n&quot;</span> <span class="comment">//</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;test2&quot;</span>: <span class="comment">// 测试数组嵌套</span></span><br><span class="line">		resp = <span class="string">&quot;*2\r\n$1\r\n0\r\n*2\r\n$11\r\nhello world\r\n$8\r\nironhead\r\n&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> resp</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="使用协议和redis-server通信"><a href="#使用协议和redis-server通信" class="headerlink" title="使用协议和redis-server通信"></a>使用协议和redis-server通信</h2><p>同上，只要我们以遵循redis序列化协议的方式处理从tcp连接获取的数据。也能实现和redis-server通信。</p>
<p>我们dial 6379 和 redis-server建立连接，获取终端的输入，把终端输入解析成 resp 的数据格式。写入 socket。（ps：将数据解析成resp 的处理 是简单做的，没有考虑复杂命令集。）</p>
<p>实验目标：</p>
<ul>
<li>终端输入 set key3 val3，在redis-server中观察（redis-cli连接后观察）是否存在key3和查看key类型和val</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="comment">//&quot;bufio&quot;</span></span><br><span class="line">	<span class="comment">//&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//&quot;log&quot;</span></span><br><span class="line">	<span class="comment">//&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//inputReader := bufio.NewReader(os.Stdin)</span></span><br><span class="line">	<span class="comment">//recv, _ = inputReader.ReadString(&#x27;\n&#x27;)</span></span><br><span class="line">	<span class="comment">//fmt.Println([]byte(recv))</span></span><br><span class="line"></span><br><span class="line">	conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:6379&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> buf [<span class="number">1024</span>]<span class="type">byte</span></span><br><span class="line">	<span class="keyword">var</span> inputbuf [<span class="number">1024</span>]<span class="type">byte</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line">		os.Stdout.SetWriteDeadline(time.Now().Add(<span class="number">10</span> * time.Second))</span><br><span class="line">		os.Stdout.Write([]<span class="type">byte</span>(<span class="string">&quot;my-redis-cli-&quot;</span> + conn.RemoteAddr().String() + <span class="string">&quot;&gt;&quot;</span>))</span><br><span class="line"></span><br><span class="line">		os.Stdin.SetReadDeadline(time.Now().Add(<span class="number">10</span> * time.Second))</span><br><span class="line">		n, err := os.Stdin.Read(inputbuf[:])</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		input := <span class="type">string</span>(inputbuf[:n])</span><br><span class="line"></span><br><span class="line">		<span class="comment">// todo input 转化成 resp风格命令</span></span><br><span class="line"></span><br><span class="line">		output := do(input)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 连续的两个命令看看是否有粘包问题。</span></span><br><span class="line">		<span class="comment">//n, err := conn.Write([]byte(&quot;*3\r\n$3\r\nset\r\n$2\r\nk1\r\n$2\r\nv1\r\n&quot; +</span></span><br><span class="line">		<span class="comment">//	&quot;*3\r\n$3\r\nset\r\n$2\r\nk2\r\n$2\r\nv2\r\n&quot;))</span></span><br><span class="line">		n, err = conn.Write([]<span class="type">byte</span>(output))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		conn.SetReadDeadline(time.Now().Add(<span class="number">10</span> * time.Second))</span><br><span class="line">		n, err = conn.Read(buf[:])</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		recv := <span class="type">string</span>(buf[:n])</span><br><span class="line">		fmt.Printf(recv)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单解析</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(input <span class="type">string</span>)</span></span> (output <span class="type">string</span>) &#123;</span><br><span class="line"></span><br><span class="line">	sep := <span class="string">&quot;\r\n&quot;</span></span><br><span class="line">	input = strings.Trim(input, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	strs := strings.Split(input, <span class="string">&quot; &quot;</span>)</span><br><span class="line">	num := <span class="built_in">len</span>(strs)</span><br><span class="line"></span><br><span class="line">	output = output + <span class="string">&quot;*&quot;</span> + strconv.Itoa(num) + sep</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line">		n := <span class="built_in">len</span>(strs[i])</span><br><span class="line">		output = output + <span class="string">&quot;$&quot;</span> + strconv.Itoa(n) + sep</span><br><span class="line">		output = output + strs[i] + sep</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><p>管道技术（Pipeline）是客户端提供的一种批处理技术，用于一次处理多个 Redis 命令，从而提高整个交互的性能。</p>
<p>管道技术本质上是客户端提供的功能，而非 Redis 服务器端的功能。对于redis服务器来说，他照样继续处理收到的redis命令，不会有什么特殊处理。</p>
<p>一条命令的执行过程如下：</p>
<p>client 进程和server 进程建立连接后，client 调用write将消息（redis命令）写到操作系统为socket分配的发送缓冲 send buffer中。</p>
<p>client 操作系统在合适的时间将发送缓冲的内容经过协议栈的层层处理，最后发到网卡，网卡将数据发到路由，通过 网络 的层层传递 最后到达服务器的网卡。</p>
<p>服务器的网卡收到数据，DMA将数据收到收包队列 ring buffer 中，硬件中断处理，操作系统启用ksoftirqd 线程处理，然后经过协议栈层层处理，到达服务器操作系统为这次连接socket分配的接收缓冲recv buffer。</p>
<p>服务器进程调用read 将数据取出，解析命令作出处理，然后将处理后的结果调用write，发送到服务器进程的socket的发送缓冲 send buffer中。</p>
<p>然后同理，数据也是经过server的send buffer –&gt; server的协议栈 –&gt; server的网卡 –&gt; 网络 –&gt; client的网卡 –&gt; client的协议栈 –&gt; client的socket的recv buffer；</p>
<p>client 进程调用 read 读出 socket中的数据，这一条命令的处理才算完成。对于client来说，真正耗时的是网络io和数据传输，写入到sendbuffer中并不耗时间。</p>
<img src="/2022/10/05/redis/redis-net-1.drawio.png" class="">



<h2 id="关于连接的read和write"><a href="#关于连接的read和write" class="headerlink" title="关于连接的read和write"></a>关于连接的read和write</h2><p>write操作并不是要等到目标服务器收到数据才返回，write操作只负责将数据写入到本地操作系统维护的发送缓冲中就返回了。剩下的交给操作系统内核来将数据发送出去。只有在发送缓冲满了的时候，write才会耗时等待缓冲中的数据被发送处理腾出空间来。写操作io只有在这时才是耗时的大头。</p>
<p>read 操作并非一定是从目标服务器读取数据，read操作只负责将数据从本地操作系统内核维护的接收缓冲中拉取数据就完事了。只有缓冲是空的，需要等待数据到来，read才是真正等待网络io的耗时。</p>
<h1 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h1><p>redis是单线程的。这个”单线程”是指处理命令是单线程的。也就是说 <strong>[ 接收客户端请求-&gt;解析请求 -&gt;进行数据读写等操作-&gt;发送数据给客户端 ] <strong>这个过程是由一个线程（主线程）来完成的。但是，Redis 程序并不是单线程的 ，Redis 在启动的时候，是会</strong>启动后台线程</strong>的</p>
<p>redis单线程为什么能这么快？</p>
<ol>
<li>数据都在内存中。</li>
<li>单线程避免了线程切换带来的开销</li>
</ol>
<p>redis是单线程，如何处理那么多的并发客户端连接？</p>
<p>redis通过”多路IO复用”机制，使用非阻塞IO轮询。</p>
<h2 id="多路复用原理"><a href="#多路复用原理" class="headerlink" title="多路复用原理"></a>多路复用原理</h2><p>在传统的同步阻塞网络编程模型里，性能上不来的根本原因是频繁地切换进程线程上下文，一个用户请求会让一个进程去处理。</p>
<p>而<strong>多路复用</strong>让很多的用户连接来复用同一个进(线)程，<strong>多路</strong>指的是许许多多个用户的网络连接。<strong>复用</strong>指的是对进(线)程的复用。但是要在一个进程中管理各个socket的文件描述符。需要有 socket 事件管理机制。select&#x2F;poll&#x2F;epoll&#x2F;kqueue，这里epoll是目前linux最常见的也行比较新的，普遍的。以epoll为例：</p>
<p>epoll主要有3个方法</p>
<ul>
<li>epoll_create 顾名思义，创建一个epoll</li>
<li>epoll_ctl 根据参数的不同用来添加一个fd到epoll或者删除等。</li>
<li>epoll_wait 获取事件，根据参数的不同，可以是阻塞，非阻塞，有限等待等方式。</li>
</ul>
<p>大致如下：</p>
<img src="/2022/10/05/redis/epoll-1.drawio.png" class="">

<p>当网卡上收到数据包后，Linux 内核进行一系列的处理后把数据放到 socket 的接收队列。然后会检查是否有 epoll 在管理它，如果是则在 epoll 的就绪队列中插入一个元素。epoll_wait 的操作就非常的简单了，就是到 epoll 的就绪队列上来查询有没有事件发生就行了。</p>
<p>读写事件是怎么被触发的？</p>
<p>看接收缓冲是否有数据和发送缓冲是否有数据。当数据到来，接收缓冲有数据，就往epoll的就绪队列添加读事件。当数据发送，发送缓冲腾出空间，就往epoll的就绪队列添加写事件。</p>
<p>接下来，我们直接看redis代码的实现。</p>
<p>相关代码主要看 server.c 和 ae.c 和 ae_epoll.c 和 networking.c 文件。</p>
<p>和 epoll 相关的代码在 ae_epoll.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeApiState</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> epfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">events</span>;</span></span><br><span class="line">&#125; aeApiState;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">aeApiCreate</span><span class="params">(aeEventLoop *eventLoop)</span> &#123;...&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">aeApiResize</span><span class="params">(aeEventLoop *eventLoop, <span class="type">int</span> setsize)</span>  &#123;...&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">aeApiFree</span><span class="params">(aeEventLoop *eventLoop)</span>  &#123;...&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">aeApiAddEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="type">int</span> fd, <span class="type">int</span> mask)</span>  &#123;...&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">aeApiDelEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="type">int</span> fd, <span class="type">int</span> delmask)</span> &#123;...&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">aeApiPoll</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">struct</span> timeval *tvp)</span> &#123;...&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *<span class="title function_">aeApiName</span><span class="params">(<span class="type">void</span>)</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>







<p>可以在redis的主线程中看到（server.c ）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  initServer();</span><br><span class="line">  ...</span><br><span class="line">  aeSetBeforeSleepProc(server.el,beforeSleep);<span class="comment">// 各种事件注册的时候都会保存到这个数组里：eventLoop-&gt;events</span></span><br><span class="line">  aeMain(server.el);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中主要的是 initServer 和 aeMain</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initServer</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="comment">// 创建 epoll</span></span><br><span class="line">  	server.el = aeCreateEventLoop(server.maxclients+CONFIG_FDSET_INCR);</span><br><span class="line">  ...</span><br><span class="line">   	</span><br><span class="line">    <span class="comment">// 打开监听socket</span></span><br><span class="line">    <span class="keyword">if</span> (server.port != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        listenToPort(server.port,server.ipfd,&amp;server.ipfd_count) == C_ERR)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">...</span><br><span class="line">		<span class="comment">/* Create the serverCron() time event, that&#x27;s our main way to process</span></span><br><span class="line"><span class="comment">     * background operations. */</span></span><br><span class="line">    <span class="keyword">if</span>(aeCreateTimeEvent(server.el, <span class="number">1</span>, serverCron, <span class="literal">NULL</span>, <span class="literal">NULL</span>) == AE_ERR) &#123; <span class="comment">///注册服务定时任务</span></span><br><span class="line">        serverPanic(<span class="string">&quot;Can&#x27;t create the serverCron time event.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">  	<span class="comment">// 注册监听READ事件和对应事件的处理函数 acceptTcpHandler</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.ipfd_count; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE,  <span class="comment">// 注册读事件处理逻辑</span></span><br><span class="line">            acceptTcpHandler,<span class="literal">NULL</span>) == AE_ERR)</span><br><span class="line">            &#123;</span><br><span class="line">                serverPanic(</span><br><span class="line">                    <span class="string">&quot;Unrecoverable error creating server.ipfd file event.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (server.sofd &gt; <span class="number">0</span> &amp;&amp; aeCreateFileEvent(server.el,server.sofd,AE_READABLE,</span><br><span class="line">        acceptUnixHandler,<span class="literal">NULL</span>) == AE_ERR) serverPanic(<span class="string">&quot;Unrecoverable error creating server.sofd file event.&quot;</span>);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>redis server 在初始化中listen端口并注册了对应事件的处理函数，这里主要关注三个函数：</p>
<ul>
<li>aeCreateEventLoop</li>
<li>aeCreateFileEvent</li>
<li>aeMain(server.el)</li>
</ul>
<p>aeCreateEventLoop中 调用了 aeApiCreate，我们可以看到aeApiCreate 中使用的 <strong>epoll_create</strong> 创建epoll</p>
<p>aeCreateFileEvent 中 调用了 aeApiAddEvent，我们可以看到aeApiAddEvent 中使用 **epoll_ctl ** 注册事件</p>
<p>aeMain 中 for 轮询调用aeProcessEvents，aeProcessEvents 调用了aeApiPoll，aeApiPoll中使用了 <strong>epoll_wait</strong> 拉取事件</p>
<p>在 aeCreateFileEvent 函数中，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">aeCreateFileEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="type">int</span> fd, <span class="type">int</span> mask,</span></span><br><span class="line"><span class="params">        aeFileProc *proc, <span class="type">void</span> *clientData)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    aeFileEvent *fe = &amp;eventLoop-&gt;events[fd];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (aeApiAddEvent(eventLoop, fd, mask) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> AE_ERR;</span><br><span class="line">    fe-&gt;mask |= mask;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_READABLE) fe-&gt;rfileProc = proc;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_WRITABLE) fe-&gt;wfileProc = proc;</span><br><span class="line">    fe-&gt;clientData = clientData;</span><br><span class="line">    <span class="keyword">if</span> (fd &gt; eventLoop-&gt;maxfd)</span><br><span class="line">        eventLoop-&gt;maxfd = fd;</span><br><span class="line">    <span class="keyword">return</span> AE_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 aeCreateFileEvent 将 proc，给到了eventLoop中的events 的 rfileProc ，对应的就是 看 initServer中 <code>aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE, acceptTcpHandler,NULL)</code>   acceptTcpHandler。</p>
<p>在 aeMain函数中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> &#123;</span><br><span class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!eventLoop-&gt;stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;beforesleep != <span class="literal">NULL</span>)</span><br><span class="line">            eventLoop-&gt;beforesleep(eventLoop); <span class="comment">// </span></span><br><span class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>redis 轮询 执行  <code>aeProcessEvents(eventLoop, AE_ALL_EVENTS)</code> 和 <code>beforesleep(eventLoop);</code></p>
<p>而aeProcessEvents 是主要的处理逻辑，主要关注的代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">aeProcessEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">if</span> (eventLoop-&gt;maxfd != <span class="number">-1</span> ||</span><br><span class="line">        ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) &#123;</span><br><span class="line">      ...</span><br><span class="line">    		numevents = aeApiPoll(eventLoop, tvp); <span class="comment">// 拉取检查事件</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</span><br><span class="line">            aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];</span><br><span class="line">            <span class="type">int</span> mask = eventLoop-&gt;fired[j].mask;</span><br><span class="line">            <span class="type">int</span> fd = eventLoop-&gt;fired[j].fd;</span><br><span class="line">            <span class="type">int</span> rfired = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	    			<span class="comment">/* note the fe-&gt;mask &amp; mask &amp; ... code: maybe an already processed</span></span><br><span class="line"><span class="comment">             * event removed an element that fired and we still didn&#x27;t</span></span><br><span class="line"><span class="comment">             * processed, so we check if the event is still valid. */</span></span><br><span class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;  <span class="comment">// 读事件</span></span><br><span class="line">                rfired = <span class="number">1</span>;</span><br><span class="line">                fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask); <span class="comment">// 读事件对应的处理函数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123; <span class="comment">// 写事件</span></span><br><span class="line">                <span class="keyword">if</span> (!rfired || fe-&gt;wfileProc != fe-&gt;rfileProc)</span><br><span class="line">                    fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask); <span class="comment">// 写事件对应的处理函数</span></span><br><span class="line">            &#125;</span><br><span class="line">            processed++;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">  ...</span><br><span class="line">  	<span class="comment">/* Check time events */</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS)</span><br><span class="line">    processed += processTimeEvents(eventLoop);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的逻辑我们也能看到。redis单线程去 poll 事件，然后执行，只有执行完了，才可能poll下一个事件。这样每次处理只有一个线程才做。</p>
<p>简单说就是监听端口的socket 的fd每次收到epoll过来的读事件，就会对应执行 acceptTcpHandler函数。</p>
<p>看下 aeProcessEvents 中的 processTimeEvents ，他处理的是在 initServer中 注册的 serverCron的逻辑，serverConn中是一些服务器自身维护的逻辑如检查key过期时间，数据持久化等操作。不是我们理解redis 线程io模型 的重点，先不讨论，只要知道这个处理逻辑经过 <code>aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL)</code> 注册到epoll中，然后aeMain 每过一定的时间就会去执行 serverCron的逻辑。</p>
<p>我们再来看看 acceptTcpHandler 函数，他调用了 anetTcpAccept 函数。简单来说就是一个根据 监听的 socket的fd，获取新到来连接，获得tcp连接的socket的fd。acceptTcpHandler 在获取连接的fd之后，调用了 acceptCommonHandler，acceptCommonHandler主要关注的处理是调用了，createClient。代码处理如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">client *<span class="title function_">createClient</span><span class="params">(<span class="type">int</span> fd)</span> &#123;</span><br><span class="line">    client *c = zmalloc(<span class="keyword">sizeof</span>(client));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* passing -1 as fd it is possible to create a non connected client.</span></span><br><span class="line"><span class="comment">     * This is useful since all the commands needs to be executed</span></span><br><span class="line"><span class="comment">     * in the context of a client. When commands are executed in other</span></span><br><span class="line"><span class="comment">     * contexts (for instance a Lua script) we need a non connected client. */</span></span><br><span class="line">    <span class="keyword">if</span> (fd != <span class="number">-1</span>) &#123;</span><br><span class="line">        anetNonBlock(<span class="literal">NULL</span>,fd);</span><br><span class="line">        anetEnableTcpNoDelay(<span class="literal">NULL</span>,fd);</span><br><span class="line">        <span class="keyword">if</span> (server.tcpkeepalive)</span><br><span class="line">            anetKeepAlive(<span class="literal">NULL</span>,fd,server.tcpkeepalive);</span><br><span class="line">        <span class="keyword">if</span> (aeCreateFileEvent(server.el,fd,AE_READABLE,  <span class="comment">// 注册事件通知和处理函数readQueryFromClient</span></span><br><span class="line">            readQueryFromClient, c) == AE_ERR)</span><br><span class="line">        &#123;</span><br><span class="line">            close(fd);</span><br><span class="line">            zfree(c);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		...</span><br><span class="line">    <span class="keyword">if</span> (fd != <span class="number">-1</span>) listAddNodeTail(server.clients,c); <span class="comment">/// 添加到redisServer的cients链表队列里面</span></span><br><span class="line">    initClientMultiState(c);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到所有建立连接的fd都会被创建client 并作为链表node 添加到 server的client 链表。</p>
<p>在上面创建的client中。往epoll中注册了读事件通知以处理 readQueryFromClient</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">readQueryFromClient</span><span class="params">(aeEventLoop *el, <span class="type">int</span> fd, <span class="type">void</span> *privdata, <span class="type">int</span> mask)</span> &#123;</span><br><span class="line">  ... </span><br><span class="line">  nread = read(fd, c-&gt;querybuf+qblen, readlen); <span class="comment">// 读取socket数据</span></span><br><span class="line">  ...</span><br><span class="line">  processInputBuffer(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 processInputBuffer处理客户端的输入，解析，执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// networking.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">processInputBuffer</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  	<span class="keyword">if</span> (c-&gt;reqtype == PROTO_REQ_INLINE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (processInlineBuffer(c) != C_OK) <span class="keyword">break</span>; <span class="comment">// 解析数据，</span></span><br><span class="line">    <span class="comment">// 执行命令，</span></span><br><span class="line">    ...</span><br><span class="line">      <span class="keyword">if</span> (processCommand(c) == C_OK)  <span class="comment">///执行命令</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">processInlineBuffer</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (sdslen(argv[j])) &#123;</span><br><span class="line">     c-&gt;argv[c-&gt;argc] = createObject(OBJ_STRING,argv[j]);  <span class="comment">// 对应命令</span></span><br><span class="line">     c-&gt;argc++;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// object.c</span></span><br><span class="line">robj *<span class="title function_">createObject</span><span class="params">(<span class="type">int</span> type, <span class="type">void</span> *ptr)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  o-&gt;ptr = ptr;  <span class="comment">// 命令的字符串</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后 我们关注 client 连接有读写事件时的处理 readQueryFromClient的processInputBuffer。命令主要是读取数据并根据resp解析数据，然后调用 processCommand</p>
<p>然后再看下其中最重要的<code>processCommand</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">processCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">    c-&gt;cmd = c-&gt;lastcmd = lookupCommand(c-&gt;argv[<span class="number">0</span>]-&gt;ptr); <span class="comment">// 根据之前processInlineBuffer解析的命令字符串找到对应的命令处理逻辑</span></span><br><span class="line">  ... <span class="comment">// 都是一些校验相关的逻辑。不是这次的重点，先省略</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != execCommand &amp;&amp; c-&gt;cmd-&gt;proc != discardCommand &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != multiCommand &amp;&amp; c-&gt;cmd-&gt;proc != watchCommand)</span><br><span class="line">    &#123;</span><br><span class="line">        queueMultiCommand(c);</span><br><span class="line">        addReply(c,shared.queued);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        call(c,CMD_CALL_FULL); <span class="comment">// 函数里面调用的 c-&gt;cmd-&gt;proc</span></span><br><span class="line">        c-&gt;woff = server.master_repl_offset;</span><br><span class="line">        <span class="keyword">if</span> (listLength(server.ready_keys))</span><br><span class="line">            handleClientsBlockedOnLists();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 server.c 中定义了每一个命令对应的处理函数，<code>lookupCommand</code>和<code>c-&gt;cmd-&gt;proc</code> 会找到对应的命令函数去执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> <span class="title">redisCommandTable</span>[] =</span> &#123;</span><br><span class="line">    &#123;<span class="string">&quot;get&quot;</span>,getCommand,<span class="number">2</span>,<span class="string">&quot;rF&quot;</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;set&quot;</span>,setCommand,<span class="number">-3</span>,<span class="string">&quot;wm&quot;</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;setnx&quot;</span>,setnxCommand,<span class="number">3</span>,<span class="string">&quot;wmF&quot;</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以get 命令为例，getCommand 会被执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_string.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    getGenericCommand(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getGenericCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    robj *o;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.nullbulk)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;type != OBJ_STRING) &#123;</span><br><span class="line">        addReply(c,shared.wrongtypeerr);</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addReplyBulk(c,o);</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到主要两个函数 <code>lookupKeyReadOrReply</code> 和 <code>addReplyBulk</code> 系列函数会被执行，这里不是讨论线程模型的重点就不继续往下挖了。</p>
<p>其中 <code>addReplyBulk</code> 是用于设置回复数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Add a Redis Object as a bulk reply */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addReplyBulk</span><span class="params">(client *c, robj *obj)</span> &#123;</span><br><span class="line">    addReplyBulkLen(c,obj);</span><br><span class="line">    addReply(c,obj); <span class="comment">// 将返回值写入到输出缓冲区中</span></span><br><span class="line">    addReply(c,shared.crlf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addReply</span><span class="params">(client *c, robj *obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (prepareClientToWrite(c) != C_OK) <span class="keyword">return</span>; <span class="comment">// 判断是否需要返回数据，然后将client添加到等待写返回数据的队列中</span></span><br><span class="line">		...</span><br><span class="line">    <span class="keyword">if</span> (sdsEncodedObject(obj)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_addReplyToBuffer(c,obj-&gt;ptr,sdslen(obj-&gt;ptr)) != C_OK)<span class="comment">// 将返回值写入到输出缓冲区</span></span><br><span class="line">            _addReplyObjectToList(c,obj);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj-&gt;encoding == OBJ_ENCODING_INT) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Wrong obj-&gt;encoding in addReply()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">prepareClientToWrite</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">     <span class="keyword">if</span> (!clientHasPendingReplies(c) &amp;&amp;</span><br><span class="line">        !(c-&gt;flags &amp; CLIENT_PENDING_WRITE) &amp;&amp;</span><br><span class="line">        (c-&gt;replstate == REPL_STATE_NONE ||</span><br><span class="line">         (c-&gt;replstate == SLAVE_STATE_ONLINE &amp;&amp; !c-&gt;repl_put_online_on_ack)))&#123;</span><br><span class="line">       ...</span><br><span class="line">       listAddNodeHead(server.clients_pending_write,c);  <span class="comment">// 添加到等待写返回数据的队列中</span></span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上面可以知道，命令执行完后，会检查自己是否有输出要写入，但是他不会马上写入，处于性能考虑。对于服务器来说，最关心的命令执行已经结束了。输出并不是那么紧急，可以把输出写到缓冲，然后加入队列，等待写输出。队列中的每一个元素都是有待写返回数据的 client 对象。</p>
<p>然后我们再来看下 <code>_addReplyToBuffer</code> 和 <code>_addReplyStringToList</code> 这两个函数是一起的。<code>_addReplyToBuffer</code> 往缓冲中写 <code>memcpy(c-&gt;buf+c-&gt;bufpos,s,len);</code> 如果写不下了。再由<code>_addReplyStringToList</code> 添加到链表，等待下次继续写。</p>
<p>现在我们知道了。redis处理后都将输出放到缓冲，然后丢到队列里面。那么</p>
<p>由谁来消费这个队列？</p>
<p>什么时候会消费这个队列？</p>
<p>这里我们根据 注册写监听的 epoll 往上找，或者根据 这个队列的 消费函数调用者，往上找，最后找到<code>beforesleep</code></p>
<p>这个函数在 <code>aeMain</code> 函数中被轮询。在 <code>aeSetBeforeSleepProc(server.el,beforeSleep);</code>  设置的。看下这个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">beforeSleep</span><span class="params">(<span class="keyword">struct</span> aeEventLoop *eventLoop)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">     <span class="comment">/* Handle writes with pending output buffers. */</span></span><br><span class="line">    handleClientsWithPendingWrites();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>buforeSleep 不仅仅只做输出，他其中还有很多任务逻辑。但是我们现在只关注网络io相关的。可以看到他去处理写输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">handleClientsWithPendingWrites</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">		listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    <span class="type">int</span> processed = listLength(server.clients_pending_write);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器遍历队列</span></span><br><span class="line">    listRewind(server.clients_pending_write,&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line">        c-&gt;flags &amp;= ~CLIENT_PENDING_WRITE;</span><br><span class="line">        listDelNode(server.clients_pending_write,ln);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入到fd</span></span><br><span class="line">        <span class="comment">/* Try to write buffers to the client socket. */</span></span><br><span class="line">        <span class="keyword">if</span> (writeToClient(c-&gt;fd,c,<span class="number">0</span>) == C_ERR) <span class="keyword">continue</span>;</span><br><span class="line">				</span><br><span class="line">      	<span class="comment">/* If there is nothing left, do nothing. Otherwise install</span></span><br><span class="line"><span class="comment">         * the write handler. */</span></span><br><span class="line">        <span class="keyword">if</span> (clientHasPendingReplies(c) &amp;&amp;  <span class="comment">// //判断是否写完，写不下了就注册写事件，等待下一轮的输出</span></span><br><span class="line">            aeCreateFileEvent(server.el, c-&gt;fd, AE_WRITABLE,</span><br><span class="line">                sendReplyToClient, c) == AE_ERR)</span><br><span class="line">        &#123;</span><br><span class="line">            freeClientAsync(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以看到函数的大致处理逻辑是，遍历 等待输出的链表队列，如果写不下就加入队列，注册写事件，等待下一轮的写入。</p>
<p>这里”写不下”是什么概念呢？系统为每个 socket 设置了接收缓冲和发送缓存区。出于性能考虑，我们write的参数肯定不是阻塞写。使用非阻塞写，当数据量超过写缓冲时，自然就会一部分是写不下的。</p>
<p>为什么说阻塞写性能会低？阻塞写在写不下的时候会阻塞等待发送缓冲的数据发送出去从而腾出空间，而”等待发送缓冲数据发送出去”这个时间是网络io，相比cpu在内存操作是更加耗时的。</p>
<p>我们知道读事件是数据到来，可以读取会触发。注册写事件后，这个”写事件”是怎么触发的呢？内核检查发现发送缓冲有空间的时候。其实这个读写事件准确的说，是看接收缓冲是否有数据和发送缓冲是否有数据。当数据到来，接收缓冲有数据，就往epoll的就绪队列添加读事件。当数据发送，发送缓冲腾出空间，就往epoll的就绪队列添加写事件。</p>
<p>其中主要的是 <code>writeToClient</code> ，<code>clientHasPendingReplies</code> 和 <code>aeCreateFileEvent</code> </p>
<p>现在我们知道服务器主要线程在处理什么了</p>
<ul>
<li>初始化的时候initServer 创建epoll并注册epoll 事件通知和设置对应事件处理</li>
<li>aeMain轮询的时候主要根据epoll的事件通知有两个逻辑<ul>
<li>fd的读写事件通知，调用对应的注册进来的函数</li>
<li>时间事件通知，处理定时任务 serverCron</li>
</ul>
</li>
</ul>
<p>这个根据事件类型调用的函数主要有3类：</p>
<ul>
<li>listen 的 fd 的 读事件：主要accept创建client</li>
<li>已经建立连接的tcp的fd的读事件：主要获取数据，解析并执行命令，将结果放到发送队列</li>
<li>已经建立连接的tcp的fd的写事件：主要获取发送队列中还没发送完的数据，写入到fd中。</li>
</ul>
<p>根据以上，我们可以总结出整个结构图如下：</p>
<img src="/2022/10/05/redis/redis-netio-1.drawio.png" class="">



















<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p>redis实现持久化有两种方式</p>
<ul>
<li>AOF 日志</li>
<li>RDB 快照</li>
</ul>
<p>AOF和RDB的持久化都是fork出一个子进程来进行持久化的。而为什么能这么做，主要是用到操作系统一个写时复制的机制</p>
<h2 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h2><p>写时复制是什么？父进程刚fork出子进程的时候，父进程和子进程的数据段和代码段是一样的。而且操作系统虽然让两者看起来都有自己的数据段，但是实际上他们各自的页表的物理页指向的是同一份。当父进程修改数据时，操作系统才会把这一页物理页换成新的物理页。而子进程只做持久化，不会去修改业务数据，子进程的数据还是在fork那一刻的整个数据状态。相当于父进程fork的时候的整个内存数据的快照。</p>
<p>如图：</p>
<img src="/2022/10/05/redis/copy-on-write-1.drawio.png" class="">







<h2 id="AOF日志"><a href="#AOF日志" class="headerlink" title="AOF日志"></a>AOF日志</h2><p>Redis 每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里，然后重启 Redis 的时候，先去读取这个文件里的命令，并且执行它，这种保存写操作命令到日志的持久化方式，就是 Redis 里的 <strong>AOF(*Append Only File*)</strong> 持久化功能，<strong>注意只会记录写操作命令，读操作命令是不会被记录的</strong></p>
<p>AOF 日志文件其实就是普通的文本，我们可以通过 <code>cat</code> 命令查看里面的内容。当然，里面的内容是按RESP存储的。</p>
<p>随着执行的写操作命令越来越多，文件的大小会越来越大。如果当 AOF 日志文件过大就会带来性能问题，比如重启 Redis 后，需要读 AOF 文件的内容以恢复数据，如果文件过大，整个恢复的过程就会很慢。</p>
<p>所以redis为AOF提供了<strong>AOF 重写机制</strong>，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。AOF 重写机制是在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件。</p>
<p>根据 <code>struct redisCommand redisCommandTable[]</code> 中的命令，我们可以看到<code>bgrewriteaof</code>  命令使用了 <code>bgrewriteaofCommand</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bgrewriteaofCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (server.aof_child_pid != <span class="number">-1</span>) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">&quot;Background append only file rewriting already in progress&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span>) &#123;</span><br><span class="line">        server.aof_rewrite_scheduled = <span class="number">1</span>;</span><br><span class="line">        addReplyStatus(c,<span class="string">&quot;Background append only file rewriting scheduled&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rewriteAppendOnlyFileBackground() == C_OK) &#123;</span><br><span class="line">        addReplyStatus(c,<span class="string">&quot;Background append only file rewriting started&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addReply(c,shared.err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">rewriteAppendOnlyFileBackground</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">if</span> ((childpid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道redis处理命令是单线程，如果进行备份写日志，就还有进行文件的io操作，而文件io操作明显属于慢操作。为了不阻塞主线程，redis需要一边持久化，一边处理客户端的请求。而持久化的时候，内存数据还在改变，比如一个key在持久化，结果一个请求过来吧key删掉了。所以redis使用fork 出子进程来处理：</p>
<ul>
<li>子进程进行 AOF 重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程；</li>
<li>子进程和父进程都有自己的一份数据结构（虽然底层依然是相同的物理页，但os会保证他们逻辑上改动都是自己的数据，通过写时复制机制）。父进程去处理命令的时候不需要担心内存数据冲突，无需加锁。</li>
</ul>
<p>而子进程在持久化时，父进程在这期间修改的数据可以留到下一次aof的时候再做持久化。</p>
<p>关于数据安全问题：</p>
<p>AOF日志是以文件的形式存储的，当程序对aof日志文件进行些操作的时候，实际上是将内容写到了内核文件描述符分配的一个内存缓冲上。然后内核会异步将脏数据刷回磁盘。</p>
<p>如果此时机器突然宕机，aof日志内容可能还没有来得及刷回磁盘，这个时候就会丢失日志。</p>
<p>在操作系统中，提供一个一个fsync的函数，可以指定让os强制将缓冲刷回磁盘。只有redis进程调用fsyn函数就可以保证aof日志不丢失，但是fsync是io操作，会影响redis高性能地处理命令。</p>
<p>所以在生产环节中，redis通常都是每隔1s左右执行一次fsync操作。至于实际多少秒，则是在数据安全和性能之间做一个权衡。</p>
<p>AOF的缺点：</p>
<p>AOF体积更大，占用空间，启动的时候要取一条一条的执行，启动慢。</p>
<p>AOF的优点：</p>
<p>增量保存，使得每次保存耗时小。</p>
<h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>RDB 文件的内容是二进制数据。</p>
<p>Redis 的快照是<strong>全量快照</strong>，也就是说每次执行快照，都是把内存中的「所有数据」都记录到磁盘中。</p>
<p>RDB 快照就是记录某一个瞬间的内存数据，记录的是实际数据，而 AOF 文件记录的是命令操作的日志，而不是实际的数据。</p>
<p>Redis 提供了两个命令来生成 RDB 文件，分别是 <code>save</code> 和 <code>bgsave</code>，他们的区别就在于是否在「主线程」里执行：</p>
<ul>
<li>执行了 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，<strong>会阻塞主线程</strong>；</li>
<li>执行了 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样可以<strong>避免主线程的阻塞</strong>；</li>
</ul>
<p>RDB 文件的加载工作是在服务器启动时自动执行的，Redis 并没有提供专门用于加载 RDB 文件的命令。</p>
<p>Redis 还可以通过配置文件的选项来实现每隔一段时间自动执行一次 bgsave 命令，默认会提供以下配置：</p>
<p>在 redis的定时任务<code>serverCron</code> 中，有一项工作是执行RDB持久化<code>rdbSaveBackground</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">serverCron</span><span class="params">(<span class="keyword">struct</span> aeEventLoop *eventLoop, <span class="type">long</span> <span class="type">long</span> id, <span class="type">void</span> *clientData)</span> &#123;</span><br><span class="line">		...</span><br><span class="line">    <span class="keyword">if</span> (rdbSaveBackground(server.rdb_filename) == C_OK)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rdb.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rdbSaveBackground</span><span class="params">(<span class="type">char</span> *filename)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">   <span class="keyword">if</span> ((childpid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 rdb 是每隔一段时间就fork子进程去执行。所以配置文件中 的配置实际上是每隔一段时间就fork出子进程。</p>
<p>RDB的缺点：</p>
<p>因为RDB是全量保存数据，所以在生产环境中，每次执行的间隔会比较大，例如5分钟，15分钟。在服务器发生故障时，丢失的数据会比 AOF 持久化的方式更多，因为 RDB 快照是全量快照的方式，因此执行的频率不能太频繁，否则会影响 Redis 性能，而 AOF 日志可以以秒级的方式记录操作命令，所以丢失的数据就相对更少。</p>
<p>RDB的优点：</p>
<p>因为RDB是二进制的全量快照，所以存储方面相比AOF会更节省空间。</p>
<h2 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h2><p>根据AOF和RDB各自的优缺点。我们可以选择两者混合的方式来持久化。</p>
<p>每次RDB都会把当前的快照持久化下来，同时在RDB的时候AOF重写开始记录。</p>
<p>在redis重启的时候，先加载RDB，在重放AOF。</p>
<p>在这里，AOF日志不再是全量日志，而是在RDB开始到下一次RDB开始之间的增量日志。如下图：</p>
<img src="/2022/10/05/redis/redis-rdb-aof.drawio.png" class="">









<p>扩展：</p>
<p>在传统的数据库中，都是先写日志再执行命令，而redis是先执行命令，再去写日志，为什么？</p>
<p>其他数据库优先做持久化再执行命令是因为，数据库更注重”数据不丢失”，”数据一致性”等问题。</p>
<p>而redis更多担任的是一个缓存的角色。更注重效率，如果redis先写日志再执行，对于client来说就太慢了。</p>
<h1 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h1><p>redis的key可以设置一个过期时间。</p>
<p>redis处理过期的key有两种途径</p>
<ul>
<li>定期扫描清理</li>
<li>懒惰删除</li>
</ul>
<h2 id="定期扫描策略"><a href="#定期扫描策略" class="headerlink" title="定期扫描策略"></a>定期扫描策略</h2><p>redis会将每个设置了过期时间的key放入一个独立的map中，之后会定期便利这个map来删除到期的key，如下 expires 就是存放，dict就是字典类型的数据结构，我习惯叫做map，以下统称map</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    dict *dict;                 <span class="comment">/* The keyspace for this DB */</span></span><br><span class="line">    dict *expires;              <span class="comment">/* Timeout of keys with a timeout set */</span></span><br><span class="line">    dict *blocking_keys;        <span class="comment">/* Keys with clients waiting for data (BLPOP) */</span></span><br><span class="line">    dict *ready_keys;           <span class="comment">/* Blocked keys that received a PUSH */</span></span><br><span class="line">    dict *watched_keys;         <span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> *<span class="title">eviction_pool</span>;</span>    <span class="comment">/* Eviction pool of keys */</span></span><br><span class="line">    <span class="type">int</span> id;                     <span class="comment">/* Database ID */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> avg_ttl;          <span class="comment">/* Average TTL, just for stats */</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>



<p>什么时候触发扫描策略，有两个地方调用到，一个是 <code>serverCron</code> ，一个<code>beforSleep</code> ,这两个由前面知识知道，一个是redis服务的定时任务，一个是主要线程的轮询函数之一。他们最终都调用了 <code>activeExpireCycle</code> 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">activeExpireCycle</span><span class="params">(<span class="type">int</span> type)</span> &#123;</span><br><span class="line">  	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; dbs_per_call; j++) &#123;</span><br><span class="line">        <span class="type">int</span> expired;   <span class="comment">// 用来记录这一趟清理的过期key数量</span></span><br><span class="line">  	...</span><br><span class="line">      <span class="comment">/* Continue to expire if at the end of the cycle more than 25%</span></span><br><span class="line"><span class="comment">         * of the keys were expired. */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">          ...</span><br><span class="line">          <span class="keyword">while</span> (num--) &#123;</span><br><span class="line">                dictEntry *de;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> ttl;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((de = dictGetRandomKey(db-&gt;expires)) == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">            		ttl = dictGetSignedIntegerVal(de)-now;</span><br><span class="line">                <span class="keyword">if</span> (activeExpireCycleTryExpire(db,de,now)) expired++;</span><br><span class="line">               	...</span><br><span class="line">          &#125;</span><br><span class="line">          ...</span><br><span class="line">          <span class="keyword">if</span> (timelimit_exit) <span class="keyword">return</span>;  <span class="comment">// 超时就退出</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (expired &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP/<span class="number">4</span>); <span class="comment">// 如果过期的key超过25%，说明过期key挺多，继续清理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>redis过期扫描不会遍历过期字典中的所有key，步骤如下：</p>
<ol>
<li>从过期字典中随机选出20个key。</li>
<li>删除这20个key中已经过期的key。</li>
<li>如果过期的key比例超过1&#x2F;4，那就重复步骤1。</li>
</ol>
<p>同时，为了保证过期扫描不会出现一直循环，导致线程一直在做过期扫描的情况，redis限制了扫描时间。默认不会超过25ms</p>
<p>定时删除策略的<strong>优点</strong>：</p>
<ul>
<li>可以保证过期 key 会被尽快删除，也就是内存可以被尽快地释放。因此，定时删除对内存是最友好的。</li>
</ul>
<p>定时删除策略的<strong>缺点</strong>：</p>
<ul>
<li>在过期 key 比较多的情况下，删除过期 key 可能会占用相当一部分 CPU 时间，在内存不紧张但 CPU 时间紧张的情况下，将 CPU 时间用于删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响。所以，定时删除策略对 CPU 不友好。</li>
</ul>
<h2 id="懒惰删除策略"><a href="#懒惰删除策略" class="headerlink" title="懒惰删除策略"></a>懒惰删除策略</h2><p>懒惰删除就是在redis访问到这个key的时候，对key的过期时间检查，如果过期就删除，返回空key。</p>
<p>Redis 的惰性删除策略由 db.c 文件中的 <code>expireIfNeeded</code> 函数实现，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> &#123;</span><br><span class="line">  <span class="type">mstime_t</span> when = getExpire(db,key);</span><br><span class="line">  <span class="keyword">if</span> (when &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* No expire for this key */</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">/* Return when this key has not expired */</span></span><br><span class="line">    <span class="keyword">if</span> (now &lt;= when) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Delete the key */</span></span><br><span class="line">    server.stat_expiredkeys++;</span><br><span class="line">    propagateExpire(db,key);</span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_EXPIRED,</span><br><span class="line">        <span class="string">&quot;expired&quot;</span>,key,db-&gt;id);</span><br><span class="line">    <span class="keyword">return</span> dbDelete(db,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>惰性删除策略的<strong>优点</strong>：</p>
<ul>
<li>因为每次访问时，才会检查 key 是否过期，所以此策略只会使用很少的系统资源，因此，惰性删除策略对 CPU 时间最友好。</li>
</ul>
<p>惰性删除策略的<strong>缺点</strong>：</p>
<ul>
<li>如果一个 key 已经过期，而这个 key 又仍然保留在数据库中，那么只要这个过期 key 一直没有被访问，它所占用的内存就不会释放，造成了一定的内存空间浪费。所以，惰性删除策略对内存不友好。</li>
</ul>
<p>注意问题：</p>
<p>假如redis中所有的key在同一时间过期了，会出现什么情况？</p>
<p>redis会持续扫描过期字典中的key，这就会导致线上读写请求出现明显的卡顿。导致这种卡顿的另外一种原因是内存管理需要频繁地回收内存页，这会产生一定的cpu时间消耗。</p>
<p>当client请求到来时，服务器如果正好进入过期扫描状态，client的请求将会等待至少25ms后才会进行处理。如果客户端将超时时间设置得比较短，例如10ms，那么就会出现大量的链接因为超时而关闭，业务端就会出现异常，而此时还无法从redis的slowlog中看到慢查询记录，因为慢查询记录的是命令处理过程慢的。</p>
<h1 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h1><p>当redis内存超出物理内存限制时，内存的数据会开始和磁盘产生频繁的交换。</p>
<p>在生产环境中，不允许redis出现交换行为，限制最大使用内存，redis提供了配置参数maxmemory来限制内存。</p>
<p>当实际内存超出maxmemory是，redis提供了集中可选策略。来让用户自己决定如何腾出心的空间。</p>
<ul>
<li>noeviction：不继续服务写请求（默认淘汰策略）</li>
<li>volatile-random：尝试淘汰设置了过期时间的key。随机</li>
<li>volatile-lru：尝试淘汰设置了过期时间的key。设置了过期且最近最少使用的key被淘汰</li>
<li>volatile-ttl：尝试淘汰设置了过期时间的key。但是会以剩余有效期作为淘汰优先级</li>
<li>allkeys-random：随机淘汰key</li>
<li>allkeys-lru：淘汰最近最少使用的key</li>
</ul>
<p>一般来说，实现LRU会使用一个链表+map，但是lru会使用许多额外内存。所以redis实现的是近似LRU：</p>
<p>近似LRU的核心就是随机采样来淘汰。</p>
<p>redis给每个key增加了一个额外字段，用来保存最后一次被访问的时间戳。</p>
<p>发现内存超出maxmemory，就会执行一次LRU淘汰算法。</p>
<p>最急采样出5个key。然后淘汰掉最旧的key。如果淘汰后内存还是超出maxmemory，那就继续采样淘汰，直到内存低于maxmemory为止。</p>
<p>什么时候触发淘汰？在处理命令的时候，会去检查，函数如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* server.c */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">processCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">		...</span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory) &#123;</span><br><span class="line">      <span class="type">int</span> retval = freeMemoryIfNeeded();</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">freeMemoryIfNeeded</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">// 计算要free的内存空间，会一直free到空间够为止</span></span><br><span class="line">    mem_tofree = mem_used - server.maxmemory;</span><br><span class="line">    mem_freed = <span class="number">0</span>;</span><br><span class="line">    latencyStartMonitor(latency);</span><br><span class="line">    <span class="keyword">while</span> (mem_freed &lt; mem_tofree) &#123;</span><br><span class="line">      			... <span class="comment">// 还有其他各种策略的处理，这里我们就看简单的 random</span></span><br><span class="line">      			<span class="comment">/* volatile-random and allkeys-random policy */</span></span><br><span class="line">            <span class="keyword">if</span> (server.maxmemory_policy == MAXMEMORY_ALLKEYS_RANDOM ||</span><br><span class="line">                server.maxmemory_policy == MAXMEMORY_VOLATILE_RANDOM)</span><br><span class="line">            &#123;</span><br><span class="line">                de = dictGetRandomKey(dict);</span><br><span class="line">                bestkey = dictGetKey(de);  <span class="comment">// 策略选定要删除的key</span></span><br><span class="line">            &#125;</span><br><span class="line">      			...</span><br><span class="line">              </span><br><span class="line">            <span class="comment">// 删除上面策略选中的key</span></span><br><span class="line">            <span class="comment">/* Finally remove the selected key. */</span></span><br><span class="line">            <span class="keyword">if</span> (bestkey) &#123;</span><br><span class="line">              ...</span><br><span class="line">              robj *keyobj = createStringObject(bestkey,sdslen(bestkey));</span><br><span class="line">              ...</span><br><span class="line">              dbDelete(db,keyobj);</span><br><span class="line">              ...</span><br><span class="line">            &#125;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="数据结构的源码"><a href="#数据结构的源码" class="headerlink" title="数据结构的源码"></a>数据结构的源码</h1><h2 id="各种存储的数据结构底层使用的数据结构"><a href="#各种存储的数据结构底层使用的数据结构" class="headerlink" title="各种存储的数据结构底层使用的数据结构"></a>各种存储的数据结构底层使用的数据结构</h2><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>String 类型的底层的数据结构实现主要是 int 和 SDS（简单动态字符串）。</p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List 类型的底层数据结构是由<strong>双向链表或压缩列表</strong>实现的：</p>
<ul>
<li>如果列表的元素个数小于 <code>512</code> 个（默认值，可由 <code>list-max-ziplist-entries</code> 配置），列表每个元素的值都小于 <code>64</code> 字节（默认值，可由 <code>list-max-ziplist-value</code> 配置），Redis 会使用<strong>压缩列表</strong>作为 List 类型的底层数据结构；</li>
<li>如果列表的元素不满足上面的条件，Redis 会使用<strong>双向链表</strong>作为 List 类型的底层数据结构；</li>
</ul>
<p>但是<strong>在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表</strong>。</p>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>Hash 类型的底层数据结构是由<strong>压缩列表或哈希表</strong>实现的：</p>
<ul>
<li>如果哈希类型元素个数小于 <code>512</code> 个（默认值，可由 <code>hash-max-ziplist-entries</code> 配置），所有值小于 <code>64</code> 字节（默认值，可由 <code>hash-max-ziplist-value</code> 配置）的话，Redis 会使用<strong>压缩列表</strong>作为 Hash 类型的底层数据结构；</li>
<li>如果哈希类型元素不满足上面条件，Redis 会使用<strong>哈希表</strong>作为 Hash 类型的 底层数据结构。</li>
</ul>
<p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了</strong>。</p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>Set 类型的底层数据结构是由<strong>哈希表或整数集合</strong>实现的：</p>
<ul>
<li>如果集合中的元素都是整数且元素个数小于 <code>512</code> （默认值，<code>set-maxintset-entries</code>配置）个，Redis 会使用<strong>整数集合</strong>作为 Set 类型的底层数据结构；</li>
<li>如果集合中的元素不满足上面条件，则 Redis 使用<strong>哈希表</strong>作为 Set 类型的底层数据结构。</li>
</ul>
<h3 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h3><p>Zset 类型的底层数据结构是由<strong>压缩列表或跳表</strong>实现的：</p>
<ul>
<li>如果有序集合的元素个数小于 <code>128</code> 个，并且每个元素的值小于 <code>64</code> 字节时，Redis 会使用<strong>压缩列表</strong>作为 Zset 类型的底层数据结构；</li>
<li>如果有序集合的元素不满足上面的条件，Redis 会使用<strong>跳表</strong>作为 Zset 类型的底层数据结构；</li>
</ul>
<p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。</strong></p>
<hr>
<p>redis是如何保存数据的？</p>
<p>redis使用一个<strong>哈希表</strong>来保存所有键值对。哈希表其实就是一个数组，数组中的元素叫做哈希桶。</p>
<p>Redis 的哈希桶是怎么保存键值对数据的呢？</p>
<p>哈希桶存放的是指向键值对数据的指针（dictEntry*），这样通过指针就能找到键值对数据，然后因为键值对的值可以保存字符串对象和集合数据类型的对象，所以键值对的数据结构中并不是直接保存值本身，而是保存了 void * key 和 void * value 指针，分别指向了实际的键对象和值对象，这样一来，即使值是集合数据，也可以通过 void * value 指针找到。</p>
<p>Redis 中的每个对象都由 redisObject 结构表示。代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*server.h*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Object types */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_STRING 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_LIST 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_SET 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ZSET 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_HASH 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Objects encoding. Some kind of objects like Strings and Hashes can be</span></span><br><span class="line"><span class="comment"> * internally represented in multiple ways. The &#x27;encoding&#x27; field of the object</span></span><br><span class="line"><span class="comment"> * is set to one of this fields for this object. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_ZIPMAP 3  <span class="comment">/* Encoded as zipmap */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_LINKEDLIST 4 <span class="comment">/* Encoded as regular linked list */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_ZIPLIST 5 <span class="comment">/* Encoded as ziplist */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_EMBSTR 8  <span class="comment">/* Embedded sds string encoding */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_QUICKLIST 9 <span class="comment">/* Encoded as linked list of ziplists */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>; <span class="comment">// 标识该对象存储的是什么类型的对象（String 对象、 List 对象、Hash 对象、Set 对象和 Zset 对象）</span></span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>; <span class="comment">// 标识该对象使用了哪种底层的数据结构；</span></span><br><span class="line">    <span class="type">unsigned</span> lru:LRU_BITS; <span class="comment">/* lru time (relative to server.lruclock) */</span></span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line">    <span class="type">void</span> *ptr; <span class="comment">// 指向底层数据结构的指针。</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>





<p>各数据结构关系如下：</p>
<img src="/2022/10/05/redis/redis-dict-2.png" class="">







<h2 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h2><p>redis中的字符串是可以修改的字符串，在内存中是以字节数组形式存储的。redis使用c语言写的，但是redis不使用c中的字符串作为自己的字符串实现，因为c语言中的字符串的长度确定是以<code>\0</code> 作为结束符，然后遍历整个字节数组。调用一次strlen的时间复杂度是O(n)。redis选择单独使用一个数值来记录字符串长度。</p>
<p>（ps：事实上其他语言也好，用c语言实现的服务也好。出于性能考虑都会使用一个字段来记录字符串长度。c语言依然保留以<code>\0</code> 的方式是因为c语言在嵌入式领域广泛使用。而嵌入式资源宝贵，同时大部分机器对时间O(n)没有那么敏感。更重视资源的利用）</p>
<p>redis使用自己实现的字符串结构，代码如下：</p>
<p>sds.h sds.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> len; <span class="comment">/* used */</span>  </span><br><span class="line">    <span class="type">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中 </p>
<ul>
<li>len 代表字符串长度</li>
<li>alloc 代表分配空间长度</li>
<li>flag 代表sds类型（ sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64。）</li>
<li>buf 是字节数组</li>
</ul>
<p>5种sds类型的主要<strong>区别就在于，它们数据结构中的 len 和 alloc 成员变量的数据类型不同</strong>。</p>
<p>例如sdshdr32 表示表示字符数组长度和分配空间大小不能超过 2 的 32 次方。</p>
<h3 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h3><p>除了设计不同类型的结构体，Redis 在编程上还<strong>使用了专门的编译优化来节省内存空间</strong>，即在 struct 声明了 <code>__attribute__ ((packed))</code> ，它的作用是：<strong>告诉编译器取消结构体在编译过程中的优化对齐，按照实际占用字节数进行对齐</strong>。</p>
<p>比如，sdshdr16 类型的 SDS，默认情况下，编译器会按照 2 字节对齐的方式给变量分配内存，这意味着，即使一个变量的大小不到 2 个字节，编译器也会给它分配 2 个字节。</p>
<p>举个例子，假设下面这个结构体，它有两个成员变量，类型分别是 char 和 int，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test1</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"> &#125; test1;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>, <span class="keyword">sizeof</span>(test1));<span class="comment">// 8</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果输出是8</p>
<p>对应内存的分配：</p>
<img src="/2022/10/05/redis/alloc-1.png" class="">



<p>这是因为默认情况下，编译器是使用「字节对齐」的方式分配内存，虽然 char 类型只占一个字节，但是由于成员变量里有 int 类型，它占用了 4 个字节，所以在成员变量为 char 类型分配内存时，会分配 4 个字节，其中这多余的 3 个字节是为了字节对齐而分配的，相当于有 3 个字节被浪费掉了。</p>
<p>如果不想编译器使用字节对齐的方式进行分配内存，可以采用了 <code>__attribute__ ((packed))</code> 属性定义结构体，这样一来，结构体实际占用多少内存空间，编译器就分配多少空间。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>((<span class="title">packed</span>)) <span class="title">test2</span>  &#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"> &#125; test2;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>, <span class="keyword">sizeof</span>(test2));</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时打印的结果是 5（1 个字节 char + 4 字节 int）。</p>
<img src="/2022/10/05/redis/alloc-2.png" class="">



<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>redis数据结构如下：</p>
<p>adlist.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="type">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>



<p>结构如下图：</p>
<img src="/2022/10/05/redis/redis-linklist.png" class="">



<p>链表的缺陷:</p>
<ul>
<li>链表每个节点之间的内存都是不连续的，意味着<strong>无法很好利用 CPU 缓存</strong>。能很好利用 CPU 缓存的数据结构就是数组，因为数组的内存是连续的，这样就可以充分利用 CPU 缓存来加速访问。</li>
<li>还有一点，保存一个链表节点的值都需要一个链表节点结构头的分配，<strong>内存开销较大</strong>。</li>
</ul>
<p>因此，Redis在数据量较小的情况下会使用压缩列表来存储节省空间。</p>
<h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><p>&#x2F;&#x2F; 内存紧凑型的数据结构,，占用一块连续的内存空间，不仅可以利用 CPU 缓存</p>
<p>&#x2F;&#x2F;优缺点</p>
<p>&#x2F;&#x2F; 连锁更新问题</p>
<p>&#x2F;&#x2F;ziplist</p>
<p>&#x2F;&#x2F;quicklist</p>
<p>&#x2F;&#x2F;listpack</p>
<p>redis5.0 引进了一个新的数据结构listpack，他是对ziplist结构的改进版本，在存储空间上会更加节省。</p>
<p>&#x2F;&#x2F; 连锁更新问题</p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>代码如下：</p>
<p>dict.h dict.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *key; <span class="comment">//键值对中的键</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125; v; <span class="comment">//键值对中的值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span> <span class="comment">//指向下一个哈希表节点，形成链表</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="type">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="type">int</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>dictEntry 结构里不仅包含指向键和值的指针，还包含了指向下一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对链接起来，以此来解决哈希冲突的问题。</p>
<p>结构如下图：</p>
<img src="/2022/10/05/redis/redis-hash-1.png" class="">



<h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><p>整数集合是 Set 对象的底层实现之一。当一个 Set 对象只包含整数值元素，并且元素数量不大时，就会使用整数集这个数据结构作为底层实现。</p>
<p>intset.h intset.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding; <span class="comment">//编码方式</span></span><br><span class="line">    <span class="type">uint32_t</span> length; <span class="comment">//集合包含的元素数量</span></span><br><span class="line">    <span class="type">int8_t</span> contents[]; <span class="comment">//保存元素的数组</span></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<p>可以看到，保存元素的容器是一个 contents 数组，虽然 contents 被声明为 int8_t 类型的数组，但是实际上 contents 数组并不保存任何 int8_t 类型的元素，contents 数组的真正类型取决于 intset 结构体里的 encoding 属性的值。比如：</p>
<ul>
<li>如果 encoding 属性值为 INTSET_ENC_INT16，那么 contents 就是一个 int16_t 类型的数组，数组中每2个元素当作一个元素，类型都是 int16_t；</li>
<li>如果 encoding 属性值为 INTSET_ENC_INT32，那么 contents 就是一个 int32_t 类型的数组，数组中每2个元素当作一个元素，类型都是 int32_t；</li>
<li>如果 encoding 属性值为 INTSET_ENC_INT64，那么 contents 就是一个 int64_t 类型的数组，数组中每8个元素当作一个元素，类型都是 int64_t；</li>
</ul>
<h3 id="整数集合升级"><a href="#整数集合升级" class="headerlink" title="整数集合升级"></a>整数集合升级</h3><p>整数集合会有一个升级规则，就是当我们将一个新元素加入到整数集合里面，如果新元素的类型（int32_t）比整数集合现有所有元素的类型（int16_t）都要长时，整数集合需要先进行升级，也就是按新元素的类型（int32_t）扩展 contents 数组的空间大小，然后才能将新元素加入到整数集合里，当然升级的过程中，也要维持整数集合的有序性。</p>
<p>整数集合升级的过程不会重新分配一个新类型的数组，而是在原本的数组上扩展空间，然后在将每个元素按间隔类型大小分割，如果 encoding 属性值为 INTSET_ENC_INT16，则每个元素的间隔就是 16 位。</p>
<p>举个例子，假设有一个整数集合里有 3 个类型为 int16_t 的元素。</p>
<p>现在，往这个整数集合中加入一个新元素 65535，这个新元素需要用 int32_t 类型来保存，所以整数集合要进行升级操作，首先需要为 contents 数组扩容，<strong>在原本空间的大小之上再扩容多 80 位（4x32-3x16&#x3D;80），这样就能保存下 4 个类型为 int32_t 的元素</strong>。</p>
<img src="/2022/10/05/redis/redis-intset-1.png" class="">

<p>扩容完 contents 数组空间大小后，需要将之前的三个元素转换为 int32_t 类型，并将转换后的元素放置到正确的位上面，并且需要维持底层数组的有序性不变，整个转换过程如下：</p>
<img src="/2022/10/05/redis/redis-intset-2.png" class="">







<h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>





<p>&#x2F;&#x2F; todo 说明跳表的结构，增删改查过程，从概率上讲为什么时间复杂度是 logN</p>
<h2 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    quicklistNode *head;</span><br><span class="line">    quicklistNode *tail;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> count;        <span class="comment">/* total count of all entries in all ziplists */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> len;           <span class="comment">/* number of quicklistNodes */</span></span><br><span class="line">    <span class="type">int</span> fill : <span class="number">16</span>;              <span class="comment">/* fill factor for individual nodes */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> compress : <span class="number">16</span>; <span class="comment">/* depth of end nodes not to compress;0=off */</span></span><br><span class="line">&#125; quicklist;</span><br></pre></td></tr></table></figure>



<img src="/2022/10/05/redis/redis-quicklist.png" class="">



<hr>
<p>&#x2F;&#x2F; todo 写listpack</p>
<p>&#x2F;&#x2F; todo 写cluster设计，槽迁移</p>
<p>&#x2F;&#x2F; todo 写stream 数据结构</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag"># 数据库</a>
              <a href="/tags/database/" rel="tag"># database</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/10/02/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" rel="prev" title="分布式事务">
      <i class="fa fa-chevron-left"></i> 分布式事务
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/10/07/%E5%88%86%E5%B8%83%E5%BC%8F%E8%B0%83%E7%94%A8-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/" rel="next" title="服务发现">
      服务发现 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%BA%94%E7%94%A8"><span class="nav-number">1.</span> <span class="nav-text">基本数据结构和应用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%8D%E5%9B%BE"><span class="nav-number">2.</span> <span class="nav-text">位图</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8"><span class="nav-number">2.1.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">2.2.</span> <span class="nav-text">原理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HyperLogLog"><span class="nav-number">3.</span> <span class="nav-text">HyperLogLog</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-1"><span class="nav-number">3.1.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-1"><span class="nav-number">3.2.</span> <span class="nav-text">原理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#GEO%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%E8%AE%A1%E7%AE%97"><span class="nav-number">4.</span> <span class="nav-text">GEO地理位置计算</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-2"><span class="nav-number">4.1.</span> <span class="nav-text">使用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">5.</span> <span class="nav-text">分布式锁</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%99%90%E6%B5%81"><span class="nav-number">6.</span> <span class="nav-text">限流</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E9%80%9A%E4%BF%A1"><span class="nav-number">7.</span> <span class="nav-text">队列通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">7.1.</span> <span class="nav-text">消息队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97"><span class="nav-number">7.2.</span> <span class="nav-text">延迟队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85"><span class="nav-number">7.3.</span> <span class="nav-text">发布订阅</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1"><span class="nav-number">8.</span> <span class="nav-text">事务</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%81%8D%E5%8E%86"><span class="nav-number">9.</span> <span class="nav-text">遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">9.1.</span> <span class="nav-text">遍历的是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E4%BD%8D%E8%BF%9B%E4%BD%8D%E5%8A%A0%E6%B3%95"><span class="nav-number">9.2.</span> <span class="nav-text">高位进位加法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B8%90%E8%BF%9B%E5%BC%8Frehash"><span class="nav-number">9.3.</span> <span class="nav-text">渐进式rehash</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RESP%E5%8D%8F%E8%AE%AE"><span class="nav-number">10.</span> <span class="nav-text">RESP协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%8D%8F%E8%AE%AE%E5%92%8Credis-cli%E9%80%9A%E4%BF%A1"><span class="nav-number">10.1.</span> <span class="nav-text">使用协议和redis-cli通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%8D%8F%E8%AE%AE%E5%92%8Credis-server%E9%80%9A%E4%BF%A1"><span class="nav-number">10.2.</span> <span class="nav-text">使用协议和redis-server通信</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%A1%E9%81%93"><span class="nav-number">11.</span> <span class="nav-text">管道</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E8%BF%9E%E6%8E%A5%E7%9A%84read%E5%92%8Cwrite"><span class="nav-number">11.1.</span> <span class="nav-text">关于连接的read和write</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">12.</span> <span class="nav-text">线程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%8E%9F%E7%90%86"><span class="nav-number">12.1.</span> <span class="nav-text">多路复用原理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">13.</span> <span class="nav-text">持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6"><span class="nav-number">13.1.</span> <span class="nav-text">写时复制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOF%E6%97%A5%E5%BF%97"><span class="nav-number">13.2.</span> <span class="nav-text">AOF日志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RDB"><span class="nav-number">13.3.</span> <span class="nav-text">RDB</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">13.4.</span> <span class="nav-text">混合持久化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5"><span class="nav-number">14.</span> <span class="nav-text">过期策略</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E6%9C%9F%E6%89%AB%E6%8F%8F%E7%AD%96%E7%95%A5"><span class="nav-number">14.1.</span> <span class="nav-text">定期扫描策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%87%92%E6%83%B0%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="nav-number">14.2.</span> <span class="nav-text">懒惰删除策略</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="nav-number">15.</span> <span class="nav-text">淘汰策略</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E6%BA%90%E7%A0%81"><span class="nav-number">16.</span> <span class="nav-text">数据结构的源码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%84%E7%A7%8D%E5%AD%98%E5%82%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%BA%95%E5%B1%82%E4%BD%BF%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">16.1.</span> <span class="nav-text">各种存储的数据结构底层使用的数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#string"><span class="nav-number">16.1.1.</span> <span class="nav-text">string</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List"><span class="nav-number">16.1.2.</span> <span class="nav-text">List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hash"><span class="nav-number">16.1.3.</span> <span class="nav-text">hash</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set"><span class="nav-number">16.1.4.</span> <span class="nav-text">set</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zset"><span class="nav-number">16.1.5.</span> <span class="nav-text">zset</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SDS"><span class="nav-number">16.2.</span> <span class="nav-text">SDS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90"><span class="nav-number">16.2.1.</span> <span class="nav-text">内存对齐</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">16.3.</span> <span class="nav-text">链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8"><span class="nav-number">16.4.</span> <span class="nav-text">压缩列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">16.5.</span> <span class="nav-text">哈希表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88"><span class="nav-number">16.6.</span> <span class="nav-text">整数集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%E5%8D%87%E7%BA%A7"><span class="nav-number">16.6.1.</span> <span class="nav-text">整数集合升级</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%B3%E8%A1%A8"><span class="nav-number">16.7.</span> <span class="nav-text">跳表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#quicklist"><span class="nav-number">16.8.</span> <span class="nav-text">quicklist</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="donscoco"
      src="/images/Misaka.jpg">
  <p class="site-author-name" itemprop="name">donscoco</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/donscoco" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;donscoco" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:donscoco@foxmail.com" title="E-Mail → mailto:donscoco@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/yourname" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:donscoco@gmail.com" title="Google → mailto:donscoco@gmail.com" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/donscoco" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;donscoco" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.facebook.com/don.chen.12" title="FB Page → https:&#x2F;&#x2F;www.facebook.com&#x2F;don.chen.12" rel="noopener" target="_blank"><i class="fab fa-facebook fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">donscoco</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
